{"title":"JavaScript基础知识","uid":"e292dba6baac8421f1f811c59a127952","slug":"JavaScript","date":"2021-04-07T08:34:27.488Z","updated":"2021-04-08T08:44:17.126Z","comments":true,"path":"api/articles/JavaScript.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/231750-16152166709491.jpg","content":"<h2 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h2><blockquote>\n<p>特殊的构造函数，可以分配指定大小的字节空间，空间分配之后不在变化 可以用 slice()方法截取部分</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const buf &#x3D; new ArrayBuffer(16); &#x2F;&#x2F; 16字节\nconst buf1 &#x3D; new ArrayBuffer(16);\nbuf1 &#x3D; buf.slice(4, 10);</code></pre>\n\n<blockquote>\n<p>类似于 malloc<br>malloc 分配失败返回 null ArrayBuffer 抛出错误<br>malloc 可以利用虚拟内存 ArrayBuffer 不超过 Number.MAX_SAFE_InTEGER(2^52 - 1)<br>malloc 不会进行初始化 ArrayBuffer 初始化为 0<br>malloc 自己释放内存 ArrayBuffer 自动释放</p>\n</blockquote>\n<h2 id=\"DataView-文件-I-O-和网络-I-O\"><a href=\"#DataView-文件-I-O-和网络-I-O\" class=\"headerlink\" title=\"DataView(文件 I/O 和网络 I/O )\"></a>DataView(文件 I/O 和网络 I/O )</h2><blockquote>\n<p>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置<br>DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转<br>换。<br>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移<br>量）定位要读取或写入值的位置</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 默认全部使用\n&#x2F;&#x2F; 写入操作\nconst buf &#x3D; new ArrayBuffer(16);\nalert(fullDataView.buffer &#x3D;&#x3D;&#x3D; buf); &#x2F;&#x2F; true\nconst firstHalfDataView &#x3D; new DataView(buf, 0, 8);\nalert(firstHalfDataView.byteOffset); &#x2F;&#x2F; 0\nalert(firstHalfDataView.byteLength); &#x2F;&#x2F; 8\nconst secondHalfDataView &#x3D; new DataView(buf, 8);\nalert(secondHalfDataView.byteOffset); &#x2F;&#x2F; 8\n\n&#x2F;&#x2F; 读操作\n\nconst buf &#x3D; new ArrayBuffer(2);\nconst view &#x3D; new DataView(buf);\n&#x2F;&#x2F; 说明整个缓冲确实所有二进制位都是 0\n&#x2F;&#x2F; 检查第一个和第二个字符\nalert(view.getInt8(0)); &#x2F;&#x2F; 0\nalert(view.getInt8(1)); &#x2F;&#x2F; 0\n&#x2F;&#x2F; 检查整个缓冲\nalert(view.getInt16(0)); &#x2F;&#x2F; 0\n&#x2F;&#x2F; 将整个缓冲都设置为 1\n&#x2F;&#x2F; 255 的二进制表示是 11111111（2^8 - 1）\nview.setUint8(0, 255);\n&#x2F;&#x2F; DataView 会自动将数据转换为特定的 ElementType\n&#x2F;&#x2F; 255 的十六进制表示是 0xFF\nview.setUint8(1, 0xff);\n&#x2F;&#x2F; 现在，缓冲里都是 1 了\n&#x2F;&#x2F; 如果把它当成二补数的有符号整数，则应该是-1\nalert(view.getInt16(0)); &#x2F;&#x2F; -1</code></pre>\n\n<h3 id=\"字节序\"><a href=\"#字节序\" class=\"headerlink\" title=\"字节序\"></a>字节序</h3><blockquote>\n<p>大端对齐或者小端对齐</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const buf &#x3D; new ArrayBuffer(2);\nconst view &#x3D; new DataView(buf);\n&#x2F;&#x2F; 填充缓冲，让第一位和最后一位都是 1\nview.setUint8(0, 0x80); &#x2F;&#x2F; 设置最左边的位等于 1\nview.setUint8(1, 0x01); &#x2F;&#x2F; 设置最右边的位等于 1</code></pre>\n\n<blockquote>\n<p>注：DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p>\n</blockquote>\n<h2 id=\"定型数组\"><a href=\"#定型数组\" class=\"headerlink\" title=\"定型数组\"></a>定型数组</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const ints &#x3D; new Int32Array(buf);\n&#x2F;&#x2F; 方法和普通数组类似</code></pre>\n\n<h2 id=\"Map-amp-amp-Object\"><a href=\"#Map-amp-amp-Object\" class=\"headerlink\" title=\"Map &amp;&amp; Object\"></a>Map &amp;&amp; Object</h2><ul>\n<li>内存占用 (但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对)</li>\n<li>插入性能</li>\n<li>查找速度</li>\n<li>删除性能<br>使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，<br>出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一<br>种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。<br>如果代码涉及大量删除操作，那么毫无疑问应该选择 Map</li>\n</ul>\n<h2 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h2><blockquote>\n<p>WeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。<br>键必须是 Object 或者是继承 Object 的类型</p>\n</blockquote>\n<h3 id=\"弱键\"><a href=\"#弱键\" class=\"headerlink\" title=\"弱键\"></a>弱键</h3><blockquote>\n<p>WeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，<br>不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值<br>对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const vm &#x3D; new WeakMap();\nvm.set(&#123;&#125;, &#39;val&#39;);\n&#x2F;&#x2F; 这个对象没有被其他对象引用 执行完之后就会被回收 变成了空映射</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const wm &#x3D; new WeakMap();\nconst container &#x3D; &#123;\n  key: &#123;&#125;,\n&#125;;\nwm.set(container.key, &#39;val&#39;);\nfunction removeReference() &#123;\n  container.key &#x3D; null;\n&#125;\n&#x2F;&#x2F; 一开始不会被回收 保持着对外的引用 执行完removeReference 就会被回收掉</code></pre>\n\n<h2 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h2><blockquote>\n<p>和 WeakMap 类似</p>\n</blockquote>\n<h2 id=\"可迭代对象\"><a href=\"#可迭代对象\" class=\"headerlink\" title=\"可迭代对象\"></a>可迭代对象</h2><p>for of<br>数组结构<br>扩展运算符<br>Array.from<br>创建集合<br>创建映射<br>Promise.all<br>Promise.rece<br>yield *</p>\n<p>如果对象的原型链上实现了<strong>iterable</strong>接口 也就可以迭代了</p>\n<h2 id=\"迭代器协议\"><a href=\"#迭代器协议\" class=\"headerlink\" title=\"迭代器协议\"></a>迭代器协议</h2><blockquote>\n<p>一种一次使用的对象 用 next()方法遍历对象 返回一个 IteratorResult 对象<br>IterattorResult 有 done value 通过判断这个来判断迭代结果<br>迭代器不是快照 如果迭代的过程中发生了变化 迭代器也会反映变化<br>迭代器维护一个引用 迭代器会阻止来垃圾回收</p>\n</blockquote>\n<h2 id=\"自定义迭代器\"><a href=\"#自定义迭代器\" class=\"headerlink\" title=\"自定义迭代器\"></a>自定义迭代器</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Counter &#123;\n  constructor(limit) &#123;\n    this.count &#x3D; 1;\n    this.limit &#x3D; limit;\n  &#125;\n\n  [Symbol.iterator]() &#123;\n    return &#123;\n      next() &#123;\n        if (this.count &lt;&#x3D; this.limit) &#123;\n          return &#123; done: false, value: this.count++ &#125;;\n        &#125; else &#123;\n          return &#123; done: true, value: undefined &#125;;\n        &#125;\n      &#125;,\n\n      return() &#123;\n        &#x2F;&#x2F; 提前退出\n        console.log(&#39;exiting early&#39;);\n        return &#123; done: true &#125;;\n      &#125;,\n    &#125;;\n  &#125;\n&#125;</code></pre>\n\n<p>如果迭代器没有关闭 可以保存状态 继续执行</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a &#x3D; [1, 2, 3, 4, 5];\nlet iter &#x3D; a[Symbol.iterator]();\n\nfor (let i of iter) &#123;\n  console.log(i);\n  break;\n&#125;\n\n&#x2F;&#x2F; 1\nfor (let i of iter) &#123;\n  console.log(i);\n&#125;\n&#x2F;&#x2F; 2 3 4 5</code></pre>\n\n<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* gen() &#123;&#125;\n&#x2F;&#x2F; 箭头函数不能使用生成器函数\n\nfunction* gen() &#123;&#125;\n\nconst g &#x3D; gen();\n\ng.next(); &#x2F;&#x2F; 返回值类似于一个迭代器\n\ng &#x3D;&#x3D;&#x3D; g[Symbol.iterator]();\n&#x2F;&#x2F;  true\n&#x2F;&#x2F; yeild 会保存当前的作用域 然后执行别的代码 然后返回</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* generatorFn() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nfor (let x of generatorFn()) &#123;\n  console.log(x);\n&#125;\n\n&#x2F;&#x2F; 1 2 3</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* gen(initial) &#123;\n  &#x2F;&#x2F; console.log(initial);\n  console.log(yield);\n  console.log(yield);\n&#125;\n&#x2F;&#x2F; let g &#x3D; gen(&#39;foo&#39;);\nlet g &#x3D; gen();\ng.next(&#39;bar&#39;);\ng.next(&#39;bar&#39;); &#x2F;&#x2F; bar\ng.next(&#39;bar&#39;); &#x2F;&#x2F; bar</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* fn() &#123;\n  return yield &#39;foo&#39;;\n&#125;\n\nlet g &#x3D; fn();\nlet res &#x3D; g.next();\nconsole.log(res);</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function* gen() &#123;\n  yield* [1, 2, 3];\n&#125;\n\nfunction* gen() &#123;\n  for (const x of [1, 2, 3]) &#123;\n    yield x;\n  &#125;\n&#125;\n\nlet g &#x3D; gen();\n\nfor (let x of gen()) &#123;\n  console.log(x);\n&#125;\n&#x2F;&#x2F; yield 会把可迭代对象序列化为一系列单独产生的值</code></pre>\n","feature":true,"text":"ArrayBuffer 特殊的构造函数，可以分配指定大小的字节空间，空间分配之后不在变化 可以用 slice()方法截取部分 const buf &#x3D; new ArrayBuffer(16); &#x2F;&#x2F; 16字节 const buf1 &#x3D; new...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":4,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ArrayBuffer\"><span class=\"toc-text\">ArrayBuffer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DataView-%E6%96%87%E4%BB%B6-I-O-%E5%92%8C%E7%BD%91%E7%BB%9C-I-O\"><span class=\"toc-text\">DataView(文件 I&#x2F;O 和网络 I&#x2F;O )</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E5%BA%8F\"><span class=\"toc-text\">字节序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E5%9E%8B%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">定型数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map-amp-amp-Object\"><span class=\"toc-text\">Map &amp;&amp; Object</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WeakMap\"><span class=\"toc-text\">WeakMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%B1%E9%94%AE\"><span class=\"toc-text\">弱键</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WeakSet\"><span class=\"toc-text\">WeakSet</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">可迭代对象</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">迭代器协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">自定义迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">生成器</span></a></li></ol>","author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""},"mapped":true,"prev_post":{"title":"svelte","uid":"159e1d8888631750dd50b9032a4b1226","slug":"svelte","date":"2021-04-07T12:07:51.000Z","updated":"2021-04-07T12:59:01.271Z","comments":true,"path":"api/articles/svelte.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/114936-15934889760420.jpg","text":"SvelteVue.min.js Vue.runtime.js (dom diff 虚拟 dom) 运行时 React Vue 虚拟 dom ---&gt; dom diff 提升性能? html 输出 domReady 提前 重绘 重排(重新布局) FID FP FCP LCP...","link":"","photos":[],"count_time":{"symbolsCount":497,"symbolsTime":"1 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"svelte","slug":"svelte","count":1,"path":"api/tags/svelte.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}},"next_post":{"title":"Vuex 源码分析","uid":"d99453202fb96ed4663408801fbf0008","slug":"vuex","date":"2021-04-06T14:27:28.497Z","updated":"2021-04-06T14:53:15.200Z","comments":true,"path":"api/articles/vuex.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200716163610402.jpg","text":"vuex 简易实现 let Vue; class ModuleCollection &#123; constructor(options) &#123; this.register([], options); &#125; register(path, rootModule) &...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"vue","slug":"vue","count":3,"path":"api/categories/vue.json"}],"tags":[{"name":"vuex","slug":"vuex","count":2,"path":"api/tags/vuex.json"},{"name":"vue","slug":"vue","count":1,"path":"api/tags/vue.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}}}