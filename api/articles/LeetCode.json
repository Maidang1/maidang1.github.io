{"title":"leetcode学习记录","uid":"46450d7ba5c2c45a066c1b2bc4af0876","slug":"LeetCode","date":"2021-04-06T14:27:28.256Z","updated":"2021-05-16T13:19:03.587Z","comments":true,"path":"api/articles/LeetCode.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20210405000538316.png","content":"<blockquote>\n<p>我是一个算法的菜鸟，在面试的时候经常被算法绊倒在门槛。这篇文章就是记录自己刷 leetcode 的过程，记下来自己对每个问题的理解和想法，把好的想法记录下来，希望读者有帮助。希望自己可以坚持下去，一天写一道题，保持自己对算法的敏感度，保持思考。一起加油！！！</p>\n</blockquote>\n<p><a href=\"https://github.com/Maidang1/leetcode\">前 100 题题解地址链接</a></p>\n<h2 id=\"134-加油站\"><a href=\"#134-加油站\" class=\"headerlink\" title=\"134 加油站\"></a>134 加油站</h2><h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><span id=\"more\"></span>\n\n<blockquote>\n<p>枚举每个站点 然后尝试从这个站点走<strong>n</strong>次, 如果可以顺利走了<strong>n</strong> 次的话 就是可以绕一周，就是题解，如果如果中途不可以继续走下去了，那个 i-j 中的子集部分也不可能走下去了。<br>时间复杂度:O(n)<br>空间复杂度:O(1)</p>\n</blockquote>\n<h3 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; gas\n * @param &#123;number[]&#125; cost\n * @return &#123;number&#125;\n *&#x2F;\nvar canCompleteCircuit &#x3D; function (gas, cost) &#123;\n  let n &#x3D; gas.length;\n\n  let i, j;\n  for (i &#x3D; 0; i &lt; n; ) &#123;\n    let left &#x3D; 0;\n\n    for (j &#x3D; 0; j &lt; n; j++) &#123;\n      let k &#x3D; (i + j) % n;\n      left &#x3D; left + gas[k] - cost[k];\n      if (left &lt; 0) break;\n    &#125;\n\n    if (j &#x3D;&#x3D; n) return i;\n    else i +&#x3D; j + 1;\n  &#125;\n  return -1;\n&#125;;</code></pre>\n\n<h2 id=\"135-分发糖果\"><a href=\"#135-分发糖果\" class=\"headerlink\" title=\"135 分发糖果\"></a>135 分发糖果</h2><h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><blockquote>\n<p>f[i]表示每个孩子分到的糖果，ans = f[0] +f[1] +….+ f[n]。每个孩子最少分到 1 个糖果。把小朋友的积分想象成一个台阶，只要是你的台阶数别两边的高，你的糖果数目必须最大一遍多一个才能保证最少。而且最少的只有一个。</p>\n</blockquote>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; ratings\n * @return &#123;number&#125;\n *&#x2F;\nvar candy &#x3D; function (ratings) &#123;\n  let n &#x3D; ratings.length;\n  let f &#x3D; new Array(n).fill(-1);\n  let w &#x3D; ratings;\n  let ans &#x3D; 0;\n\n  for (let x &#x3D; 0; x &lt; n; x++) &#123;\n    ans +&#x3D; dp(x);\n  &#125;\n\n  return ans;\n\n  function dp(i) &#123;\n    if (f[i] !&#x3D;&#x3D; -1) return f[i]; &#x2F;&#x2F; 分过了糖果不需要再分\n\n    f[i] &#x3D; 1;\n    if (i &amp;&amp; w[i - 1] &lt; w[i]) f[i] &#x3D; Math.max(f[i], dp(i - 1) + 1);\n    if (i + 1 &lt; n &amp;&amp; w[i + 1] &lt; w[i]) f[i] &#x3D; Math.max(f[i], dp(i + 1) + 1);\n\n    return f[i];\n  &#125;\n&#125;;</code></pre>\n\n<h2 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136 只出现一次的数字\"></a>136 只出现一次的数字</h2><h3 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h3><blockquote>\n<p>主要是运用了位操作的异或运算 a^a^b = a^b^a = b</p>\n</blockquote>\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  for (let i &#x3D; 1; i &lt; nums.length; i++) &#123;\n    nums[0] ^&#x3D; nums[i];\n  &#125;\n  return nums[0];\n&#125;;</code></pre>\n\n<h2 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137 只出现一次的数字 II\"></a>137 只出现一次的数字 II</h2><h3 id=\"分析-3\"><a href=\"#分析-3\" class=\"headerlink\" title=\"分析\"></a>分析</h3><blockquote>\n<p>用数组计数的方法<br>使用位运算的操作 位运算 并行运算<br>DFA 思路</p>\n</blockquote>\n<h3 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解 1\"></a>题解 1</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  let res &#x3D; &#123;&#125;;\n\n  nums.reduce((obj, key) &#x3D;&gt; &#123;\n    return obj[key]++ || (obj[key] &#x3D; 1), obj;\n  &#125;, res);\n\n  for (let key in res) &#123;\n    if (res[key] &#x3D;&#x3D;&#x3D; 1) &#123;\n      return key;\n    &#125;\n  &#125;\n&#125;;</code></pre>\n\n<h3 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解 2\"></a>题解 2</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  &#x2F;&#x2F; let one &#x3D; 0, two &#x3D; 0;\n  let ans &#x3D; 0;\n  for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n    let count &#x3D; 0;\n    for (let j &#x3D; 0; j &lt; nums.length; j++) &#123;\n      count +&#x3D; (nums[j] &gt;&gt; i) &amp; 1;\n    &#125;\n    ans +&#x3D; count % 3 &lt;&lt; i;\n  &#125;\n\n  return ans;\n&#125;;\n&#x2F;&#x2F; 统计每一位 是0或者是1</code></pre>\n\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解 3\"></a>题解 3</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  &#x2F;&#x2F; let one &#x3D; 0, two &#x3D; 0;\n  let onceseen &#x3D; 0,\n    secondseen &#x3D; 0;\n  for (let x of nums) &#123;\n    onceseen &#x3D; ~secondseen &amp; (onceseen ^ x);\n    secondseen &#x3D; ~onceseen &amp; (secondseen ^ x);\n  &#125;\n  return onceseen;\n&#125;;</code></pre>\n\n<h2 id=\"138-复制带随机指针的链表\"><a href=\"#138-复制带随机指针的链表\" class=\"headerlink\" title=\"138 复制带随机指针的链表\"></a>138 复制带随机指针的链表</h2><h3 id=\"分析-4\"><a href=\"#分析-4\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p><img src=\"https://cdn.jsdelivr.net/gh/Maidang1/image//image/138.png\" alt=\"分析\"></p>\n<h3 id=\"题解-3\"><a href=\"#题解-3\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * Definition for a Node.\n * function Node(val, next, random) &#123;\n *    this.val &#x3D; val;\n *    this.next &#x3D; next;\n *    this.random &#x3D; random;\n * &#125;;\n *&#x2F;\n\n&#x2F;**\n * @param &#123;Node&#125; head\n * @return &#123;Node&#125;\n *&#x2F;\nvar copyRandomList &#x3D; function (head) &#123;\n  let p &#x3D; head;\n  while (p) &#123;\n    &#x2F;&#x2F; 复制小弟\n    let q &#x3D; new Node(p.val);\n    q.next &#x3D; p.next;\n    p.next &#x3D; q;\n    p &#x3D; q.next;\n  &#125;\n  &#x2F;&#x2F; 复制随机的边\n  for (let p &#x3D; head; p; p &#x3D; p.next.next) &#123;\n    if (p.random) &#123;\n      p.next.random &#x3D; p.random.next;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 拆分链表\n  let dummy &#x3D; new Node(-1),\n    cur &#x3D; dummy;\n\n  for (let p &#x3D; head; p; p &#x3D; p.next) &#123;\n    let q &#x3D; p.next; &#x2F;&#x2F; 小弟\n    cur &#x3D; cur.next &#x3D; q;\n    p.next &#x3D; q.next;\n  &#125;\n\n  return dummy.next;\n&#125;;</code></pre>\n\n<h2 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a>141. 环形链表</h2><h3 id=\"分析-5\"><a href=\"#分析-5\" class=\"headerlink\" title=\"分析\"></a>分析</h3><blockquote>\n<p>快慢指针 有环的话快指针能追上慢指针</p>\n</blockquote>\n<h3 id=\"题解-4\"><a href=\"#题解-4\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * Definition for singly-linked list.\n * function ListNode(val) &#123;\n *     this.val &#x3D; val;\n *     this.next &#x3D; null;\n * &#125;\n *&#x2F;\n\n&#x2F;**\n * @param &#123;ListNode&#125; head\n * @return &#123;boolean&#125;\n *&#x2F;\nvar hasCycle &#x3D; function (head) &#123;\n  if (!head) return false;\n\n  let fast &#x3D; head,\n    slow &#x3D; head;\n\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n\n    if (fast &#x3D;&#x3D;&#x3D; slow) return true;\n  &#125;\n\n  return false;\n&#125;;</code></pre>\n\n<h2 id=\"142-环形链表-II\"><a href=\"#142-环形链表-II\" class=\"headerlink\" title=\"142. 环形链表 II\"></a>142. 环形链表 II</h2><h3 id=\"分析-6\"><a href=\"#分析-6\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p><img src=\"https://assets.leetcode-cn.com/solution-static/142/142_fig1.png\"></p>\n<p>a = c + (n-1) (b+c)</p>\n<h3 id=\"题解-5\"><a href=\"#题解-5\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var detectCycle &#x3D; function (head) &#123;\n  if (head &#x3D;&#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n  let slow &#x3D; head,\n    fast &#x3D; head;\n  while (fast !&#x3D;&#x3D; null) &#123;\n    slow &#x3D; slow.next;\n    if (fast.next !&#x3D;&#x3D; null) &#123;\n      fast &#x3D; fast.next.next;\n    &#125; else &#123;\n      return null;\n    &#125;\n    if (fast &#x3D;&#x3D;&#x3D; slow) &#123;\n      let ptr &#x3D; head;\n      while (ptr !&#x3D;&#x3D; slow) &#123;\n        ptr &#x3D; ptr.next;\n        slow &#x3D; slow.next;\n      &#125;\n      return ptr;\n    &#125;\n  &#125;\n  return null;\n&#125;;</code></pre>\n\n<h2 id=\"143-重排链表\"><a href=\"#143-重排链表\" class=\"headerlink\" title=\"143 重排链表\"></a>143 重排链表</h2><h3 id=\"分析-7\"><a href=\"#分析-7\" class=\"headerlink\" title=\"分析\"></a>分析</h3><blockquote>\n<p>快慢指针 倒置后一半的链表 然后合并</p>\n</blockquote>\n<h3 id=\"题解-6\"><a href=\"#题解-6\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * Definition for singly-linked list.\n * function ListNode(val, next) &#123;\n *     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)\n *     this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next)\n * &#125;\n *&#x2F;\n&#x2F;**\n * @param &#123;ListNode&#125; head\n * @return &#123;void&#125; Do not return anything, modify head in-place instead.\n *&#x2F;\nvar reorderList &#x3D; function (head) &#123;\n  if (!head) return null;\n  let dummy &#x3D; new ListNode(-1);\n  let tail &#x3D; dummy;\n\n  dummy.next &#x3D; head;\n  let fast &#x3D; dummy,\n    slow &#x3D; dummy;\n\n  while (fast &amp;&amp; fast.next) &#123;\n    slow &#x3D; slow.next;\n    fast &#x3D; fast.next.next;\n  &#125;\n\n  let cur &#x3D; new ListNode(-1);\n  cur &#x3D; slow.next;\n  slow.next &#x3D; null;\n\n  let tem &#x3D; new ListNode(-1);\n\n  while (cur) &#123;\n    let c &#x3D; cur.next;\n    cur.next &#x3D; tem.next;\n    tem.next &#x3D; cur;\n    cur &#x3D; c;\n  &#125;\n  cur &#x3D; head;\n  tem &#x3D; tem.next;\n  dummy.next &#x3D; null;\n  tail &#x3D; dummy;\n  while (cur || tem) &#123;\n    if (cur) &#123;\n      dummy &#x3D; dummy.next &#x3D; cur;\n      cur &#x3D; cur.next;\n    &#125;\n    if (tem) &#123;\n      dummy &#x3D; dummy.next &#x3D; tem;\n      tem &#x3D; tem.next;\n    &#125;\n  &#125;\n\n  return tail.next;\n&#125;;</code></pre>\n\n<h2 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a>144. 二叉树的前序遍历</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 递归\nvar preorderTraversal &#x3D; function (root) &#123;\n  let res &#x3D; [];\n  let stack &#x3D; [];\n\n  while (root || stack.length) &#123;\n    while (root) &#123;\n      res.push(root.val);\n      stack.push(root);\n      root &#x3D; root.left;\n    &#125;\n\n    let top &#x3D; stack.pop();\n    root &#x3D; top.right;\n  &#125;\n\n  return res;\n&#125;;</code></pre>\n\n<h2 id=\"145-二叉树的后序遍历\"><a href=\"#145-二叉树的后序遍历\" class=\"headerlink\" title=\"145 二叉树的后序遍历\"></a>145 二叉树的后序遍历</h2><h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 方式一\nvar postorderTraversal &#x3D; function (root) &#123;\n  let res &#x3D; [];\n  let stack &#x3D; [];\n  let prev &#x3D; null;\n  while (root || stack.length) &#123;\n    while (root) &#123;\n      stack.push(root);\n      root &#x3D; root.left;\n    &#125;\n\n    root &#x3D; stack.pop();\n\n    if (root.right &#x3D;&#x3D;&#x3D; null || root.right &#x3D;&#x3D;&#x3D; prev) &#123;\n      res.push(root.val);\n      prev &#x3D; root;\n      root &#x3D; null;\n    &#125; else &#123;\n      stack.push(root);\n      root &#x3D; root.right;\n    &#125;\n  &#125;\n\n  return res;\n&#125;;\n\n&#x2F;&#x2F; 方式二\nvar postorderTraversal &#x3D; function (root) &#123;\n  let res &#x3D; [];\n  let stack &#x3D; [];\n\n  while (root || stack.length) &#123;\n    while (root) &#123;\n      res.push(root.val);\n      stack.push(root);\n      root &#x3D; root.right;\n    &#125;\n\n    root &#x3D; stack.pop().left;\n  &#125;\n\n  return res.reverse();\n&#125;;</code></pre>\n\n\n\n<h2 id=\"146-LRU缓存机制\"><a href=\"#146-LRU缓存机制\" class=\"headerlink\" title=\"146 LRU缓存机制\"></a>146 LRU缓存机制</h2><h3 id=\"分析-8\"><a href=\"#分析-8\" class=\"headerlink\" title=\"分析\"></a>分析</h3><blockquote>\n<p>用hash表存储每一个节点 然后用一个双链表来表示优先级 每次更新的节点全部放到链表头 不使用的放在链表尾部，这样就可以解决了排序的问题 同时删除节点的时候 需要删除的东西都在链表尾部 做到了O(1)的时间复杂度</p>\n</blockquote>\n<h3 id=\"题解-7\"><a href=\"#题解-7\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\nfunction Node(key, value) &#123;\n    this.value &#x3D; value\n    this.key &#x3D; key;\n    this.left &#x3D; null;\n    this.right &#x3D; null\n&#125;\n\nvar LRUCache &#x3D; function (capacity) &#123;\n    this.size &#x3D; 0\n    this.capacity &#x3D; capacity\n    this.head &#x3D; new Node(-1, -1);\n    this.tail &#x3D; new Node(-1, -1)\n    this.head.right &#x3D; this.tail;\n    this.tail.left &#x3D; this.head;\n    this.container &#x3D; new Map()\n&#125;;\n\nLRUCache.prototype.remove &#x3D; function remove(node) &#123;\n    node.right.left &#x3D; node.left;\n    node.left.right &#x3D; node.right\n&#125;\n\nLRUCache.prototype.addToHead &#x3D; function addToHead(node) &#123;\n    node.left &#x3D; this.head\n    node.right &#x3D; this.head.right\n    this.head.right.left &#x3D; node\n    this.head.right &#x3D; node;\n\n&#125;\n\n\nLRUCache.prototype.moveToHead &#x3D; function moveToHead(node) &#123;\n    this.remove(node)\n    this.addToHead(node)\n&#125;\n\n\nLRUCache.prototype.removeTail &#x3D; function removeTail() &#123;\n    let node &#x3D; this.tail.left;\n    this.remove(node)\n    return node\n&#125;\n\nLRUCache.prototype.get &#x3D; function (key) &#123;\n    if (!this.container.has(key)) &#123;\n        return -1\n    &#125;\n\n    let p &#x3D; this.container.get(key);\n    this.moveToHead(p);\n    return p.value;\n\n&#125;;\n\nLRUCache.prototype.put &#x3D; function (key, value) &#123;\n    if (!this.container.has(key)) &#123;\n        let node &#x3D; new Node(key, value);\n        this.container.set(key, node);\n        this.addToHead(node);\n        this.size++;\n        if (this.size &gt; this.capacity) &#123;\n            let removedNode &#x3D; this.removeTail();\n            this.container.delete(removedNode.key);\n            delete removedNode;\n            this.size--;\n        &#125;\n    &#125; else &#123;\n        let node &#x3D; this.container.get(key);\n        node.value &#x3D; value;\n        this.moveToHead(node)\n    &#125;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"147对链表进行插入排序\"><a href=\"#147对链表进行插入排序\" class=\"headerlink\" title=\"147对链表进行插入排序\"></a>147对链表进行插入排序</h2><h3 id=\"题解-8\"><a href=\"#题解-8\" class=\"headerlink\" title=\"题解\"></a>题解</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var insertionSortList &#x3D; function (head) &#123;\n    if (!head) return null;\n    let dummy &#x3D; new ListNode();\n    dummy.next &#x3D; head;\n    head &#x3D; head.next;\n    dummy.next.next &#x3D; null;\n\n\n    while (head) &#123;\n        let tail &#x3D; dummy\n        let p &#x3D; dummy.next;\n        let c &#x3D; null;\n        while (p) &#123;\n            if (head.val &gt; p.val) &#123;\n                p &#x3D; p.next;\n                tail &#x3D; tail.next;\n            &#125; else &#123;\n                c &#x3D; head.next\n                tail.next &#x3D; head;\n                head.next &#x3D; p;\n                break;\n            &#125;\n\n        &#125;\n        if (!p) &#123;\n            tail.next &#x3D; head;\n            head &#x3D; head.next\n            tail.next.next &#x3D; null;\n        &#125; else &#123;\n\n            head &#x3D; c\n        &#125;\n    &#125;\n    return dummy.next;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"149-直线上最多的点数\"><a href=\"#149-直线上最多的点数\" class=\"headerlink\" title=\"149 直线上最多的点数\"></a>149 直线上最多的点数</h2><blockquote>\n<p>用map记下所有斜率的点 注意重合和斜率为0的情况</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[][]&#125; points\n * @return &#123;number&#125;\n *&#x2F;\nvar maxPoints &#x3D; function (points) &#123;\n    let res &#x3D; 0;\n\n    for (let i &#x3D; 0; i &lt; points.length; i++) &#123;\n        let hash &#x3D; new Map();\n        let vs &#x3D; 0;\n        let ss &#x3D; 0;\n\n        for (let j &#x3D; 0; j &lt; points.length; j++) &#123;\n            if (points[i][0] &#x3D;&#x3D;&#x3D; points[j][0] &amp;&amp; points[i][1] &#x3D;&#x3D;&#x3D; points[j][1]) ss++;\n            else if (points[i][0] &#x3D;&#x3D;&#x3D; points[j][0]) vs++;\n            else &#123;\n                let k &#x3D; (points[i][1] - points[j][1]) &#x2F; (points[i][0] - points[j][0]);\n                hash.set(k, hash.get(k) + 1 || 1);\n            &#125;\n\n        &#125;\n        let maxc &#x3D; vs;\n        hash.forEach(val &#x3D;&gt; maxc &#x3D; Math.max(val, maxc))\n        res &#x3D; Math.max(res, maxc + ss)\n    &#125;\n\n    return res;\n&#125;;</code></pre>\n\n\n\n<h2 id=\"150-逆波兰表达式求值\"><a href=\"#150-逆波兰表达式求值\" class=\"headerlink\" title=\"150 逆波兰表达式求值\"></a>150 逆波兰表达式求值</h2><blockquote>\n<p>一个栈模拟运算</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var evalRPN &#x3D; function(tokens) &#123;\n    const stack &#x3D; [];\n    const n &#x3D; tokens.length;\n    for (let i &#x3D; 0; i &lt; n; i++) &#123;\n        const token &#x3D; tokens[i];\n        if (isNumber(token)) &#123;\n            stack.push(parseInt(token));\n        &#125; else &#123;\n            const num2 &#x3D; stack.pop();\n            const num1 &#x3D; stack.pop();\n            if (token &#x3D;&#x3D;&#x3D; &#39;+&#39;) &#123;\n                stack.push(num1 + num2);\n            &#125; else if (token &#x3D;&#x3D;&#x3D; &#39;-&#39;) &#123;\n                stack.push(num1 - num2);\n            &#125; else if (token &#x3D;&#x3D;&#x3D; &#39;*&#39;) &#123;\n                stack.push(num1 * num2);\n            &#125; else if (token &#x3D;&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;\n                stack.push(num1 &#x2F; num2 &gt; 0 ? Math.floor(num1 &#x2F; num2) : Math.ceil(num1 &#x2F; num2));\n            &#125;\n        &#125;\n    &#125;\n    return stack.pop();\n&#125;;\n\nconst isNumber &#x3D; (token) &#x3D;&gt; &#123;\n    return !(&#39;+&#39; &#x3D;&#x3D;&#x3D; token || &#39;-&#39; &#x3D;&#x3D;&#x3D; token || &#39;*&#39; &#x3D;&#x3D;&#x3D; token || &#39;&#x2F;&#39; &#x3D;&#x3D;&#x3D; token );\n&#125;</code></pre>\n\n\n\n<h2 id=\"151-翻转字符串的单词\"><a href=\"#151-翻转字符串的单词\" class=\"headerlink\" title=\"151 翻转字符串的单词\"></a>151 翻转字符串的单词</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;string&#125; s\n * @return &#123;string&#125;\n *&#x2F;\nvar reverseWords &#x3D; function (s) &#123;\n    let k &#x3D; 0;\n    let res &#x3D; []\n    let str &#x3D; &#39;&#39;\n\n    while (k &lt; s.length) &#123;\n        if (s[k] &#x3D;&#x3D;&#x3D; &#39; &#39; &amp;&amp; str.length &#x3D;&#x3D;&#x3D; 0) &#123;\n            k++;\n            continue;\n        &#125; else if (s[k] &#x3D;&#x3D;&#x3D; &#39; &#39; &amp;&amp; str.length !&#x3D;&#x3D; 0) &#123;\n            res.push(str);\n            str &#x3D; &#39;&#39;\n        &#125; else &#123;\n            str +&#x3D; s[k];\n        &#125;\n        k++;\n    &#125;\n\n    if (str.length) res.push(str)\n\n    let tem &#x3D; &#39;&#39;\n    let len &#x3D; res.length - 1;\n    for (let i &#x3D; len; i &gt;&#x3D; 0; i--) &#123;\n        if (i &#x3D;&#x3D;&#x3D; 0) tem +&#x3D; res[i];\n        else &#123;\n            tem +&#x3D; res[i] + &#39; &#39;\n        &#125;\n    &#125;\n    return tem\n&#125;;</code></pre>\n\n\n\n<h2 id=\"152-乘机的最大子数组\"><a href=\"#152-乘机的最大子数组\" class=\"headerlink\" title=\"152 乘机的最大子数组\"></a>152 乘机的最大子数组</h2><blockquote>\n<p>入门级动态规划 需要讨论正数和负数情况</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar maxProduct &#x3D; function (nums) &#123;\n\n    if (nums.length &#x3D;&#x3D;&#x3D; 0) return null;\n    if (nums.length &#x3D;&#x3D;&#x3D; 1) return nums[0]\n    let max &#x3D; []\n    let min &#x3D; []\n    max[0] &#x3D; min[0] &#x3D; nums[0];\n\n\n    for (let i &#x3D; 1; i &lt; nums.length; i++) &#123;\n        max[i] &#x3D; Math.max(max[i - 1] * nums[i], min[i - 1] * nums[i], nums[i]);\n        min[i] &#x3D; Math.min(min[i - 1] * nums[i], max[i - 1] * nums[i], nums[i])\n    &#125;\n\n    return Math.max(...max);\n&#125;;</code></pre>\n\n\n\n<h2 id=\"155-最小栈\"><a href=\"#155-最小栈\" class=\"headerlink\" title=\"155 最小栈\"></a>155 最小栈</h2><blockquote>\n<p>维护两个栈 同时的填入和抛出</p>\n</blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var MinStack &#x3D; function() &#123;\n    this.x_stack &#x3D; [];\n    this.min_stack &#x3D; [Infinity];\n&#125;;\n\nMinStack.prototype.push &#x3D; function(x) &#123;\n    this.x_stack.push(x);\n    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));\n&#125;;\n\nMinStack.prototype.pop &#x3D; function() &#123;\n    this.x_stack.pop();\n    this.min_stack.pop();\n&#125;;\n\nMinStack.prototype.top &#x3D; function() &#123;\n    return this.x_stack[this.x_stack.length - 1];\n&#125;;\n\nMinStack.prototype.getMin &#x3D; function() &#123;\n    return this.min_stack[this.min_stack.length - 1];\n&#125;;</code></pre>\n\n","feature":true,"text":" 我是一个算法的菜鸟，在面试的时候经常被算法绊倒在门槛。这篇文章就是记录自己刷 leetcode 的过程，记下来自己对每个问题的理解和想法，把好的想法记录下来，希望读者有帮助。希望自己可以坚持下去，一天写一道题，保持自己对算法的敏感度，保持思考。一起加油！！！ 前 100 题题解...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"leetcode","slug":"leetcode","count":1,"path":"api/categories/leetcode.json"}],"tags":[{"name":"leetcode","slug":"leetcode","count":1,"path":"api/tags/leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#134-%E5%8A%A0%E6%B2%B9%E7%AB%99\"><span class=\"toc-text\">134 加油站</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C\"><span class=\"toc-text\">135 分发糖果</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-1\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-1\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">136 只出现一次的数字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-2\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-2\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II\"><span class=\"toc-text\">137 只出现一次的数字 II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-3\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-1\"><span class=\"toc-text\">题解 1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-2\"><span class=\"toc-text\">题解 2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-3\"><span class=\"toc-text\">题解 3</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">138 复制带随机指针的链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-4\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-3\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">141. 环形链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-5\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-4\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II\"><span class=\"toc-text\">142. 环形链表 II</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-6\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-5\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">143 重排链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-7\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-6\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">144. 二叉树的前序遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">145 二叉树的后序遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">146 LRU缓存机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90-8\"><span class=\"toc-text\">分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-7\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#147%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">147对链表进行插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3-8\"><span class=\"toc-text\">题解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0\"><span class=\"toc-text\">149 直线上最多的点数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC\"><span class=\"toc-text\">150 逆波兰表达式求值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E8%AF%8D\"><span class=\"toc-text\">151 翻转字符串的单词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#152-%E4%B9%98%E6%9C%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">152 乘机的最大子数组</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#155-%E6%9C%80%E5%B0%8F%E6%A0%88\"><span class=\"toc-text\">155 最小栈</span></a></li></ol>","author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""},"mapped":true,"prev_post":{"title":"connected-react-router","uid":"3a1de7864b72f88f991d2ad903723f46","slug":"connected-react-router","date":"2021-04-06T14:27:28.294Z","updated":"2021-04-06T14:51:00.207Z","comments":true,"path":"api/articles/connected-react-router.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200815152729473.png","text":"index.js import routerMiddlware from &#39;.&#x2F;routerMiddlware&#39;; import connectRouter from &#39;.&#x2F;connectRouter&#39;; import push...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":9,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":9,"path":"api/tags/React.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}},"next_post":{}}