{"title":"proxy 基础学习","uid":"764ea20144bdcb36de34ee7af78c0567","slug":"proxy","date":"2021-04-06T14:27:28.313Z","updated":"2021-04-06T14:51:47.305Z","comments":true,"path":"api/articles/proxy.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200807160832237.jpg","content":"<h2 id=\"代理基础\"><a href=\"#代理基础\" class=\"headerlink\" title=\"代理基础\"></a>代理基础</h2><p><strong>什么是代理</strong></p>\n<p>代理是目标对象的抽象，类似于 c++的指针，可以用作目标的替身，又独立目标之外。</p>\n<span id=\"more\"></span>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(proxy.id);\n\n&#x2F;&#x2F; proxy的prototype是undefined</code></pre>\n\n<p><strong>定义捕获器</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;handler override&#39;;\n  &#125;,\n&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(proxy.id);\n&#x2F;&#x2F; 只有代理才会产生捕获 原来的目标没有这样的行为</code></pre>\n\n<p><strong>反射 API</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;\n  get() &#123;\n    console.log(&#39;get handler&#39;);\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(&#39;----------&#39;, proxy.id);</code></pre>\n\n<p><strong>捕获器不变式</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123;&#125;;\nObject.defineProperty(target, &#39;foo&#39;, &#123;\n  configurable: false,\n  writable: false,\n  value: &#39;bar&#39;,\n&#125;);\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;qux&#39;;\n  &#125;,\n&#125;;\nconst proxy &#x3D; new Proxy(target, handler);\nconsole.log(proxy.foo);</code></pre>\n\n<p><strong>撤销代理</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const target &#x3D; &#123;\n  foo: &#39;bar&#39;,\n&#125;;\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;intercepted&#39;;\n  &#125;,\n&#125;;\nconst &#123; proxy, revoke &#125; &#x3D; Proxy.revocable(target, handler);\nconsole.log(proxy.foo); &#x2F;&#x2F; intercepted\nconsole.log(target.foo); &#x2F;&#x2F; bar\nrevoke();\nconsole.log(proxy.foo); &#x2F;&#x2F; TypeError</code></pre>\n\n<p>**实用反射 API **</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功\nconst o &#x3D; &#123;&#125;;\ntry &#123;\n  Object.defineProperty(o, &#39;foo&#39;, &#39;bar&#39;);\n  console.log(&#39;success&#39;);\n&#125; catch (e) &#123;\n  console.log(&#39;failure&#39;);\n&#125;\n&#x2F;&#x2F; 使用代理之后\n&#x2F;&#x2F; 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。\n&#x2F;&#x2F; 因此使用这个反射方法可以这样重构上面的代码：\n&#x2F;&#x2F; 重构后的代码\nconst o &#x3D; &#123;&#125;;\nif (Reflect.defineProperty(o, &#39;foo&#39;, &#123; value: &#39;bar&#39; &#125;)) &#123;\n  console.log(&#39;success&#39;);\n&#125; else &#123;\n  console.log(&#39;failure&#39;);\n&#125;</code></pre>\n\n<p>其他的<strong>状态标记</strong>反射 API</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Reflect.defineProperty();\nReflect.preventExtensions();\nReflect.setPrototypeOf();\nReflect.set();\nReflect.deleteProperty();</code></pre>\n\n<p><strong>用一等函数替代操作符</strong></p>\n<p>以下反射方法提供只有通过操作符才能完成的操作。</p>\n<p>Reflect.get()：可以替代对象属性访问操作符。</p>\n<p>Reflect.set()：可以替代=赋值操作符。</p>\n<p>Reflect.has()：可以替代 in 操作符或 with()。</p>\n<p>Reflect.deleteProperty()：可以替代 delete 操作符。</p>\n<p>Reflect.construct()：可以替代 new 操作符。</p>\n<p><strong>代理的问题</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const wm &#x3D; new WeakMap();\n\nclass User &#123;\n\n constructor(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n set id(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n get id() &#123;\n\n \treturn wm.get(this);\n\n &#125;\n\n&#125;\n\n由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：\n\nconst user &#x3D; new User(123);\n\nconsole.log(user.id); &#x2F;&#x2F; 123\n\nconst userInstanceProxy &#x3D; new Proxy(user, &#123;&#125;);\n\nconsole.log(userInstanceProxy.id); &#x2F;&#x2F; undefined\n\n&#x2F;&#x2F; 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实\n\n&#x2F;&#x2F; 例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代\n\n&#x2F;&#x2F; 理的实例就会以代理实例作为 WeakMap 的键了：\n\nconst UserClassProxy &#x3D; new Proxy(User, &#123;&#125;);\n\nconst proxyUser &#x3D; new UserClassProxy(456);\n\nconsole.log(proxyUser.id);  &#x2F;&#x2F;</code></pre>\n\n<p><strong>代理与内部槽位</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;*\n代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可\n能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的\n内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通\n的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：\n*&#x2F;\nconst target &#x3D; new Date();\nconst proxy &#x3D; new Proxy(target, &#123;&#125;);\nconsole.log(proxy instanceof Date); &#x2F;&#x2F; true\nproxy.getDate(); &#x2F;&#x2F; TypeError: &#39;this&#39; is not a Date object</code></pre>\n\n<h2 id=\"代理捕获器\"><a href=\"#代理捕获器\" class=\"headerlink\" title=\"代理捕获器\"></a>代理捕获器</h2><p><strong>get()</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  get(target, property, receiver) &#123;\n    console.log(&#39;get()&#39;);\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;);\nproxy.foo;</code></pre>\n\n<p>拦截的操作</p>\n<blockquote>\n<p>proxy.property</p>\n<p>proxy[property]</p>\n<p>Object.create(proxy)[property]</p>\n<p>Reflect.get(proxy, property, receiver)</p>\n</blockquote>\n<p><strong>set</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  set(target, property, value, receiver) &#123;\n    console.log(&#39;set()&#39;);\n    return Reflect.set(...arguments);\n  &#125;,\n&#125;);\nproxy.foo &#x3D; &#39;bar&#39;;\n&#x2F;&#x2F; 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。</code></pre>\n\n<p>拦截的操作</p>\n<blockquote>\n<p>proxy.property = value</p>\n<p>proxy[property] = value</p>\n<p>Object.create(proxy)[property] = value</p>\n<p>Reflect.set(proxy, property, value, receiver)</p>\n</blockquote>\n<p><strong>has</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  has(target, property) &#123;\n    console.log(&#39;has()&#39;);\n    return Reflect.has(...arguments);\n  &#125;,\n&#125;);\n&#39;foo&#39; in proxy;\n&#x2F;&#x2F; has()</code></pre>\n\n<blockquote>\n<p>property in proxy</p>\n<p>property in Object.create(proxy)</p>\n<p>with(proxy) {(property);}</p>\n<p>Reflect.has(proxy, property)</p>\n</blockquote>\n<p><strong>defineProperty()</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  defineProperty(target, property, descriptor) &#123;\n    console.log(&#39;defineProperty()&#39;);\n    return Reflect.defineProperty(...arguments);\n  &#125;,\n&#125;);\nObject.defineProperty(proxy, &#39;foo&#39;, &#123; value: &#39;bar&#39; &#125;);\n&#x2F;&#x2F; Object.defineProperty(proxy, property, descriptor)\n&#x2F;&#x2F; Reflect.defineProperty(proxy, property, descriptor)</code></pre>\n\n<p><strong>getOwnPropertyDescriptor</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  getOwnPropertyDescriptor(target, property) &#123;\n    console.log(&#39;getOwnPropertyDescriptor()&#39;);\n    return Reflect.getOwnPropertyDescriptor(...arguments);\n  &#125;,\n&#125;);\nObject.getOwnPropertyDescriptor(proxy, &#39;foo&#39;);\n&#x2F;&#x2F; getOwnPropertyDescriptor()\n\n&#x2F;&#x2F; Object.getOwnPropertyDescriptor(proxy, property)\n&#x2F;&#x2F; Reflect.getOwnPropertyDescriptor(proxy, property)</code></pre>\n\n<p><strong>deleteProperty</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  deleteProperty(target, property) &#123;\n    console.log(&#39;deleteProperty()&#39;);\n    return Reflect.deleteProperty(...arguments);\n  &#125;,\n&#125;);\ndelete proxy.foo;\n&#x2F;&#x2F; deleteProperty()\n&#x2F;*\n    delete proxy.property\n    delete proxy[property]\n    Reflect.deleteProperty(proxy, property)\n*&#x2F;</code></pre>\n\n<p><strong>ownKeys</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  ownKeys(target) &#123;\n    console.log(&#39;ownKeys()&#39;);\n    return Reflect.ownKeys(...arguments);\n  &#125;,\n&#125;);\nObject.keys(proxy);\n&#x2F;&#x2F; ownKeys()\n&#x2F;*\n    Object.getOwnPropertyNames(proxy)\n    Object.getOwnPropertySymbols(proxy)\n    Object.keys(proxy)\n    Reflect.ownKeys(proxy)\n*&#x2F;</code></pre>\n\n<p><strong>getPrototypeOf</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  getPrototypeOf(target) &#123;\n    console.log(&#39;getPrototypeOf()&#39;);\n    return Reflect.getPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.getPrototypeOf(proxy);\n&#x2F;&#x2F; getPrototypeOf()\n\n&#x2F;*\n    Object.getPrototypeOf(proxy)\n    Reflect.getPrototypeOf(proxy)\n    proxy.__proto__\n    Object.prototype.isProt\n*&#x2F;</code></pre>\n\n<p><strong>setPrototypeOf</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  setPrototypeOf(target, prototype) &#123;\n    console.log(&#39;setPrototypeOf()&#39;);\n    return Reflect.setPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.setPrototypeOf(proxy, Object);\n&#x2F;&#x2F; setPrototypeOf()\n\n&#x2F;*\n    Object.setPrototypeOf(proxy)\n    Reflect.setPrototypeOf(proxy)\n*&#x2F;</code></pre>\n\n<p><strong>isExtensible</strong></p>\n<p><strong>preventExtensions</strong></p>\n<p><strong>apply</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; () &#x3D;&gt; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  apply(target, thisArg, ...argumentsList) &#123;\n    console.log(&#39;apply()&#39;);\n    return Reflect.apply(...arguments);\n  &#125;,\n&#125;);\nproxy();\n&#x2F;*\n    proxy(...argumentsList)\n    Function.prototype.apply(thisArg, argumentsList)\n    Function.prototype.call(thisArg, ...argumentsList)\n    Reflect.apply(target, thisArgument, argumentsList)\n*&#x2F;</code></pre>\n\n<p><strong>construct</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const myTarget &#x3D; function () &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  construct(target, argumentsList, newTarget) &#123;\n    console.log(&#39;construct()&#39;);\n    return Reflect.construct(...arguments);\n  &#125;,\n&#125;);\nnew proxy();\n&#x2F;&#x2F; construct()\n&#x2F;*\n    new proxy(...argumentsList)\n    Reflect.construct(target, argumentsList, newTarget)\n*&#x2F;</code></pre>\n","feature":null,"text":"代理基础什么是代理 代理是目标对象的抽象，类似于 c++的指针，可以用作目标的替身，又独立目标之外。 const target &#x3D; &#123; id: &#39;target&#39;, &#125;; const handler &#x3D; &#123;&#125...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">代理基础</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8\"><span class=\"toc-text\">代理捕获器</span></a></li></ol>","author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""},"mapped":true,"prev_post":{"title":"react base","uid":"b9a37f021de474295d3010955ace362e","slug":"react-base","date":"2021-04-06T14:27:28.342Z","updated":"2021-04-06T14:52:27.491Z","comments":true,"path":"api/articles/react-base.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200716163610402.jpg","text":"生命周期(老版) import React, &#123; Component &#125; from &#39;react&#39;; class LifeCycle extends Component &#123; &#x2F;**组件的静态属性 *&#x2F; static...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[{"name":"React","slug":"React","count":7,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":7,"path":"api/tags/React.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}},"next_post":{"title":"connected-react-router","uid":"3a1de7864b72f88f991d2ad903723f46","slug":"connected-react-router","date":"2021-04-06T14:27:28.294Z","updated":"2021-04-06T14:51:00.207Z","comments":true,"path":"api/articles/connected-react-router.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200815152729473.png","text":"index.js import routerMiddlware from &#39;.&#x2F;routerMiddlware&#39;; import connectRouter from &#39;.&#x2F;connectRouter&#39;; import push...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"React","slug":"React","count":7,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":7,"path":"api/tags/React.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}}}