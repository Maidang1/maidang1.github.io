{"title":"react base","uid":"b9a37f021de474295d3010955ace362e","slug":"react-fiber","date":"2021-06-21T08:53:45.331Z","updated":"2021-06-23T11:45:37.696Z","comments":true,"path":"api/articles/react-fiber.json","keywords":null,"cover":"https://i.picsum.photos/id/176/1000/400.jpg?hmac=oNXYF0f90DxZNASJJ2C8mFDTH8Oqjp2Y52DlzdSCCas","content":"<h2 id=\"fiber\"><a href=\"#fiber\" class=\"headerlink\" title=\"fiber\"></a>fiber</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let root &#x3D; &#123;\n  key: &quot;A1&quot;,\n  children: [\n    &#123;\n      key: &quot;B1&quot;,\n      children: [&#123; key: &quot;C1&quot;, children: [] &#125;],\n      children: [&#123; key: &quot;C2&quot;, children: [] &#125;],\n    &#125;,\n    &#123;\n      key: &quot;B2&quot;,\n      children: [],\n    &#125;,\n  ],\n&#125;;\n\n&#x2F;*\n            A\n          &#x2F;  \\\n        B1    B2\n      &#x2F;   \\\n     C1   C2\n\n*&#x2F;\n\n&#x2F;&#x2F; 此过程没有办法中断 一个虚拟DOM就是最小的单元\n&#x2F;&#x2F; 递归不可以中断\nfunction walk(vDom) &#123;\n  doWork(vDom);\n  &#x2F;&#x2F; 深度优先\n  vDom.forEach((child) &#x3D;&gt; walk(child));\n&#125;\n\nfunction doWork(vDom) &#123;\n  console.log(vDom.key);\n&#125;\nwork(root);</code></pre>\n\n<p><img src=\"C:\\Users\\ASUS\\Desktop\\01.png\" alt=\"01\"></p>\n<h2 id=\"fiber执行阶段\"><a href=\"#fiber执行阶段\" class=\"headerlink\" title=\"fiber执行阶段\"></a>fiber执行阶段</h2><ul>\n<li>render阶段</li>\n<li>Commit阶段</li>\n</ul>\n<h3 id=\"render阶段\"><a href=\"#render阶段\" class=\"headerlink\" title=\"render阶段\"></a>render阶段</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; element.js\nlet A1 &#x3D; &#123; type:&#39;div&#39;, key: &#39;A1&#39;&#125;\nlet B1 &#x3D; &#123; type:&#39;div&#39;, key: &#39;B1&#39;, return &#39;A1&#39;&#125;\nlet A2 &#x3D; &#123; type:&#39;div&#39;, key: &#39;B2&#39;, return &#39;A1&#39;&#125;\nlet C1 &#x3D; &#123; type:&#39;div&#39;, key: &#39;C1&#39;, return &#39;B1&#39;&#125;\nlet C2 &#x3D; &#123; type:&#39;div&#39;, key: &#39;C2&#39;, return &#39;B2&#39;&#125;\nA1.child &#x3D; B1;\nB1.sibing &#x3D; B2\nB1.child &#x3D; C1\nC1.sibling &#x3D; C2\n\nmodule.exports &#x3D; A1\n\n&#x2F;*\n            A\n          &#x2F;  \n        B1-------B2\n      &#x2F;   \n     C1------C2\n\n*&#x2F;</code></pre>\n\n\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; filer.js\n&#x2F;&#x2F; 顶点开始遍历\n&#x2F;&#x2F; 先儿子 在兄弟 在叔叔\n&#x2F;&#x2F; render阶段\nlet rootFiber &#x3D; require(&#39;element&#39;)\nlet nextUnitOfWork &#x3D; null\n\nfunction workLoop(deadline) &#123;\n    while(nextUnitOfWork &amp;&amp; (deadline.timeRemaining() &gt; 1 || deadline.didTimeout)) &#123; \n        &#x2F;&#x2F; 有需要执行的单元就去执行\n        &#x2F;&#x2F; 这里实现了中断\n        nextUnitOfWork &#x3D; performUnitOfWork(nextUnitOfWork)\n    &#125;\n    \n    if(!nextUnitOfWork) &#123;\n        console.log(&#39;render结束&#39;)\n    &#125; else &#123;\n       requestIdleCallback(workLoop, &#123;timeout: 1000&#125;) \n    &#125;\n&#125;\n\nfunction performUnitOfWork(fiber) &#123;\n    beginWork(fiber)\n    if(fiber.child) &#123;\n        return fiber.child\n    &#125; &#x2F;&#x2F; 没有儿子了 次fiber执行完了\n    while(fiber) &#123;\n        completeUnitOfWork(fiber)\n        if(fiber.sibling) &#123;\n            return fiber.sibling\n        &#125;\n        fiber &#x3D; fiber.return \n    &#125;\n&#125;\n\nfunction beginWork(fiber) &#123;\n    console.log(fiber.key + &#39;开始&#39;)\n&#125;\n\nfunction completeUnitOfWork(fiber) &#123;\n    console.log(fiber.key + &#39;完成&#39;)\n&#125;\n\n\nnextUnitOfWork &#x3D; rootFiber；\n&#x2F;&#x2F; workLoop()\n\nrequestIdleCallback(workLoop, &#123;timeout: 1000&#125;)</code></pre>\n\n\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let style &#x3D; &#123;border: &#39;3px solid red&#39;, margin:&#39;5px&#39;&#125;\nlet element &#x3D;&#96;\n\t&lt;div id&#x3D;&quot;A1&quot; style&#x3D;&#123;style&#125;&gt;\n\t\t&lt;div id&#x3D;&quot;B1&quot; style&#x3D;&#123;style&#125;&gt;\n            &lt;div id&#x3D;&quot;C1&quot; style&#x3D;&#123;style&#125;&gt;&lt;&#x2F;div&gt;\n            &lt;div id&#x3D;&quot;C2&quot; style&#x3D;&#123;style&#125;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;div id&#x3D;&quot;B2&quot; style&#x3D;&#123;style&#125;&gt;&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&#96;\n&#x2F;&#x2F; 编译之后\nReact.createElement(&quot;div&quot;, &#123;id: &quot;A1&quot;&#125;, \n  React.createElement(&quot;div&quot;, &#123;id: &quot;B1&quot;&#125;,\n    React.createElement(&quot;div&quot;, &#123;id: &quot;C1&quot;&#125;), \n    React.createElement(&quot;div&quot;, &#123;id: &quot;C2&quot;&#125;)), \n  React.createElement(&quot;div&quot;, &#123;id: &quot;B2&quot;&#125;)\n);\n&#x2F;&#x2F; createElement(type, props, childrens)\n\n\nimport &#123; ELEMENT_TEXT &#125; from &#39;.&#x2F;constants&#39;\n\nfunction createElement(type, config, ...children) &#123;\n    delete config.__self\n    delete config.__source\n    return &#123;\n        type,\n        props: &#123;\n            ...config,\n            children: children.map((child) &#x3D;&gt; &#123;\n                return typeof child &#x3D;&#x3D;&#x3D; &#39;object&#39; ? child: &#123;\n                    type: ELEMENT_TEXT,\n                    props: &#123; text: child, children: []&#125;\n                &#125;\n            &#125;)\n        &#125;\n        \n    &#125;\n&#125;\n\nconst React &#x3D; &#123;\n    createElement\n&#125;\n\nexport default React</code></pre>\n\n\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n&#x2F;&#x2F; unilsjs\n\n&#x2F;&#x2F; 给一个DOM节点设置一个属性\n&#x2F;&#x2F; dom节点 老的props 新的props\nfunction setProps(dom, oldProps, newProps) &#123;\n    for(let key in oldProps) &#123;\n\n    &#125;\n    for(let key in newProps) &#123;\n        if(key !&#x3D;&#x3D; &#39;children&#39;) &#123;\n            setProp(dom, key, newProps[key])\n        &#125;\n    &#125;\n&#125;\n\n\nfunction setProp(dom, key, value) &#123;\n\n    &#x2F;&#x2F; 判断事件\n    if(&#x2F;^on&#x2F;.test(key)) &#123;\n        dom[key.toLowerCase()] &#x3D; value &#x2F;&#x2F; 没有使用合成事件\n    &#125; else if(key &#x3D;&#x3D;&#x3D; &#39;style&#39;) &#123;\n        if(value) &#123;\n            for(let styleName in value) &#123;\n                dom.style[styleName] &#x3D; value[styleName]\n            &#125;\n        &#125;\n    &#125; else &#123;\n        dom.setAttribute(key, value)\n    &#125;\n&#125;\n</code></pre>\n\n\n\n\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function render(element, container) &#123;\n    let rootFiber &#x3D; &#123;\n        tar: TAR_ROOT,\n        stateNode: container, &#x2F;&#x2F; DOM 元素\n        props: &#123;\n            children: [element] &#x2F;&#x2F; react元素 就是虚拟DOM\n        &#125;\n    &#125;\n    scheduleRoot(rootFiber)\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;*\n\tdiff 阶段 render阶段 任务拆分 进行增量 更新 或者拆分 可以暂停\n\t\t生成fiber 收集effectList\n\tcommit DOM的更新和创建阶段 不能中断\n*&#x2F;\nlet nextUnitOfWork &#x3D; null; &#x2F;&#x2F; 下一个工作单元\nlet workInProgressRoot &#x3D; null; &#x2F;&#x2F; RootFiber应用的根\nfunction scheduleRoot(rootFiber) &#123;\n    workInProgressRoot &#x3D; rootFiber\n    nextUnitOfWork &#x3D; rootFiber\n&#125;\n\nfunction workLoop(deadline) &#123;\n    let shouldYield &#x3D; false\n    while(nextUnitOfWork &amp;&amp; !shouldYield) &#123;\n        nextUnitOfWork &#x3D; perforUnitOfWork(nextUnitOfWork)\n        shouldYield &#x3D; deadline.timeRemaining() &lt; 1\n        \n    &#125;\n    if(!nextUnitOfWork) &#123;\n        console.log(&#39;render结束&#39;)\n    &#125;\n      requestIdleCallback(workLoop, &#123;timeout: 500&#125;)\n    \n&#125;\n\n&#x2F;&#x2F; 这个函数的作用就是返回下一个任务节点 一直遍历整个fiber树\n&#x2F;&#x2F; 一直返回到树根为止\nfunction perforUnitOfWork(currentFiber) &#123;\n    beginWork(currentFiber)\n    if(currentFiber.child) &#123;\n        return currentFiber.child \n    &#125;\n     while(currentFiber) &#123;\n        completeUnitOfWork(currentFiber) \n        if(currentFiber.sibling) &#123;\n            return currentFiber.sibling\n        &#125;\n        currentFiber &#x3D; currentFiber.return\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 创建DOM\n&#x2F;&#x2F; 创建子fiber\nfunction beginWork(currentFiber) &#123;\n    &#x2F;&#x2F; 传入的节点是应用的根节点 rootFiber 做一个特殊的处理\n    if(currentFiber.tag &#x3D;&#x3D;&#x3D; TAG_ROOT) &#123;\n        updateHostRoot(currentFiber)\n    &#125; else if(currentFiber.tag &#x3D;&#x3D;&#x3D; TAG_TEXT) &#123;\n        updateHostText(currentFiber)\n    &#125; else if(currentFiber.tag &#x3D;&#x3D;&#x3D;  TAR_HOST) &#123;\n        updateHost(currentFiber)\n    &#125;\n&#125;\n\n\n&#x2F;&#x2F; 完成的时候 收集副作用的fiber 然后组成 effect list\nfunction completeUnitOfWork(currentFiber) &#123;\n    let returnFiber &#x3D; currentFiber.return\n    if(returnFiber) &#123;\n        const effectTag &#x3D; currentFiber.effectTag;\n        if(effectTag) &#123;\n            returnFiber.firstEffect &#x3D; returnFiber.lastEffect &#x3D; currentFiber;\n        &#125;\n    &#125;\n&#125;\n\n\n\nfunction updateHostRoot(currentFiber) &#123;\n    &#x2F;&#x2F; 先处理自己 如果是原生节点的话 创建真实dom \n    &#x2F;&#x2F; 创建子fiber\n    let newChildren &#x3D; currentFiber.props.children &#x2F;&#x2F; [element]\n    reconcileChildren(currentFiber, newChildren)\n&#125;\n\n\n\nfunction updateHostText(currentFiber) &#123;\n    &#x2F;&#x2F; 如果次fiber没有创建DOM节点\n    if(!currentFiber.stateNode) &#123;\n        currentFiber.stateNode &#x3D; createDOM(currentFiber)\n    &#125;\n&#125;\n\n\nfunction updateHost(currentFiber) &#123;\n    if(!currentFiber.stateNode) &#123;\n        currentFiber.stateNode &#x3D; createDOM(currentFiber)\n    &#125;\n    &#x2F;&#x2F; 创建子节点的fiber\n    const newChildren &#x3D; currentFiber.props.children\n    reconcileChildren(currentFiber, newChildren);\n&#125;\n\n\n\n&#x2F;&#x2F; 此函数用来创建DOM\nfunction createDOM(currentFiber) &#123;\n    if(currentFiber.tag &#x3D;&#x3D;&#x3D; TAG_TEXT) &#123;\n        return document.createTextNode(currentFiber.props.text)\n    &#125; else if(currentFiber.tag &#x3D;&#x3D;&#x3D; TAR_HOST) &#123; &#x2F;&#x2F; div span\n        let stateNode &#x3D; document.createElement(currentFiber.type)\n        updateDOM(stateNode, &#123;&#125;, currentFiber.props)\n        return stateNode;\n    &#125;\n&#125;\n\n\nfunction updateDOM(stateNode, oldProps, newProps) &#123;\n    setProps(stateNode, oldProps, newProps)\n&#125;\n\n\n\n&#x2F;&#x2F; 这个函数会构建出当前节点的所有子fiber节点(没有构建出自己 仅仅构建子fiber)\nfunction reconcileChildren(currentFiber, newChildren) &#123;\n    let newChildIndex &#x3D; 0;\n    let prevSibling; &#x2F;&#x2F; 上一个新节点的fiber\n    &#x2F;&#x2F; 子 fiber 没有遍历完成\n    while(newChildIndex &lt; newChildren.length) &#123;\n        let newChild &#x3D; newChildren[newChildIndex]\n        let tag;\n        if(newChild.type &#x3D;&#x3D;&#x3D; ELEMENT_TEXT) &#123;\n            tag &#x3D; TAR_TEXT; &#x2F;&#x2F; 文本节点\n        &#125; else if(typeof newChild.type &#x3D;&#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n            tag &#x3D; TAR_HOST &#x2F;&#x2F; type 是字符串的话 那么就是一个原生节点\n        &#125;\n        &#x2F;&#x2F; beginWork 的时候 创建fiber\n        &#x2F;&#x2F; completeUnitOfWork 的时候 收集effect\n        let newFiber &#x3D; &#123;\n            tag,\n            type: newChild.type,\n            props: newChild.props,\n            stateNode: null,\n            return currentFiber, &#x2F;&#x2F; 返回的节点是父节点\n            effectTag: PLACEMENT,\n            nextEffect: null &#x2F;&#x2F; 下一个effectList 也是一个链表\n            &#x2F;&#x2F; effect list 和遍历的顺序是一样的 可能有的节点没有effect\n            &#x2F;&#x2F; 节点可能会少\n        &#125;\n        if(newFiber) &#123;\n            if(newChildIndex &#x3D;&#x3D;&#x3D; 0) &#123;\n                currentFiber.child &#x3D; newFiber;\n            &#125; else &#123;\n                prevSibling.sibling &#x3D; newFiber\n               &#x2F;&#x2F; 串联所有的fiber\n            &#125;\n            prevSibling &#x3D; newFiber;\n        &#125;\n        newChildIndex++;\n    &#125;\n&#125;\n\n\n\nrequestIdleCallback(workLoop, &#123;timeout: 500&#125;)</code></pre>\n\n\n\n\n\n\n\n<h2 id=\"constants-js\"><a href=\"#constants-js\" class=\"headerlink\" title=\"constants.js\"></a>constants.js</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export const ELEMENT_TEXT &#x3D; Symbol.for(&#39;ELEMENT_TEXT&#39;); &#x2F;&#x2F; 文本元素\nexport const TAR_ROOT &#x3D; Symbol.for(&#39;TAR_ROOT&#39;); &#x2F;&#x2F; 根节点\nexport const TAR_HOST &#x3D; Symbol.for(&#39;TAR_HOST&#39;); &#x2F;&#x2F; 原生节点\nexport const TAR_TEXT &#x3D; Symbol.for(&#39;TAR_TEXT&#39;); &#x2F;&#x2F; 文本节点\n\n&#x2F;&#x2F; 关于副作用的更新\nexport const PLACEMENT &#x3D; Symbol.for(&#39;PLACEMENT&#39;); &#x2F;&#x2F; 插入节点\nexport const UPDATE &#x3D; Symbol.for(&#39;UPDATE&#39;); &#x2F;&#x2F; 更新节点\nexport const DELETION &#x3D; Symbol.for(&#39;DELETION&#39;); &#x2F;&#x2F; 删除节点</code></pre>\n\n","feature":null,"text":"fiberlet root &#x3D; &#123; key: &quot;A1&quot;, children: [ &#123; key: &quot;B1&quot;, children: [&#123; key: &quot;C1&quot;, children: []...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"React","slug":"React","count":9,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":9,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fiber\"><span class=\"toc-text\">fiber</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#fiber%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">fiber执行阶段</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#render%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">render阶段</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#constants-js\"><span class=\"toc-text\">constants.js</span></a></li></ol>","author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""},"mapped":true,"prev_post":{},"next_post":{"title":"cssnext介绍以及使用","uid":"f7da3a6dbd8139fcbf33c613ff852d63","slug":"cssnext介绍以及使用","date":"2021-05-16T07:26:00.000Z","updated":"2021-05-16T07:39:59.060Z","comments":true,"path":"api/articles/cssnext介绍以及使用.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200716163610402.jpg","text":"什么是cssnext PostCSS-cssnext is a PostCSS plugin that helps you to use the latest CSS syntax today. It transforms new CSS specs into more comp...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}}}