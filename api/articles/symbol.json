{"title":"Symbol 基础学习","uid":"ba2efac7316616866db1719079267951","slug":"symbol","date":"2021-04-06T14:27:28.412Z","updated":"2021-04-06T14:53:18.661Z","comments":true,"path":"api/articles/symbol.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200716163610402.jpg","content":"<h2 id=\"Symbol-内置符号\"><a href=\"#Symbol-内置符号\" class=\"headerlink\" title=\"Symbol 内置符号\"></a>Symbol 内置符号</h2><blockquote>\n<p>ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道 <strong>for-of</strong> 循环会在相关对象上使用 <strong>Symbol.iterator</strong> 属性，那么就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p><strong>Symbol.asyncIterator</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; for-await-of 实现调用\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max &#x3D; max;\n    this.asyncIdx &#x3D; 0;\n  &#125;\n  async *[Symbol.asyncIterator]() &#123;\n    while (this.asyncIdx &lt; this.max) &#123;\n      yield new Promise((resolve) &#x3D;&gt; resolve(this.asyncIdx++));\n    &#125;\n  &#125;\n&#125;\nasync function asyncCount() &#123;\n  let emitter &#x3D; new Emitter(5);\n  for await (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\nasyncCount();\n&#x2F;&#x2F; 0 1 2 3 4</code></pre>\n\n<p><strong>Symbol.hasInstance</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; instanceof 调用</code></pre>\n\n<p><strong>Symbol.isConcatSpreadable</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 使用concat的时候会不会被打平\nlet initial &#x3D; [&#39;foo&#39;];\nlet arrayLikeObject &#x3D; &#123; length: 1, 0: &#39;baz&#39; &#125;;\nconsole.log(arrayLikeObject[Symbol.isConcatSpreadable]); &#x2F;&#x2F; undefined\nconsole.log(initial.concat(arrayLikeObject)); &#x2F;&#x2F; [&#39;foo&#39;, &#123;...&#125;]\narrayLikeObject[Symbol.isConcatSpreadable] &#x3D; true;\nconsole.log(initial.concat(arrayLikeObject)); &#x2F;&#x2F; [&#39;foo&#39;, &#39;baz&#39;]\n&#x2F;*\n  [ &#39;foo&#39;, &#123; &#39;0&#39;: &#39;baz&#39;, length: 1 &#125; ]\n  [ &#39;foo&#39;, &#39;baz&#39; ]\n*&#x2F;</code></pre>\n\n<p><strong>Symbol.iterator</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Emitter &#123;\n  constructor(max) &#123;\n    this.max &#x3D; max;\n    this.idx &#x3D; 0;\n  &#125;\n  *[Symbol.iterator]() &#123;\n    while (this.idx &lt; this.max) &#123;\n      yield this.idx++;\n    &#125;\n  &#125;\n&#125;\nfunction count() &#123;\n  let emitter &#x3D; new Emitter(5);\n  for (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\ncount();</code></pre>\n\n<p><strong>Symbol.match</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; String.prototype.match() 调用</code></pre>\n\n<p><strong>Symbol.replace</strong><br><strong>Symbol.search</strong><br><strong>Symbol.split</strong></p>\n<p><strong>Symbol.toPrimitive</strong><br><strong>Symbol.toStringTag</strong></p>\n","feature":null,"text":"Symbol 内置符号 ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/categories/JavaScript.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Symbol-%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">Symbol 内置符号</span></a></li></ol>","author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""},"mapped":true,"prev_post":{"title":"dataFetchHook","uid":"eb7ed51aa22769817771964a330ff0d5","slug":"useFetchData","date":"2021-04-06T14:27:28.438Z","updated":"2021-04-06T14:53:18.660Z","comments":true,"path":"api/articles/useFetchData.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200716163610402.jpg","text":"Encapsulating data request with hook import React, &#123; Fragment, useState, useEffect &#125; from &#39;react&#39;; import axios from &#39;...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"React","slug":"React","count":7,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":7,"path":"api/tags/React.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}},"next_post":{"title":"redux && redux-middleware","uid":"f45f275952c50e73ccfd35d25a4b9c92","slug":"redux && redux-middleware","date":"2021-04-06T14:27:28.404Z","updated":"2021-04-06T14:53:18.660Z","comments":true,"path":"api/articles/redux && redux-middleware.json","keywords":null,"cover":"http://img-blog.csdnimg.cn/20200716163610402.jpg","text":"redux import &#123; createStore &#125; from &#39;redux&#39;; let INC &#x3D; Symbol.for(&#39;INC&#39;); let DEC &#x3D; Symbol.for(&#39;DEC&#3...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[{"name":"React","slug":"React","count":7,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":7,"path":"api/tags/React.json"},{"name":"redux","slug":"redux","count":1,"path":"api/tags/redux.json"},{"name":"redux-middleware","slug":"redux-middleware","count":1,"path":"api/tags/redux-middleware.json"}],"author":{"name":"麦当","avatar":"https://cdn.jsdelivr.net/gh/Maidang1/image//image/avatar.jpg","link":""}}}