[{"id":"0d342afe6af4aff548d2b83f7ab3c19b","title":"React哲学","content":"浏览器运行环境js 运行 ---&gt; v8&#x2F;quickJs\n浏览器 js&#x2F;html&#x2F;css &#x3D;&#x3D;&#x3D;&#x3D; 框架\nReact UI框架 ----&gt; 快速响应 配合浏览器的特性开发 不是压榨浏览器性能\n\n环境特点配合框架\n框架有个运行时环境 根据不同的环境生成不同的描述语言 放进不同的容器中\n然后配合生成不同的程序， 配合不同的操作系统\n\n浏览器浏览器进程\n\n网络线程 (dns tcp ip 跨域 mime)\nUI 线程\n文件读写(store)线程\n\n渲染进程\n\n合成线程\n主线程 (js 执行 html 解析 垃圾回收)\ntile work 线程\n\nGPU 进程\n\nGPU 线程 (绘图)\n\n渲染\n资源经过网络线程加载之后 送给合成线程\n一帧进行的操作requestAnimationFrame(上一帧绑定的回调)Parse HTML (DOM 树)Receive Styles （CSSOM）LayoutUI (真正要展示的树 每个节点有相应的属性 宽高 没有层级)Update Layer Tree 层叠上下文 Z 轴(分层)Paint 绘制记录表 (Skia Graphics Library)\n\nComposite (合成阶段)\n光栅化 (切块) CPU(几何数据) ===&gt; GPU(像素点信息结合) 存储\n合成线程返回信息\n{(几何信息): (像素信息 内存地址) 同时标记非快速滚动区域(注册事件)}\n下次渲染 合成线程 (点击的鼠标有位置和非快速滚动区域作比较，不是非快速滚动区域作比较 不需要主线程参与本次更新)\nreact &lt; 17 事件绑定在 document 所以每次都会有主线程react &gt; 17 进行了更加细致的事件绑定\n========&gt; 如何让框架更加契合浏览器的特点\n","slug":"react哲学","date":"2021-04-07T14:08:51.000Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"159e1d8888631750dd50b9032a4b1226","title":"svelte","content":"SvelteVue.min.js\nVue.runtime.js (dom diff 虚拟 dom) 运行时\nReact Vue\n虚拟 dom ---&gt; dom diff\n\n提升性能?\nhtml 输出 domReady 提前\n\n重绘 重排(重新布局)\nFID FP FCP LCP\n\nJQuery 没有响应式\n\nSvelte 相当于 store + 响应式 + JQuery\n\n自己对于 Vue, React, Svelte 的理解现在的框架都是基于响应式的，这样的好处就是我们不要关心对于DOM的操作\n我们只需要注重于数据驱动视图即可。所以Vue, React就是专注于于数据和\n视图。追求的极致就是追求最小的DOM操作，为此诞生出了大名鼎鼎的DOM DIFF\n算法。 通过虚拟DOM 来寻找最小的元素更新。为此出现了一大推的编译，调度\n更新。Svelte并没有虚拟DOM 去直接跟踪最小的元素节点。避免了虚拟DOM的\n大量比对 相当于一个编译器\n\n优点\n编译出来的代码小 状态管理 响应式\nTs Scoped Style\n没有虚拟 dom dom diff\n\n缺点\n组件库 路由 少\n\n","slug":"svelte","date":"2021-04-07T12:07:51.000Z","categories_index":"JavaScript","tags_index":"svelte","author_index":"麦当"},{"id":"e292dba6baac8421f1f811c59a127952","title":"JavaScript基础知识","content":"ArrayBuffer\n特殊的构造函数，可以分配指定大小的字节空间，空间分配之后不在变化 可以用 slice()方法截取部分\n\nconst buf &#x3D; new ArrayBuffer(16); &#x2F;&#x2F; 16字节\nconst buf1 &#x3D; new ArrayBuffer(16);\nbuf1 &#x3D; buf.slice(4, 10);\n\n\n类似于 mallocmalloc 分配失败返回 null ArrayBuffer 抛出错误malloc 可以利用虚拟内存 ArrayBuffer 不超过 Number.MAX_SAFE_InTEGER(2^52 - 1)malloc 不会进行初始化 ArrayBuffer 初始化为 0malloc 自己释放内存 ArrayBuffer 自动释放\n\nDataView(文件 I/O 和网络 I/O )\n必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置\n\n&#x2F;&#x2F; 默认全部使用\n&#x2F;&#x2F; 写入操作\nconst buf &#x3D; new ArrayBuffer(16);\nalert(fullDataView.buffer &#x3D;&#x3D;&#x3D; buf); &#x2F;&#x2F; true\nconst firstHalfDataView &#x3D; new DataView(buf, 0, 8);\nalert(firstHalfDataView.byteOffset); &#x2F;&#x2F; 0\nalert(firstHalfDataView.byteLength); &#x2F;&#x2F; 8\nconst secondHalfDataView &#x3D; new DataView(buf, 8);\nalert(secondHalfDataView.byteOffset); &#x2F;&#x2F; 8\n\n&#x2F;&#x2F; 读操作\n\nconst buf &#x3D; new ArrayBuffer(2);\nconst view &#x3D; new DataView(buf);\n&#x2F;&#x2F; 说明整个缓冲确实所有二进制位都是 0\n&#x2F;&#x2F; 检查第一个和第二个字符\nalert(view.getInt8(0)); &#x2F;&#x2F; 0\nalert(view.getInt8(1)); &#x2F;&#x2F; 0\n&#x2F;&#x2F; 检查整个缓冲\nalert(view.getInt16(0)); &#x2F;&#x2F; 0\n&#x2F;&#x2F; 将整个缓冲都设置为 1\n&#x2F;&#x2F; 255 的二进制表示是 11111111（2^8 - 1）\nview.setUint8(0, 255);\n&#x2F;&#x2F; DataView 会自动将数据转换为特定的 ElementType\n&#x2F;&#x2F; 255 的十六进制表示是 0xFF\nview.setUint8(1, 0xff);\n&#x2F;&#x2F; 现在，缓冲里都是 1 了\n&#x2F;&#x2F; 如果把它当成二补数的有符号整数，则应该是-1\nalert(view.getInt16(0)); &#x2F;&#x2F; -1\n\n字节序\n大端对齐或者小端对齐\n\nconst buf &#x3D; new ArrayBuffer(2);\nconst view &#x3D; new DataView(buf);\n&#x2F;&#x2F; 填充缓冲，让第一位和最后一位都是 1\nview.setUint8(0, 0x80); &#x2F;&#x2F; 设置最左边的位等于 1\nview.setUint8(1, 0x01); &#x2F;&#x2F; 设置最右边的位等于 1\n\n\n注：DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：\n\n定型数组const ints &#x3D; new Int32Array(buf);\n&#x2F;&#x2F; 方法和普通数组类似\n\nMap &amp;&amp; Object\n内存占用 (但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对)\n插入性能\n查找速度\n删除性能使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map\n\nWeakMap\nWeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。键必须是 Object 或者是继承 Object 的类型\n\n弱键\nWeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收\n\nconst vm &#x3D; new WeakMap();\nvm.set(&#123;&#125;, &#39;val&#39;);\n&#x2F;&#x2F; 这个对象没有被其他对象引用 执行完之后就会被回收 变成了空映射\n\nconst wm &#x3D; new WeakMap();\nconst container &#x3D; &#123;\n  key: &#123;&#125;,\n&#125;;\nwm.set(container.key, &#39;val&#39;);\nfunction removeReference() &#123;\n  container.key &#x3D; null;\n&#125;\n&#x2F;&#x2F; 一开始不会被回收 保持着对外的引用 执行完removeReference 就会被回收掉\n\nWeakSet\n和 WeakMap 类似\n\n","slug":"JavaScript","date":"2021-04-07T08:34:27.488Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"d99453202fb96ed4663408801fbf0008","title":"Vuex 源码分析","content":"vuex 简易实现\n\nlet Vue;\n\nclass ModuleCollection &#123;\n  constructor(options) &#123;\n    this.register([], options);\n  &#125;\n\n  register(path, rootModule) &#123;\n    let module &#x3D; &#123;\n      _rawModule: rootModule,\n      _children: &#123;&#125;,\n      state: rootModule.state,\n    &#125;;\n\n    if (path.length &#x3D;&#x3D; 0) &#123;\n      this.root &#x3D; module;\n    &#125;\n\n    if(rootModule.modules) &#123;\n      for\n    &#125;\n  &#125;\n&#125;\n\nclass Store &#123;\n  constructor(options &#x3D; &#123;&#125;) &#123;\n    &#x2F;&#x2F; 状态赋值\n    this.s &#x3D; new Vue(&#123;\n      data() &#123;\n        return &#123; state: options.state &#125;;\n      &#125;,\n    &#125;);\n    let getters &#x3D; options.getters;\n\n    this.getters &#x3D; &#123;&#125;;\n\n    Object.keys(getters).forEach((getterName) &#x3D;&gt; &#123;\n      Object.defineProperty(this.getters, getterName, &#123;\n        get: () &#x3D;&gt; &#123;\n          return getters[getterName](this.state);\n        &#125;,\n      &#125;);\n    &#125;);\n\n    let mutations &#x3D; options.mutations;\n    this.mutations &#x3D; &#123;&#125;;\n    &#x2F;&#x2F; 发布订阅模式\n    Object.keys(mutations).forEach((mutation) &#x3D;&gt; &#123;\n      this.mutations[mutation] &#x3D; (payload) &#x3D;&gt; &#123;\n        mutations[mutation](this.state, payload);\n      &#125;;\n    &#125;);\n\n    &#x2F;&#x2F; action\n\n    let actions &#x3D; options.actions;\n    this.action &#x3D; &#123;&#125;;\n    Object.keys(actions).forEach((action) &#x3D;&gt; &#123;\n      this.actions[action] &#x3D; (payload, fn) &#x3D;&gt; &#123;\n        fn(this, payload);\n      &#125;;\n    &#125;);\n\n    this._modules &#x3D; new ModuleCollection(); &#x2F;&#x2F; 数据格式化\n  &#125;\n\n  dispatch &#x3D; (actionName, payload) &#x3D;&gt; &#123;\n    this.action[actionName](payload);\n  &#125;;\n  &#x2F;&#x2F;提交更改\n  commit &#x3D; (mutationName, payload) &#x3D;&gt; &#123;\n    this.mutations[mutationName](payload);\n  &#125;;\n\n  get state() &#123;\n    return this.s.state;\n  &#125;\n&#125;\n\nconst install &#x3D; (_Vue) &#x3D;&gt; &#123;\n  Vue &#x3D; _Vue; &#x2F;&#x2F; vue构造函数\n\n  Vue.mixin(&#123;\n    beforeCreate() &#123;\n      &#x2F;&#x2F; 需要拿到store 给每个组件增加了$store属性\n      &#x2F;&#x2F; 可能有很多Vue实例 有的不需要store 没有放在Vue原型上面\n      if (this.$options &amp;&amp; this.$options.store) &#123;\n        &#x2F;&#x2F; 给根实例增加$store属性\n        this.$store &#x3D; this.$options.store;\n      &#125; else &#123;\n        &#x2F;&#x2F; 单独创建的实例\n        this.store &#x3D; this.$parent &amp;&amp; this.$parent.store;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;;\n\nexport default &#123;\n  &#x2F;&#x2F; 默认执行 vue方法\n  install,\n&#125;;\n\n","slug":"vuex","date":"2021-04-06T14:27:28.497Z","categories_index":"vue","tags_index":"vuex,vue","author_index":"麦当"},{"id":"b491bd34f265533799a79211838a0e41","title":"Vue3 响应式原理","content":"简单的实现 Vue3 响应式原理\n\nlet toProxy &#x3D; new WeakMap(); &#x2F;&#x2F; 原对象：代理过得对象\nlet toRaw &#x3D; new WeakMap(); &#x2F;&#x2F; 被代理过得对象: 原对象\nfunction isObject(val) &#123;\n  return typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; val !&#x3D;&#x3D; null;\n&#125;\n\nfunction reactive(target) &#123;\n  return createReactiveObject(target);\n&#125;\n\nfunction hasOwn(target, key) &#123;\n  return target.hasOwnProperty(key);\n&#125;\n\nlet proxy &#x3D; reactive(&#123; name: &#39;zf&#39; &#125;);\n\nfunction createReactiveObject(target) &#123;\n  if (!isObject(target)) return target;\n\n  &#x2F;&#x2F; 处理多次代理的操作\n  let proxy &#x3D; toProxy.get(target);\n  if (proxy) return proxy;\n  if (toRaw.has(target)) return target;\n  let baseHandler &#x3D; &#123;\n    get(target, key, receiver) &#123;\n      let res &#x3D; Reflect.get(target, key, receiver);\n      &#x2F;&#x2F; 实现多层代理\n\n      track(target, key);\n      return isObject(res) ? reactive(res) : res;\n    &#125;,\n    set(target, key, value, receiver) &#123;\n      let hadKey &#x3D; hasOwn(target, key);\n      let oldValue &#x3D; target[key];\n      let res &#x3D; Reflect.set(target, key, value, receiver);\n      if (!hadKey) &#123;\n        &#x2F;&#x2F; 增加属性\n        trigger(target, &#39;add&#39;, key);\n      &#125; else if (oldValue !&#x3D;&#x3D; value) &#123;\n        &#x2F;&#x2F; 修改属性 屏蔽没有意义的更新\n        trigger(target, &#39;set&#39;, key);\n      &#125;\n      return res;\n    &#125;,\n    deleteProperty(target, key) &#123;\n      let res &#x3D; Reflect.defineProperty(target, key);\n      return res;\n    &#125;,\n  &#125;;\n  let proxy &#x3D; new Proxy(target, baseHandler);\n  toProxy.set(target, proxy);\n  toRaw.set(proxy, target);\n  return proxy;\n&#125;\n\n&#x2F;&#x2F; 依赖收集 发布订阅\n\nlet activeEffectStacks &#x3D; [];\nlet targetsMap &#x3D; new WeakMap();\nfunction track(target, key) &#123;\n  let effect &#x3D; activeEffectStacks[activeEffectStacks.length - 1];\n  if (effect) &#123;\n    let depMap &#x3D; targetsMap.get(target);\n    if (!depMap) &#123;\n      targetsMap.set(target, (depMap &#x3D; new Map()));\n    &#125;\n    let deps &#x3D; depMap.get(key);\n    if (!deps) &#123;\n      depMap, set(key, (deps &#x3D; new Set()));\n    &#125;\n\n    if (!deps.has(effect)) &#123;\n      deps.add(effect);\n    &#125;\n  &#125;\n&#125;\n\nfunction trigger(target, type, key) &#123;\n  let depsMap &#x3D; targetsMap.get(target);\n  if (depsMap) &#123;\n    let deps &#x3D; depsMap.get(key);\n    if (deps) &#123;\n      deps.forEach((effect) &#x3D;&gt; &#123;\n        effect();\n      &#125;);\n    &#125;\n  &#125;\n&#125;\n\nfunction effect(fn) &#123;\n  &#x2F;&#x2F; fn是响应的\n  let effect &#x3D; createReactiveEffect(fn);\n  effect();\n&#125;\n\nfunction createReactiveEffect(fn) &#123;\n  let effect &#x3D; function () &#123;\n    return run(effect, fn);\n  &#125;;\n  return effect;\n&#125;\n\nfunction run(effect, fn) &#123;\n  try &#123;\n    activeEffectStacks.push(effect);\n    fn();\n  &#125; finally &#123;\n    activeEffectStacks.pop();\n  &#125;\n&#125;\n","slug":"vue3-reactive","date":"2021-04-06T14:27:28.471Z","categories_index":"vue","tags_index":"vue3","author_index":"麦当"},{"id":"eb7ed51aa22769817771964a330ff0d5","title":"dataFetchHook","content":"Encapsulating data request with hook\nimport React, &#123; Fragment, useState, useEffect &#125; from &#39;react&#39;;\nimport axios from &#39;axios&#39;;\n\nfunction App() &#123;\n  const [data, setData] &#x3D; useState(&#123; hits: [] &#125;);\n  const [query, setQuery] &#x3D; useState(&#39;redux&#39;);\n  const [url, setUrl] &#x3D; useState(\n    &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;\n  );\n  const [isLoading, setIsLoading] &#x3D; useState(false);\n  const [isError, setIsError] &#x3D; useState(false);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const fetchData &#x3D; async () &#x3D;&gt; &#123;\n      setIsError(false);\n      setIsLoading(true);\n\n      try &#123;\n        const result &#x3D; await axios(url);\n\n        setData(result.data);\n      &#125; catch (error) &#123;\n        setIsError(true);\n      &#125;\n\n      setIsLoading(false);\n    &#125;;\n\n    fetchData();\n  &#125;, [url]);\n  return (\n    &lt;Fragment&gt;\n      &lt;input\n        type&#x3D;&#39;text&#39;\n        value&#x3D;&#123;query&#125;\n        onChange&#x3D;&#123;(event) &#x3D;&gt; setQuery(event.target.value)&#125;\n      &#x2F;&gt;\n      &lt;button\n        type&#x3D;&#39;button&#39;\n        onClick&#x3D;&#123;() &#x3D;&gt;\n          setUrl(&#96;http:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;$&#123;query&#125;&#96;)\n        &#125;\n      &gt;\n        Search\n      &lt;&#x2F;button&gt;\n\n      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;&#x2F;div&gt;&#125;\n\n      &#123;isLoading ? (\n        &lt;div&gt;Loading ...&lt;&#x2F;div&gt;\n      ) : (\n        &lt;ul&gt;\n          &#123;data.hits.map((item) &#x3D;&gt; (\n            &lt;li key&#x3D;&#123;item.objectID&#125;&gt;\n              &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;\n            &lt;&#x2F;li&gt;\n          ))&#125;\n        &lt;&#x2F;ul&gt;\n      )&#125;\n    &lt;&#x2F;Fragment&gt;\n  );\n&#125;\nexport default App;\n\nCustom hookimport React, &#123; Fragment, useState, useEffect &#125; from &#39;react&#39;;\nimport axios from &#39;axios&#39;;\n\nconst useDataApi &#x3D; (initialUrl, initialData) &#x3D;&gt; &#123;\n  const [data, setData] &#x3D; useState(initialData);\n  const [url, setUrl] &#x3D; useState(initialUrl);\n  const [isLoading, setIsLoading] &#x3D; useState(false);\n  const [isError, setIsError] &#x3D; useState(false);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const fetchData &#x3D; async () &#x3D;&gt; &#123;\n      setIsError(false);\n      setIsLoading(true);\n\n      try &#123;\n        const result &#x3D; await axios(url);\n\n        setData(result.data);\n      &#125; catch (error) &#123;\n        setIsError(true);\n      &#125;\n\n      setIsLoading(false);\n    &#125;;\n\n    fetchData();\n  &#125;, [url]);\n\n  return [&#123; data, isLoading, isError &#125;, setUrl];\n&#125;;\n\nfunction App() &#123;\n  const [query, setQuery] &#x3D; useState(&#39;redux&#39;);\n  const [&#123; data, isLoading, isError &#125;, doFetch] &#x3D; useDataApi(\n    &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;,\n    &#123;\n      hits: [],\n    &#125;\n  );\n\n  return (\n    &lt;Fragment&gt;\n      &lt;form\n        onSubmit&#x3D;&#123;(event) &#x3D;&gt; &#123;\n          doFetch(&#96;http:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;$&#123;query&#125;&#96;);\n\n          event.preventDefault();\n        &#125;&#125;\n      &gt;\n        &lt;input\n          type&#x3D;&#39;text&#39;\n          value&#x3D;&#123;query&#125;\n          onChange&#x3D;&#123;(event) &#x3D;&gt; setQuery(event.target.value)&#125;\n        &#x2F;&gt;\n        &lt;button type&#x3D;&#39;submit&#39;&gt;Search&lt;&#x2F;button&gt;\n      &lt;&#x2F;form&gt;\n\n      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;&#x2F;div&gt;&#125;\n\n      &#123;isLoading ? (\n        &lt;div&gt;Loading ...&lt;&#x2F;div&gt;\n      ) : (\n        &lt;ul&gt;\n          &#123;data.hits.map((item) &#x3D;&gt; (\n            &lt;li key&#x3D;&#123;item.objectID&#125;&gt;\n              &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;\n            &lt;&#x2F;li&gt;\n          ))&#125;\n        &lt;&#x2F;ul&gt;\n      )&#125;\n    &lt;&#x2F;Fragment&gt;\n  );\n&#125;\n\nexport default App;\n","slug":"useFetchData","date":"2021-04-06T14:27:28.438Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"ba2efac7316616866db1719079267951","title":"Symbol 基础学习","content":"Symbol 内置符号\nECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道 for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。\n\n\n\nSymbol.asyncIterator\n&#x2F;&#x2F; for-await-of 实现调用\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max &#x3D; max;\n    this.asyncIdx &#x3D; 0;\n  &#125;\n  async *[Symbol.asyncIterator]() &#123;\n    while (this.asyncIdx &lt; this.max) &#123;\n      yield new Promise((resolve) &#x3D;&gt; resolve(this.asyncIdx++));\n    &#125;\n  &#125;\n&#125;\nasync function asyncCount() &#123;\n  let emitter &#x3D; new Emitter(5);\n  for await (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\nasyncCount();\n&#x2F;&#x2F; 0 1 2 3 4\n\nSymbol.hasInstance\n&#x2F;&#x2F; instanceof 调用\n\nSymbol.isConcatSpreadable\n&#x2F;&#x2F; 使用concat的时候会不会被打平\nlet initial &#x3D; [&#39;foo&#39;];\nlet arrayLikeObject &#x3D; &#123; length: 1, 0: &#39;baz&#39; &#125;;\nconsole.log(arrayLikeObject[Symbol.isConcatSpreadable]); &#x2F;&#x2F; undefined\nconsole.log(initial.concat(arrayLikeObject)); &#x2F;&#x2F; [&#39;foo&#39;, &#123;...&#125;]\narrayLikeObject[Symbol.isConcatSpreadable] &#x3D; true;\nconsole.log(initial.concat(arrayLikeObject)); &#x2F;&#x2F; [&#39;foo&#39;, &#39;baz&#39;]\n&#x2F;*\n  [ &#39;foo&#39;, &#123; &#39;0&#39;: &#39;baz&#39;, length: 1 &#125; ]\n  [ &#39;foo&#39;, &#39;baz&#39; ]\n*&#x2F;\n\nSymbol.iterator\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max &#x3D; max;\n    this.idx &#x3D; 0;\n  &#125;\n  *[Symbol.iterator]() &#123;\n    while (this.idx &lt; this.max) &#123;\n      yield this.idx++;\n    &#125;\n  &#125;\n&#125;\nfunction count() &#123;\n  let emitter &#x3D; new Emitter(5);\n  for (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\ncount();\n\nSymbol.match\n&#x2F;&#x2F; String.prototype.match() 调用\n\nSymbol.replaceSymbol.searchSymbol.split\nSymbol.toPrimitiveSymbol.toStringTag\n","slug":"symbol","date":"2021-04-06T14:27:28.412Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"f45f275952c50e73ccfd35d25a4b9c92","title":"redux && redux-middleware","content":"redux\n\nimport &#123; createStore &#125; from &#39;redux&#39;;\nlet INC &#x3D; Symbol.for(&#39;INC&#39;);\nlet DEC &#x3D; Symbol.for(&#39;DEC&#39;);\nlet initialState &#x3D; 0;\nfunction reducer(state &#x3D; initialState, action) &#123;\n  switch (action.type) &#123;\n    case INC:\n      return state + 1;\n    case DEC:\n      return state - 1;\n    default:\n      return state;\n  &#125;\n&#125;\n\n&#x2F;**\n * redux action有要求 有个不是undefined的type类型\n *&#x2F;\nlet store &#x3D; createStore(reducer);\n\nlet state &#x3D; store.getState();\nlet countValue &#x3D; document.getElementById(&#39;counter-value&#39;);\nlet inc &#x3D; document.getElementById(&#39;inc-btn&#39;);\nlet dec &#x3D; document.getElementById(&#39;dec-btn&#39;);\nconsole.log(state);\n\nfunction render() &#123;\n  countValue.innerHTML &#x3D; store.getState();\n&#125;\n\nrender();\n\nstore.subscribe(render);\n\ninc.addEventListener(&#39;click&#39;, function () &#123;\n  store.dispatch(&#123; type: INC &#125;);\n&#125;);\n\ndec.addEventListener(&#39;click&#39;, function () &#123;\n  store.dispatch(&#123; type: DEC &#125;);\n&#125;);\n\ncreate-store.js(版本一)import isPlainObject from &#39;.&#x2F;utils&#x2F;isPlainObject&#39;;\nimport ActionTypes from &#39;.&#x2F;utils&#x2F;actionType&#39;;\nexport default function createStore(reducer, preloadedState) &#123;\n  if (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new Error(&#39;reducer must be a function&#39;);\n  &#125;\n\n  &#x2F;*******************************&#x2F;\n  &#x2F;** initiallize the base property  *&#x2F;\n  let currentState &#x3D; preloadedState;\n  let currentReducer &#x3D; reducer;\n  let currentListeners &#x3D; [];\n  &#x2F;*******************************&#x2F;\n\n  function getState() &#123;\n    return currentState;\n  &#125;\n\n  function dispatch(action) &#123;\n    if (!isPlainObject(action)) &#123;\n      throw new Error(&#39;action must be a plainObject&#39;);\n    &#125;\n    if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n      throw new Error(&#39;action need a type property&#39;);\n    &#125;\n    currentState &#x3D; currentReducer(currentState, action);\n    for (let i &#x3D; 0; i &lt; currentListeners.length; i++) &#123;\n      let listener &#x3D; currentListeners[i];\n      listener();\n    &#125;\n    return action;\n  &#125;\n\n  dispatch(&#123; type: ActionTypes.INIT &#125;);\n  function subScribe(listener) &#123;\n    currentListeners.push(listener);\n    return function unsubScribe() &#123;\n      const index &#x3D; currentListeners.indexOf(listener);\n      currentListeners.splice(index, 1);\n    &#125;;\n  &#125;\n\n  return &#123;\n    getState,\n    subScribe,\n    dispatch,\n  &#125;;\n&#125;\n\nbindActionCreatorfunction bindActionCreator(actionCreator, dispatch) &#123;\n  return function () &#123;\n    return dispatch(actionCreator.apply(this, arguments));\n  &#125;;\n&#125;\n\nfunction bindActionCreators(actionCreators, dispatch) &#123;\n  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return bindActionCreator(actionCreators, dispatch);\n  &#125;\n  const boundActionCreators &#x3D; &#123;&#125;;\n  for (const key in actionCreators) &#123;\n    boundActionCreators[key] &#x3D; bindActionCreator(actionCreators[key], dispatch);\n  &#125;\n  return boundActionCreators;\n&#125;\n\nexport default bindActionCreators;\n\ncombineReducerexport default function combineReducer(reducers) &#123;\n  const reducerkeys &#x3D; Object.keys(reducers);\n\n  return function (state &#x3D; &#123;&#125;, action) &#123;\n    let nextState &#x3D; &#123;&#125;;\n    for (let i &#x3D; 0; i &lt; reducerkeys.length; i++) &#123;\n      const key &#x3D; reducerkeys[i];\n      const reducer &#x3D; reducers[key];\n      const previousStateForKey &#x3D; state[key];\n      const nextStateForkey &#x3D; reducer(previousStateForKey, action);\n      nextState[key] &#x3D; nextStateForkey;\n    &#125;\n\n    return nextState;\n  &#125;;\n&#125;\n\nutilexport default function isPlainObject(obj) &#123;\n  if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\n    return false;\n  &#125;\n\n  let proto &#x3D; obj;\n  while (Object.getPrototypeOf(proto)) &#123;\n    proto &#x3D; Object.getPrototypeOf(proto);\n  &#125;\n\n  return Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; proto;\n&#125;\n\napplyMiddleWarefunction applyMiddleWare(...middlewares) &#123;\n  return function (createStore) &#123;\n    return function (reducer) &#123;\n      let store &#x3D; createStore();\n      let dispath &#x3D; () &#x3D;&gt; &#123;\n        throw new Error();\n      &#125;;\n      let middlewareAPI &#x3D; &#123;\n        getStore: store.getState,\n        dispatch: (...args) &#x3D;&gt; dispath(...args),\n      &#125;;\n      &#x2F;&#x2F; middleware &#x3D; middleware(store);\n      &#x2F;&#x2F; dispath &#x3D; middleware(store.dispatch);\n\n      const chain &#x3D; middlewares.map((middleware) &#x3D;&gt; middleware(middlewareAPI));\n      dispath &#x3D; componse(...chain)(store.dispatch)\n      return &#123;\n        ...store,\n        dispath,\n      &#125;;\n    &#125;;\n  &#125;;\n&#125;\n\ncomposefunction compose(...funcs) &#123;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return (args) &#x3D;&gt; args;\n  &#125;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n\n  return funcs.reduce((a, b) &#x3D;&gt; (...args) &#x3D;&gt; a(b(...args)));\n&#125;\n\nexport default compose;\n\nreact-reudxindex.jsimport Provider from &#39;.&#x2F;Provider&#39;;\nimport connect from &#39;.&#x2F;connect&#39;;\n\nexport &#123; Provider, connect &#125;;\n\nProvider.jsimport React, &#123; Component &#125; from &#39;react&#39;;\nimport ReduxContext from &#39;.&#x2F;context&#39;;\n\nclass Provider extends Component &#123;\n  render() &#123;\n    return (\n      &lt;ReduxContext.Provider value&#x3D;&#123;this.props.store&#125;&gt;\n        &#123;this.props.children&#125;\n      &lt;&#x2F;ReduxContext.Provider&gt;\n    );\n  &#125;\n&#125;\n\nexport default Provider;\n\nconnect.jsimport React from &#39;react&#39;;\nimport ReduxContext from &#39;.&#x2F;context&#39;;\nimport bindActionCreator from &#39;..&#x2F;redux&#x2F;bindActionCreator&#39;;\nexport default function connect(mapStateToProps, mapDispatchToProps) &#123;\n  return function (WrappedComponent) &#123;\n    return class extends React.Component &#123;\n      static contextType &#x3D; ReduxContext;\n      constructor(props, context) &#123;\n        super(props);\n        &#x2F;** context &#x3D; &#123;store: this.props.store&#125; *&#x2F;\n        this.state &#x3D; mapDispatchToProps(context.store.getState());\n      &#125;\n      componentDidCatch() &#123;\n        this.unsubscribe &#x3D; this.context.store.subscribe(() &#x3D;&gt; &#123;\n          this.setState(mapStateToProps(this.context.store.getState()));\n        &#125;);\n      &#125;\n      componentWillUnmount() &#123;\n        this.unsubscribe();\n      &#125;\n      render() &#123;\n        let action &#x3D; bindActionCreator(\n          mapDispatchToProps,\n          this.context.store.dispatch\n        );\n        return &lt;WrappedComponent &#123;...this.state&#125; &#123;...action&#125; &#x2F;&gt;;\n      &#125;\n    &#125;;\n  &#125;;\n&#125;\n\ncontext.jsimport React from &#39;react&#39;;\n\nconst ReduxContext &#x3D; React.createContext(null);\nexport default ReduxContext;\n\nredux-promisefunction isPromise(obj) &#123;\n  return (\n    !!obj &amp;&amp;\n    (typeof obj &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof obj &#x3D;&#x3D;&#x3D; &#39;function&#39;) &amp;&amp;\n    typeof obj.then &#x3D;&#x3D;&#x3D; &#39;function&#39;\n  );\n&#125;\nexport default function (&#123; dispatch, getState &#125;) &#123;\n  return (next) &#x3D;&gt; (action) &#x3D;&gt; &#123;\n    return isPromise(action.payload)\n      ? action.payload.then((result) &#x3D;&gt; &#123;\n          dispatch(&#123; ...action, payload: result &#125;);\n        &#125;)\n      : next(action);\n  &#125;;\n&#125;\n\nreudx-thunkfunction createThunkMiddleware() &#123;\n  return (&#123; dispatch, getState &#125; &#x2F;** middlewareAPI *&#x2F;) &#x3D;&gt; (next) &#x3D;&gt; (\n    action\n  ) &#x3D;&gt; &#123;\n    if (typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n      return action(dispatch, getState);\n    &#125;\n    return next(action);\n  &#125;;\n&#125;\n\n","slug":"redux && redux-middleware","date":"2021-04-06T14:27:28.404Z","categories_index":"React","tags_index":"React,redux,redux-middleware","author_index":"麦当"},{"id":"89dff2a6379feafc73b36875ccf71035","title":"react-setState","content":"react-state 流程\n\nindex.js&#x2F;** 事务 用wrapper包装起来 *&#x2F;\nclass Transaction &#123;\n  constructor(wrappers) &#123;\n    this.wrappers &#x3D; wrappers;\n  &#125;\n  &#x2F;** AOP 编程概念  *&#x2F;\n  perform(anyMethod) &#123;\n    this.wrappers.forEach((wrapper) &#x3D;&gt; wrapper.initialize());\n    anyMethod();\n    this.wrappers.forEach((wrapper) &#x3D;&gt; wrapper.close());\n  &#125;\n&#125;\nlet batchingStrategy &#x3D; &#123;\n  isBatchingStrates: false &#x2F;** 标记是否是批量更新模式 *&#x2F;,\n  dirtyComponent: [] &#x2F;** 脏组件 组件的状态和UI不匹配  *&#x2F;,\n  batchedUpdates() &#123;\n    &#x2F;** 执行所有的更新操作 *&#x2F;\n    this.dirtyComponent.forEach((component) &#x3D;&gt; component.updateComonent());\n  &#125;,\n&#125;;\nclass Updater &#123;\n  constructor(component) &#123;\n    this.component &#x3D; component;\n    this.pendingState &#x3D; [];\n  &#125;\n  addState(partcialState) &#123;\n    this.pendingState.push(partcialState);\n    &#x2F;** 判断是不是批量更新模式 如果是批量更新 将组件放到脏组件里 做到异步更新 *&#x2F;\n    batchingStrategy.isBatchingStrates\n      ? batchingStrategy.dirtyComponent.push(this.component)\n      : this.component.updateComonent();\n  &#125;\n&#125;\nclass Component &#123;\n  constructor(props) &#123;\n    this.props &#x3D; props;\n    this.$updater &#x3D; new Updater(this);\n  &#125;\n  createDOMFromDOMString(domString) &#123;\n    let div &#x3D; document.createElement(&#39;div&#39;);\n    div.innerHTML &#x3D; domString;\n    return div.children[0];\n  &#125;\n  setState(partcialState) &#123;\n    this.$updater.addState(partcialState);\n  &#125;\n\n  &#x2F;** 组件的更新方法 合并所有的状态 然后进行统一的页面元素UI的替换 *&#x2F;\n  updateComonent() &#123;\n    this.$updater.pendingState.forEach((partcialState) &#x3D;&gt;\n      Object.assign(this.setState, partcialState)\n    );\n    this.$updater.pendingState.length &#x3D; 0; &#x2F;** 清空队列 *&#x2F;\n    let oldElemet &#x3D; this.domElement;\n    let newElement &#x3D; this.renderElement();\n    oldElemet.parentElement.replaceChild(newElement, oldElemet);\n  &#125;\n\n  &#x2F;** 创建页面元素 *&#x2F;\n  renderElement() &#123;\n    let htmlString &#x3D; this.render();\n    this.domElement &#x3D; this.createDOMFromDOMString(htmlString);\n    this.domElement.component &#x3D; this;\n    return this.domElement;\n  &#125;\n\n  &#x2F;** 组件的挂载方法  *&#x2F;\n  mount(container) &#123;\n    container.appendChild(this.renderElement());\n  &#125;\n&#125;\n\nlet transaction &#x3D; new Transaction([\n  &#123;\n    initialize() &#123;\n      &#x2F;** 事件开启的时候进入批量更新模式  *&#x2F;\n      batchingStrategy.isBatchingStrates &#x3D; true;\n    &#125;,\n    close() &#123;\n      &#x2F;** 事件结束的时候关闭批量更新模式  *&#x2F;\n      batchingStrategy.isBatchingStrates &#x3D; false;\n      &#x2F;** 脏组件进行状态的更新 *&#x2F;\n      batchingStrategy.batchedUpdates();\n    &#125;,\n  &#125;,\n]);\n\n&#x2F;** 统一的事件处理 挂载到全局  *&#x2F;\nwindow.trigger &#x3D; function (event, mothodName) &#123;\n  &#x2F;** 拿到组件的实例(事件委托) 执行绑定的方法 *&#x2F;\n  let component &#x3D; event.target.component;\n  &#x2F;** wrapper包装起来 处理一些相关的事件 *&#x2F;\n  transaction.perform(component[mothodName].bind(component));\n&#125;;\n\n&#x2F;** 子组件 *&#x2F;\nclass Counter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n  &#125;\n  add() &#123;\n    this.setState(&#123; number: this.state.number + 1 &#125;);\n  &#125;\n\n  render() &#123;\n    return &#96;&lt;button onclick&#x3D;&quot;trigger(event, &#39;add&#39;)&quot;&gt;$&#123;this.state.number&#125;&lt;&#x2F;button&gt;&#96;;\n  &#125;\n&#125;\n\nindex.html&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;count-app&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n  &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script&gt;\n    let countApp &#x3D; document.getElementById(&#39;count-app&#39;);\n    let res &#x3D; new Counter().render();\n    res.mount(countApp);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n","slug":"react-setState","date":"2021-04-06T14:27:28.394Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"50552075ed1d1cbaae410e21993db179","title":"react-router-dom","content":"BrowserRouter\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\n\nlet pushState &#x3D; window.history.pushState;\n\nclass HashRouter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      location: &#123; pathname: window.location.pathname, state: null &#125;,\n    &#125;;\n  &#125;\n  componentDidMount() &#123;\n    window.history.pushState &#x3D; (state, title, url) &#x3D;&gt; &#123;\n      pushState.call(window.history, state, title, url);\n      window.onpushstate.call(this, state, url);\n    &#125;;\n    window.onpopstate &#x3D; (event) &#x3D;&gt; &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: window.location.pathname,\n          state: event.state,\n        &#125;,\n      &#125;);\n    &#125;;\n    window.onpushstate &#x3D; (state, pathname) &#x3D;&gt; &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: pathname,\n          state: state,\n        &#125;,\n      &#125;);\n    &#125;;\n  &#125;\n  render() &#123;\n    let that &#x3D; this;\n    let value &#x3D; &#123;\n      location: that.state.location,\n      history: &#123;\n        push(to) &#123;\n          &#x2F;** 阻止跳转 *&#x2F;\n          if (that.block) &#123;\n            let confirm &#x3D; window.confirm(\n              that.block(typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; ? to : &#123; pathname: to &#125;)\n            );\n            if (!confirm) return;\n          &#125;\n          if (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n            let &#123; pathname, state &#125; &#x3D; to;\n            window.history.pushState(state, &#39;&#39;, pathname);\n          &#125; else &#123;\n            window.history.pushState(null, &#39;&#39;, to);\n          &#125;\n        &#125;,\n        block(message) &#123;\n          that.block &#x3D; message;\n        &#125;,\n      &#125;,\n    &#125;;\n    return (\n      &lt;Context.Provider value&#x3D;&#123;value&#125;&gt;&#123;this.props.children&#125;&lt;&#x2F;Context.Provider&gt;\n    );\n  &#125;\n&#125;\n\nexport default HashRouter;\n\ncontext&#x2F;** 暴露出整个库的context上下文  *&#x2F;\nimport React from &#39;react&#39;;\n\nconst Context &#x3D; React.createContext();\n\nexport default Context;\n\nHashRouterimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass HashRouter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      location: &#123; pathname: window.location.hash.slice(1), state: null &#125;,\n    &#125;;\n    this.locationState &#x3D; null;\n  &#125;\n  componentDidMount() &#123;\n    window.location.hash &#x3D; window.location.hash || &#39;&#x2F;&#39;;\n    window.addEventListener(&#39;hashchange&#39;, () &#x3D;&gt; &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: window.location.hash.slice(1),\n          state: this.locationState,\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  render() &#123;\n    let that &#x3D; this;\n    let value &#x3D; &#123;\n      location: that.state.location,\n      history: &#123;\n        push(to) &#123;\n          &#x2F;** 阻止跳转 *&#x2F;\n          if (that.block) &#123;\n            let confirm &#x3D; window.confirm(\n              that.block(typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; ? to : &#123; pathname: to &#125;)\n            );\n            if (!confirm) return;\n          &#125;\n          if (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n            let &#123; pathname, state &#125; &#x3D; to;\n            that.locationState &#x3D; state;\n            window.location.hash &#x3D; pathname;\n          &#125; else &#123;\n            that.locationState &#x3D; null;\n            window.location.hash &#x3D; to;\n          &#125;\n        &#125;,\n        block(message) &#123;\n          that.block &#x3D; message;\n        &#125;,\n      &#125;,\n    &#125;;\n    return (\n      &lt;Context.Provider value&#x3D;&#123;value&#125;&gt;&#123;this.props.children&#125;&lt;&#x2F;Context.Provider&gt;\n    );\n  &#125;\n&#125;\n\nexport default HashRouter;\n\nLinkimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Link extends Component &#123;\n  static contextType &#x3D; Context;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  render() &#123;\n    &#x2F;** 注意合并上部传来的props *&#x2F;\n    return (\n      &#x2F;&#x2F; eslint-disable-next-line jsx-a11y&#x2F;anchor-is-valid\n      &lt;a\n        &#123;...this.props&#125;\n        onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n          this.props.context.history.push(this.props.to);\n        &#125;&#125;\n      &gt;\n        &#123;this.props.children&#125;\n      &lt;&#x2F;a&gt;\n    );\n  &#125;\n&#125;\n\nexport default Link;\n\n&#x2F;**\n * &lt;a href&#x3D;&#123;&#96;#$&#123;this.props.to&#125;&#96;&#125;&gt;&#123;this.props.children&#125;&lt;&#x2F;a&gt;;\n *&#x2F;\n\nMenuLinkimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Route from &#39;.&#x2F;Route&#39;;\nimport Link from &#39;.&#x2F;Link&#39;;\n&#x2F;**自定义导航 正增加高亮属性 *&#x2F;\n\n&#x2F;** Route渲染内容有三种方法 component render children *&#x2F;\n&#x2F;&#x2F; component render 路径匹配渲染\n&#x2F;&#x2F; children 都会渲染\nfunction MenuLink(&#123; to, exact, children &#125;) &#123;\n  return (\n    &lt;Route\n      path&#x3D;&#123;to&#125;\n      exact&#x3D;&#123;exact&#125;\n      children&#x3D;&#123;(props) &#x3D;&gt; (\n        &lt;li className&#x3D;&#123;props.match ? &#39;active&#39; : &#39;&#39;&#125;&gt;\n          &lt;Link to&#x3D;&#123;to&#125;&gt;&#123;children&#125;&lt;&#x2F;Link&gt;\n        &lt;&#x2F;li&gt;\n      )&#125;\n    &gt;&lt;&#x2F;Route&gt;\n  );\n&#125;\n\nexport default MenuLink;\n\nPromptimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Prompt extends Component &#123;\n  static contextType &#x3D; Context;\n\n  componentWillUnmount() &#123;\n    this.history.block(null);\n  &#125;\n  render() &#123;\n    let history &#x3D; this.context.history;\n    const &#123; when, messaga &#125; &#x3D; this.props;\n    if (when) &#123;\n      history.block(messaga);\n    &#125; else &#123;\n      history.block(null);\n    &#125;\n\n    return null;\n  &#125;\n&#125;\n\nexport default Prompt;\n\nRedirectimport &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Redirect extends Component &#123;\n  static contextType &#x3D; Context;\n  render() &#123;\n    this.context.history.push(this.props.to);\n    return null;\n  &#125;\n&#125;\n\nexport default Redirect;\n\nRouteimport PathToRegexp from &#39;path-to-regexp&#39;;\nimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Route extends Component &#123;\n  static contextType &#x3D; Context;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  render() &#123;\n    let &#123; pathname &#125; &#x3D; this.context.location;\n    let &#123;\n      path &#x3D; &#39;&#x2F;&#39;,\n      component: Component,\n      exact &#x3D; false,\n      render,\n      children,\n    &#125; &#x3D; this.props;\n    let paramNames &#x3D; [];\n    let regxp &#x3D; PathToRegexp(path, paramNames, &#123; end: exact &#125;);\n    let result &#x3D; pathname.match(regxp);\n    let props &#x3D; &#123;\n      location: this.context.location,\n      history: this.props.history,\n    &#125;;\n    if (result) &#123;\n      paramNames &#x3D; paramNames.map((item) &#x3D;&gt; item.name);\n      let [url, ...values] &#x3D; result;\n      let params &#x3D; &#123;&#125;;\n      for (let i &#x3D; 0; i &lt; paramNames.length; i++) &#123;\n        params[paramNames[i]] &#x3D; values[i];\n      &#125;\n      props.match &#x3D; &#123; params, path, url, isExect: url &#x3D;&#x3D;&#x3D; pathname &#125;;\n      if (Component) &#123;\n        return &lt;Component &#123;...props&#125; &#x2F;&gt;;\n      &#125; else if (render) &#123;\n        &#x2F;** 检查属性 兼容性 *&#x2F;\n        return render(props);\n      &#125; else if (children) &#123;\n        return children(props);\n      &#125; else &#123;\n        return null;\n      &#125;\n    &#125; else &#123;\n      if (children) return children(props);\n      else return null;\n    &#125;\n  &#125;\n&#125;\n\nexport default Route;\n\nSwitchimport &#123; Component &#125; from &#39;react&#39;;\nimport PathToRegexp from &#39;path-to-regexp&#39;;\nclass Switch extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  render() &#123;\n    let &#123; pathname &#125; &#x3D; this.context.location;\n    let children &#x3D; Array.isArray(this.props.children)\n      ? this.props\n      : [this.props.children];\n    for (let i &#x3D; 0; i &lt; children.length; i++) &#123;\n      let child &#x3D; children[i];\n      let &#123; path &#x3D; &#39;&#x2F;&#39;, exect &#x3D; false &#125; &#x3D; child.props;\n      let pathNames &#x3D; [];\n      let reg &#x3D; PathToRegexp(path, pathNames, &#123; end: exect &#125;);\n      let result &#x3D; pathname.match(reg);\n      if (result) &#123;\n        return child; &#x2F;** react的元素 React.createElement *&#x2F;\n      &#125;\n    &#125;\n    return null;\n  &#125;\n&#125;\n\nexport default Switch;\n\nWithRouterimport React from &#39;react&#39;;\nimport Route from &#39;.&#x2F;Route&#39;;\n\n&#x2F;&#x2F; eslint-disable-next-line import&#x2F;no-anonymous-default-export\nexport default function (WrappedComponent) &#123;\n  return (props) &#x3D;&gt; &lt;Route component&#x3D;&#123;WrappedComponent&#125; &#x2F;&gt;;\n&#125;\n","slug":"react-router-dom","date":"2021-04-06T14:27:28.383Z","categories_index":"React","tags_index":"React,react-router-dom","author_index":"麦当"},{"id":"fa08fd35cb36d755ed7492a61cf66138","title":"react Hooks","content":"useState\n\n每次渲染都是一个独立的闭包\n每次渲染都会有自己的 props 和 state\n每次渲染后会有自己的时间处理函数\n\nfunction Counter() &#123;\n  let [num, setNum] &#x3D; useState(0);\n  function alertNum() &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      alert(num);\n    &#125;, 3000);\n  &#125;\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setNum&#125;&gt;&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;alertNum&#125;&gt;alert&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Counter() &#123;\n  let [num, setNum] &#x3D; useState(0);\n  function lazy()&#123;\n    setTimeout((\n      &#x2F;&#x2F; 有差别\n -     setNum(num + 1);\n -     setNum(num &#x3D;&gt; num + 1);\n    )&#x3D;&gt;&#123;&#125;, 3000)\n  &#125;\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setNum&#125;&gt;&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;lazy&#125;&gt;lazy&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n惰性初始化\nfunction Counter(props) &#123;\n  let [counter, setCounter] &#x3D; useState(function () &#123;\n    return &#123; num: props.num &#125;;\n  &#125;);\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;counter.num&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCounter&#125;&gt;&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nefect每次我们重新渲染 都会生成新的 effect 替换之前的 effect 属于渲染结果的一部分 effect 属于特定的渲染\n","slug":"react-hook","date":"2021-04-06T14:27:28.370Z","categories_index":"React","tags_index":"React,react hook","author_index":"麦当"},{"id":"b9a37f021de474295d3010955ace362e","title":"react base","content":"生命周期(老版)\n\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\n\nclass LifeCycle extends Component &#123;\n  &#x2F;**组件的静态属性 *&#x2F;\n  static defaultProps &#x3D; &#123; name: &#39;计数器&#39; &#125;;\n  constructor(props) &#123;\n    &#x2F;** setup props and state *&#x2F;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n    console.log(&#39;setup&#39;);\n  &#125;\n  componentWillMount() &#123;\n    console.log(&#39;2 组件将要挂载&#39;);\n  &#125;\n  componentDidMount() &#123;\n    console.log(&#39;4.组件挂载完成&#39;);\n  &#125;\n  shouldComponentUpdate() &#123;\n    console.log(&#39;5. 询问组件是否要更新&#39;);\n    return true;\n  &#125;\n  componentWillUpdate() &#123;\n    console.log(&#39;6 组件将要更新&#39;);\n  &#125;\n  componentDidUpdate() &#123;\n    console.log(&#39;7 组件已经更新完毕&#39;);\n  &#125;\n  add &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      number: this.state.number + 1,\n    &#125;);\n  &#125;;\n  render() &#123;\n    console.log(&#39;parent render&#39;);\n    return (\n      &lt;div&gt;\n        &lt;p&gt;&#123;this.state.name&#125;&lt;&#x2F;p&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;+&lt;&#x2F;button&gt;\n        &lt;Sub &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default LifeCycle;\n\nclass Sub extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; age: 10 &#125;;\n  &#125;\n  componentWillReceiveProps() &#123;\n    console.log(&#39;componentWillReceiveProps&#39;);\n  &#125;\n  render() &#123;\n    console.log(&#39;children render&#39;);\n    return (\n      &lt;div&gt;\n        &lt;p&gt;age:&#123;this.state.age&#125;&lt;&#x2F;p&gt;\n        &lt;button\n          onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n            this.setState(&#123; age: this.state.age + 1 &#125;);\n          &#125;&#125;\n        &gt;&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n生命周期新版\ngetDerivedStateFromPropsimport React, &#123; Component &#125; from &#39;react&#39;;\nclass Counter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n  &#125;\n  add &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      number: this.state.number + 1,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;p&gt;&#123;this.state.number&#125;&lt;&#x2F;p&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;+&lt;&#x2F;button&gt;\n        &lt;SubCounter number&#x3D;&#123;this.state.number&#125; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass SubCounter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n  &#125;\n  &#x2F;** 将State和Props传来的值全部整合到state上 *&#x2F;\n  static getDerivedStateFromProps(nextProps, prevState) &#123;\n    if (nextProps.number % 2 &#x3D;&#x3D;&#x3D; 0) &#123;\n      return &#123; number: nextProps.number * 2 &#125;;\n    &#125; else &#123;\n      return &#123; number: nextProps.number * 3 &#125;;\n    &#125;\n  &#125;\n  render() &#123;\n    return &lt;div&gt;&#123;this.state.number&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default Counter;\n\ngetSnapshotBeforeUpdateimport React, &#123; Component &#125; from &#39;react&#39;;\nclass getSnapshotBeforeUpdateComponent extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.wrapper &#x3D; React.createRef();\n    this.state &#x3D; &#123; message: [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;] &#125;;\n  &#125;\n\n  componentDidMount() &#123;\n    setInterval(() &#x3D;&gt; &#123;\n      this.setState(&#123;\n        message: [this.state.message.length, ...this.state.message],\n      &#125;);\n    &#125;, 1000);\n  &#125;\n\n  getSnapshotBeforeUpdate() &#123;\n    return this.wrapper.current.scrollHeight;\n  &#125;\n  componentDidUpdate(prevProps, prevState, scrollHeight) &#123;\n    let Dom &#x3D; this.wrapper.current;\n    Dom.scrollTop &#x3D; Dom.scrollTop + (Dom.scrollHeight - scrollHeight);\n  &#125;\n  render() &#123;\n    let style &#x3D; &#123;\n      height: &#39;100p&#39;,\n      width: &#39;200px&#39;,\n      border: &#39;1px solid red&#39;,\n      overflow: &#39;auto&#39;,\n    &#125;;\n    return (\n      &lt;div style&#x3D;&#123;style&#125; ref&#x3D;&#123;this.wrapper&#125;&gt;\n        &lt;ul&gt;\n          &#123;this.state.message.map((item, index) &#x3D;&gt; &#123;\n            return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;;\n          &#125;)&#125;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default getSnapshotBeforeUpdateComponent;\n\ncontext(上下文)旧版import React, &#123; Component &#125; from &#39;react&#39;;\nimport propTypes from &#39;prop-types&#39;;\nclass Page extends Component &#123;\n  static childContextTypes &#x3D; &#123;\n    color: propTypes.string,\n    setColor: propTypes.func,\n  &#125;;\n  getChildContext() &#123;\n    return &#123; color: &#39;gray&#39;, setColor: this.setColor &#125;;\n  &#125;\n\n  setColor &#x3D; (color) &#x3D;&gt; &#123;\n    this.setColor(&#123; color &#125;);\n  &#125;;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123; color: &#39;gray&#39; &#125;;\n  &#125;\n  render() &#123;\n    return (\n      &lt;&gt;\n        &lt;Header&gt;\n          &lt;Title&gt;&lt;&#x2F;Title&gt;\n        &lt;&#x2F;Header&gt;\n        &lt;Main&gt;\n          &lt;Content&gt;&lt;&#x2F;Content&gt;\n        &lt;&#x2F;Main&gt;\n      &lt;&#x2F;&gt;\n    );\n  &#125;\n&#125;\n\nclass Header extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Header\n        &lt;Title&gt;&lt;&#x2F;Title&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass Title extends Component &#123;\n  &#x2F;** 子集关系 *&#x2F;\n  static contextTypes &#x3D; &#123;\n    color: propTypes.string,\n    setColor: propTypes.func,\n  &#125;;\n  &#x2F;**\n   * this.context.color\n   * this.context.setColor\n   *&#x2F;\n\n  render() &#123;\n    return &lt;div&gt;Title&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nclass Main extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Main\n        &lt;Content&gt;&lt;&#x2F;Content&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass Content extends Component &#123;\n  render() &#123;\n    return &lt;div&gt;Content&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default Page;\n\n新版&#x2F;&#x2F; import &#123; func &#125; from &#39;prop-types&#39;;\nimport React, &#123; Component &#125; from &#39;react&#39;;\n&#x2F;&#x2F; import propTypes from &#39;prop-types&#39;;\nconst ThemeContext &#x3D; React.createContext();\n&#x2F;**\n * ThemeContext &#x3D; &#123;Provider Consumer&#125;\n *\n *&#x2F;\n\n&#x2F;**-------- createContext -----------------------------------*&#x2F;\n\nfunction createContext() &#123;\n  class Provider extends Component &#123;\n    static value;\n    constructor(props) &#123;\n      super(props);\n      Provider.value &#x3D; props.value;\n    &#125;\n    render() &#123;\n      return this.props.children;\n    &#125;\n  &#125;\n\n  class Consumer extends Component &#123;\n    render() &#123;\n      return this.props.children(Provider.value);\n    &#125;\n  &#125;\n\n  return &#123; Provider, Consumer &#125;;\n&#125;\n\n&#x2F;**----------------------------------------------------------- *&#x2F;\n\nclass Page extends Component &#123;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123; color: &#39;gray&#39; &#125;;\n  &#125;\n  setColor(color) &#123;\n    this.setState(&#123; color &#125;);\n  &#125;\n  render() &#123;\n    let ctx &#x3D; &#123; color: &#39;gray&#39;, setColor: this.setColor &#125;;\n    return (\n      &lt;ThemeContext.Provider value&#x3D;&#123;ctx&#125;&gt;\n        &lt;Header&gt;\n          &lt;Title&gt;&lt;&#x2F;Title&gt;\n        &lt;&#x2F;Header&gt;\n        &lt;Main&gt;\n          &lt;Content&gt;&lt;&#x2F;Content&gt;\n        &lt;&#x2F;Main&gt;\n      &lt;&#x2F;ThemeContext.Provider&gt;\n    );\n  &#125;\n&#125;\n\nclass Header extends Component &#123;\n  &#x2F;**----------------------------------------------- *&#x2F;\n  static contextType &#x3D; ThemeContext;\n  &#x2F;**----------------------------------------------- *&#x2F;\n\n  &#x2F;**\n   * this.context 拿到了所有的值\n   *&#x2F;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Header\n        &lt;Title&gt;&lt;&#x2F;Title&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nfunction Title(props) &#123;\n  return &lt;div&gt;title&lt;&#x2F;div&gt;;\n&#125;\n\nclass Main extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Main\n        &lt;Content&gt;&lt;&#x2F;Content&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass Content extends Component &#123;\n  render() &#123;\n    return &lt;div&gt;Content&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default Page;\n\npureComponentimport React, &#123; PureComponent &#125; from &#39;react&#39;;\n\nclass Title extends PureComponent &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.title&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nclass Counter extends PureComponent &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.number&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default class App extends PureComponent &#123;\n  constructor(props) &#123;\n    super(props);\n    this.props &#x3D; props;\n    this.state &#x3D; &#123; title: &#39;计数器&#39;, number: 0 &#125;;\n    this.inputRef &#x3D; React.createRef();\n  &#125;\n  add &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      number: this.state.number + parseInt(this.inputRef.current.value),\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Title title&#x3D;&#123;this.state.title&#125; &#x2F;&gt;\n        &lt;Counter number&#x3D;&#123;this.state.number&#125; &#x2F;&gt;\n        &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;+&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\n\nexport default class PureComponent extends Component &#123;\n  isPureComponent &#x3D; true;\n  shouldComponentUpdate(nextProps, nextState) &#123;\n    return (\n      !shallowEqual(this.props, nextProps) ||\n      !shallowEqual(this.state, nextState)\n    );\n  &#125;\n  render() &#123;\n    return &lt;div&gt;1&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nfunction shallowEqual(obj1, obj2) &#123;\n  if (obj1 &#x3D;&#x3D;&#x3D; obj2) return true;\n  if (\n    typeof obj1 !&#x3D;&#x3D; &#39;object&#39; ||\n    obj1 &#x3D;&#x3D;&#x3D; null ||\n    typeof obj2 !&#x3D;&#x3D; &#39;object&#39; ||\n    obj2 &#x3D;&#x3D;&#x3D; null\n  ) &#123;\n    return false;\n  &#125;\n\n  let keys1 &#x3D; Object.keys(obj1);\n  let keys2 &#x3D; Object.keys(obj2);\n  if (keys1.length !&#x3D;&#x3D; keys2.length) return false;\n\n  for (let key of keys1) &#123;\n    if (!obj2.hasOwnProperty(key)) &#123;\n      if (obj1[key] !&#x3D;&#x3D; obj2[key]) &#123;\n        if (typeof obj1[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof obj2[key] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n          return shallowEqual(obj1[key], obj2[key]);\n        &#125;\n      &#125; else &#123;\n        return false;\n      &#125;\n    &#125;\n  &#125;\n  return true;\n&#125;\n\nmemoimport React, &#123; PureComponent &#125; from &#39;react&#39;;\n\nfunction memo(FunComponent) &#123;\n  return class Proxy extends PureComponent &#123;\n    render() &#123;\n      return FunComponent(this.props)\n    &#125;\n  &#125;;\n&#125;\nexport default memo;\n\n\n高阶组件&#x2F;**\n * 高阶函数 传入一个函数 返回一个新的函数\n * 高阶组件 传入一个组件 返回一个新的组件\n *&#x2F;\n\nimport React from &#39;react&#39;;\nexport default function withLogger(Comp) &#123;\n  return class extends React.Component &#123;\n    componentWillMount() &#123;\n      this.start &#x3D; Date.now();\n    &#125;\n    componentDidMount() &#123;\n      console.log(Date.now() - this.start + &#39;ms&#39;);\n    &#125;\n\n    render() &#123;\n      return &lt;Comp &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n&#125;\n\n\nrender props&lt;MouseTracker&gt;\n\t&#123;\n        (props)&#x3D;&gt;&lt;Pirture &#123;...props&#125;&#x2F;&gt;\n    &#125;\n&lt;&#x2F;MouseTracker&gt;\n\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\nclass MouseTracker extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; x: 0, y: 0 &#125;;\n  &#125;\n  handleMouseMove &#x3D; (event) &#x3D;&gt; &#123;\n    this.setState(&#123;\n      x: event.clientX,\n      y: event.clientY,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div onMouseOver&#x3D;&#123;this.handleMouseMove&#125;&gt;\n            &#x2F;* 执行子组件 函数组件*&#x2F;\n        &#123;this.props.children(&#123; x: this.state.x, y: this.state.y &#125;)&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default MouseTracker;\n\n\nFrament&lt;React.Fragment&gt;\n\nprotalimport React, &#123; Component &#125; from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nclass Modal extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.modal &#x3D; document.getElementById(&#39;modal-root&#39;);\n  &#125;\n  render() &#123;\n    return ReactDOM.createPortal(this.props.children, this.modal);\n  &#125;\n&#125;\n\nclass Page extends Component &#123;\n  constructor(prop) &#123;\n    super(prop);\n    this.state &#x3D; &#123; show: false &#125;;\n  &#125;\n  toggleModal &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      show: !this.state.show,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick&#x3D;&#123;this.toggleModal&#125;&gt;关闭&#x2F;显示&lt;&#x2F;button&gt;\n        &#123;this.state.show &amp;&amp; (\n          &lt;Modal&gt;\n            &lt;div id&#x3D;&#39;modal&#39; className&#x3D;&#39;modal&#39;&gt;\n              &lt;div id&#x3D;&#39;content&#39; className&#x3D;&#39;content&#39;&gt;\n                Modal\n              &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;Modal&gt;\n        )&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default Page;\n\n错误边界import React, &#123; Component &#125; from &#39;react&#39;;\nclass ErrorBoundary extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; hasErrors: false &#125;;\n  &#125;\n  &#x2F;* 捕获异常 检查错误*&#x2F;\n  componentDidCatch(err, info) &#123;\n    if (err) &#123;\n      this.setState(&#123;\n        hasErrors: true,\n      &#125;);\n    &#125;\n  &#125;\n  render() &#123;\n    if (this.state.hasErrors) &#123;\n      return &lt;div&gt; error&lt;&#x2F;div&gt;;\n    &#125; else &#123;\n      return this.props.children;\n    &#125;\n  &#125;\n&#125;\n\nclass Clock extends Component &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;Date.now()&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nclass page extends Component &#123;\n  render() &#123;\n    return (\n      &lt;ErrorBoundary&gt;\n        &lt;Clock &#x2F;&gt;\n      &lt;&#x2F;ErrorBoundary&gt;\n    );\n  &#125;\n&#125;\n\nexport default page;\n","slug":"react-base","date":"2021-04-06T14:27:28.342Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"764ea20144bdcb36de34ee7af78c0567","title":"proxy 基础学习","content":"代理基础什么是代理\n代理是目标对象的抽象，类似于 c++的指针，可以用作目标的替身，又独立目标之外。\n\n\nconst target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(proxy.id);\n\n&#x2F;&#x2F; proxy的prototype是undefined\n\n定义捕获器\nconst target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;handler override&#39;;\n  &#125;,\n&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(proxy.id);\n&#x2F;&#x2F; 只有代理才会产生捕获 原来的目标没有这样的行为\n\n反射 API\nconst target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;\n  get() &#123;\n    console.log(&#39;get handler&#39;);\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(&#39;----------&#39;, proxy.id);\n\n捕获器不变式\nconst target &#x3D; &#123;&#125;;\nObject.defineProperty(target, &#39;foo&#39;, &#123;\n  configurable: false,\n  writable: false,\n  value: &#39;bar&#39;,\n&#125;);\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;qux&#39;;\n  &#125;,\n&#125;;\nconst proxy &#x3D; new Proxy(target, handler);\nconsole.log(proxy.foo);\n\n撤销代理\nconst target &#x3D; &#123;\n  foo: &#39;bar&#39;,\n&#125;;\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;intercepted&#39;;\n  &#125;,\n&#125;;\nconst &#123; proxy, revoke &#125; &#x3D; Proxy.revocable(target, handler);\nconsole.log(proxy.foo); &#x2F;&#x2F; intercepted\nconsole.log(target.foo); &#x2F;&#x2F; bar\nrevoke();\nconsole.log(proxy.foo); &#x2F;&#x2F; TypeError\n\n**实用反射 API **\n&#x2F;&#x2F; 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功\nconst o &#x3D; &#123;&#125;;\ntry &#123;\n  Object.defineProperty(o, &#39;foo&#39;, &#39;bar&#39;);\n  console.log(&#39;success&#39;);\n&#125; catch (e) &#123;\n  console.log(&#39;failure&#39;);\n&#125;\n&#x2F;&#x2F; 使用代理之后\n&#x2F;&#x2F; 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。\n&#x2F;&#x2F; 因此使用这个反射方法可以这样重构上面的代码：\n&#x2F;&#x2F; 重构后的代码\nconst o &#x3D; &#123;&#125;;\nif (Reflect.defineProperty(o, &#39;foo&#39;, &#123; value: &#39;bar&#39; &#125;)) &#123;\n  console.log(&#39;success&#39;);\n&#125; else &#123;\n  console.log(&#39;failure&#39;);\n&#125;\n\n其他的状态标记反射 API\nReflect.defineProperty();\nReflect.preventExtensions();\nReflect.setPrototypeOf();\nReflect.set();\nReflect.deleteProperty();\n\n用一等函数替代操作符\n以下反射方法提供只有通过操作符才能完成的操作。\nReflect.get()：可以替代对象属性访问操作符。\nReflect.set()：可以替代=赋值操作符。\nReflect.has()：可以替代 in 操作符或 with()。\nReflect.deleteProperty()：可以替代 delete 操作符。\nReflect.construct()：可以替代 new 操作符。\n代理的问题\nconst wm &#x3D; new WeakMap();\n\nclass User &#123;\n\n constructor(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n set id(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n get id() &#123;\n\n \treturn wm.get(this);\n\n &#125;\n\n&#125;\n\n由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：\n\nconst user &#x3D; new User(123);\n\nconsole.log(user.id); &#x2F;&#x2F; 123\n\nconst userInstanceProxy &#x3D; new Proxy(user, &#123;&#125;);\n\nconsole.log(userInstanceProxy.id); &#x2F;&#x2F; undefined\n\n&#x2F;&#x2F; 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实\n\n&#x2F;&#x2F; 例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代\n\n&#x2F;&#x2F; 理的实例就会以代理实例作为 WeakMap 的键了：\n\nconst UserClassProxy &#x3D; new Proxy(User, &#123;&#125;);\n\nconst proxyUser &#x3D; new UserClassProxy(456);\n\nconsole.log(proxyUser.id);  &#x2F;&#x2F;\n\n代理与内部槽位\n&#x2F;*\n代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可\n能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的\n内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通\n的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：\n*&#x2F;\nconst target &#x3D; new Date();\nconst proxy &#x3D; new Proxy(target, &#123;&#125;);\nconsole.log(proxy instanceof Date); &#x2F;&#x2F; true\nproxy.getDate(); &#x2F;&#x2F; TypeError: &#39;this&#39; is not a Date object\n\n代理捕获器get()\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  get(target, property, receiver) &#123;\n    console.log(&#39;get()&#39;);\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;);\nproxy.foo;\n\n拦截的操作\n\nproxy.property\nproxy[property]\nObject.create(proxy)[property]\nReflect.get(proxy, property, receiver)\n\nset\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  set(target, property, value, receiver) &#123;\n    console.log(&#39;set()&#39;);\n    return Reflect.set(...arguments);\n  &#125;,\n&#125;);\nproxy.foo &#x3D; &#39;bar&#39;;\n&#x2F;&#x2F; 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。\n\n拦截的操作\n\nproxy.property = value\nproxy[property] = value\nObject.create(proxy)[property] = value\nReflect.set(proxy, property, value, receiver)\n\nhas\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  has(target, property) &#123;\n    console.log(&#39;has()&#39;);\n    return Reflect.has(...arguments);\n  &#125;,\n&#125;);\n&#39;foo&#39; in proxy;\n&#x2F;&#x2F; has()\n\n\nproperty in proxy\nproperty in Object.create(proxy)\nwith(proxy) {(property);}\nReflect.has(proxy, property)\n\ndefineProperty()\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  defineProperty(target, property, descriptor) &#123;\n    console.log(&#39;defineProperty()&#39;);\n    return Reflect.defineProperty(...arguments);\n  &#125;,\n&#125;);\nObject.defineProperty(proxy, &#39;foo&#39;, &#123; value: &#39;bar&#39; &#125;);\n&#x2F;&#x2F; Object.defineProperty(proxy, property, descriptor)\n&#x2F;&#x2F; Reflect.defineProperty(proxy, property, descriptor)\n\ngetOwnPropertyDescriptor\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  getOwnPropertyDescriptor(target, property) &#123;\n    console.log(&#39;getOwnPropertyDescriptor()&#39;);\n    return Reflect.getOwnPropertyDescriptor(...arguments);\n  &#125;,\n&#125;);\nObject.getOwnPropertyDescriptor(proxy, &#39;foo&#39;);\n&#x2F;&#x2F; getOwnPropertyDescriptor()\n\n&#x2F;&#x2F; Object.getOwnPropertyDescriptor(proxy, property)\n&#x2F;&#x2F; Reflect.getOwnPropertyDescriptor(proxy, property)\n\ndeleteProperty\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  deleteProperty(target, property) &#123;\n    console.log(&#39;deleteProperty()&#39;);\n    return Reflect.deleteProperty(...arguments);\n  &#125;,\n&#125;);\ndelete proxy.foo;\n&#x2F;&#x2F; deleteProperty()\n&#x2F;*\n    delete proxy.property\n    delete proxy[property]\n    Reflect.deleteProperty(proxy, property)\n*&#x2F;\n\nownKeys\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  ownKeys(target) &#123;\n    console.log(&#39;ownKeys()&#39;);\n    return Reflect.ownKeys(...arguments);\n  &#125;,\n&#125;);\nObject.keys(proxy);\n&#x2F;&#x2F; ownKeys()\n&#x2F;*\n    Object.getOwnPropertyNames(proxy)\n    Object.getOwnPropertySymbols(proxy)\n    Object.keys(proxy)\n    Reflect.ownKeys(proxy)\n*&#x2F;\n\ngetPrototypeOf\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  getPrototypeOf(target) &#123;\n    console.log(&#39;getPrototypeOf()&#39;);\n    return Reflect.getPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.getPrototypeOf(proxy);\n&#x2F;&#x2F; getPrototypeOf()\n\n&#x2F;*\n    Object.getPrototypeOf(proxy)\n    Reflect.getPrototypeOf(proxy)\n    proxy.__proto__\n    Object.prototype.isProt\n*&#x2F;\n\nsetPrototypeOf\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  setPrototypeOf(target, prototype) &#123;\n    console.log(&#39;setPrototypeOf()&#39;);\n    return Reflect.setPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.setPrototypeOf(proxy, Object);\n&#x2F;&#x2F; setPrototypeOf()\n\n&#x2F;*\n    Object.setPrototypeOf(proxy)\n    Reflect.setPrototypeOf(proxy)\n*&#x2F;\n\nisExtensible\npreventExtensions\napply\nconst myTarget &#x3D; () &#x3D;&gt; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  apply(target, thisArg, ...argumentsList) &#123;\n    console.log(&#39;apply()&#39;);\n    return Reflect.apply(...arguments);\n  &#125;,\n&#125;);\nproxy();\n&#x2F;*\n    proxy(...argumentsList)\n    Function.prototype.apply(thisArg, argumentsList)\n    Function.prototype.call(thisArg, ...argumentsList)\n    Reflect.apply(target, thisArgument, argumentsList)\n*&#x2F;\n\nconstruct\nconst myTarget &#x3D; function () &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  construct(target, argumentsList, newTarget) &#123;\n    console.log(&#39;construct()&#39;);\n    return Reflect.construct(...arguments);\n  &#125;,\n&#125;);\nnew proxy();\n&#x2F;&#x2F; construct()\n&#x2F;*\n    new proxy(...argumentsList)\n    Reflect.construct(target, argumentsList, newTarget)\n*&#x2F;\n","slug":"proxy","date":"2021-04-06T14:27:28.313Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"3a1de7864b72f88f991d2ad903723f46","title":"connected-react-router","content":"index.js\n\nimport routerMiddlware from &#39;.&#x2F;routerMiddlware&#39;;\nimport connectRouter from &#39;.&#x2F;connectRouter&#39;;\nimport push from &#39;.&#x2F;push&#39;;\nimport ConnectedRouter from &#39;.&#x2F;ConnectedRouter&#39;;\nexport &#123; routerMiddlware, connectRouter, push, ConnectedRouter &#125;;\n\n\n\nconstantsexport const CALL_HISTORY_METHOD &#x3D; &#39;@@router&#x2F;CALL_HISTORY_METHOD&#39;;\nexport const LOCATION_CHANGE &#x3D; &#39;@@router&#x2F;LOCATION_CHANGE&#39;;\n\nConnectedRouter.jsimport React, &#123; Component &#125; from &#39;react&#39;;\nimport &#123; ReactReduxContext &#125; from &#39;react-redux&#39;;\nimport &#123; Route &#125; from &#39;react-router&#39;;\nimport &#123; LOCATION_CHANGE &#125; from &#39;.&#x2F;constants&#39;;\nclass ConnectedRouter extends Component &#123;\n  static contextType &#x3D; ReactReduxContext;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  componentDidMount() &#123;\n    &#x2F;&#x2F; location 新的路径\n    &#x2F;&#x2F; action 新的动作 POP PUSH\n    this.unlistener &#x3D; this.props.history.listen((location, action) &#x3D;&gt; &#123;\n      this.context.store.dispatch(&#123;\n        type: LOCATION_CHANGE,\n        payload: &#123; location, action &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  componentWillUnmount() &#123;\n    this.unlistener();\n  &#125;\n  render() &#123;\n    let &#123; history, children &#125; &#x3D; this.props;\n    return &lt;Route history&#x3D;&#123;history&#125;&gt;&#123;children&#125;&lt;&#x2F;Route&gt;;\n  &#125;\n&#125;\n\nexport default ConnectedRouter;\n\nconnectRouter.jsimport &#123; LOCATION_CHANGE &#125; from &#39;.&#x2F;constants&#39;;\n&#x2F;&#x2F; eslint-disable-next-line import&#x2F;no-anonymous-default-export\nexport default function (history) &#123;\n  let initialState &#x3D; &#123; action: history.action, location: history.location &#125;;\n  return function (state &#x3D; initialState, action) &#123;\n    switch (action.type) &#123;\n      case LOCATION_CHANGE:\n        return action.payload;\n      default:\n        return state;\n    &#125;\n  &#125;;\n&#125;\n\npushimport &#123; CALL_HISTORY_METHOD &#125; from &#39;.&#x2F;constants&#39;;\nfunction push(path) &#123;\n  return &#123;\n    type: CALL_HISTORY_METHOD,\n    payload: &#123;\n      method: &#39;push&#39;,\n      path,\n    &#125;,\n  &#125;;\n&#125;\n\nexport default push;\n\nrouterMiddleware.jsimport &#123; CALL_HISTORY_METHOD &#125; from &#39;.&#x2F;constants&#39;;\n&#x2F;&#x2F; eslint-disable-next-line import&#x2F;no-anonymous-default-export\nexport default function (history) &#123;\n  return (&#123; dispatch, getState &#125;) &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; &#123;\n    if (action.type &#x3D;&#x3D;&#x3D; CALL_HISTORY_METHOD) &#123;\n      let &#123; method, path &#125; &#x3D; action.payload;\n      history[method](path);\n    &#125; else &#123;\n      next();\n    &#125;\n  &#125;;\n&#125;\n","slug":"connected-react-router","date":"2021-04-06T14:27:28.294Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"46450d7ba5c2c45a066c1b2bc4af0876","title":"leetcode学习记录","content":"\n我是一个算法的菜鸟，在面试的时候经常被算法绊倒在门槛。这篇文章就是记录自己刷 leetcode 的过程，记下来自己对每个问题的理解和想法，把好的想法记录下来，希望读者有帮助。希望自己可以坚持下去，一天写一道题，保持自己对算法的敏感度，保持思考。一起加油！！！\n\n134 加油站分析\n\n\n枚举每个站点 然后尝试从这个站点走n次, 如果可以顺利走了n 次的话 就是可以绕一周，就是题解，如果如果中途不可以继续走下去了，那个 i-j 中的子集部分也不可能走下去了。时间复杂度:O(n)空间复杂度:O(1)\n\n题解&#x2F;**\n * @param &#123;number[]&#125; gas\n * @param &#123;number[]&#125; cost\n * @return &#123;number&#125;\n *&#x2F;\nvar canCompleteCircuit &#x3D; function (gas, cost) &#123;\n  let n &#x3D; gas.length;\n\n  let i, j;\n  for (i &#x3D; 0; i &lt; n; ) &#123;\n    let left &#x3D; 0;\n\n    for (j &#x3D; 0; j &lt; n; j++) &#123;\n      let k &#x3D; (i + j) % n;\n      left &#x3D; left + gas[k] - cost[k];\n      if (left &lt; 0) break;\n    &#125;\n\n    if (j &#x3D;&#x3D; n) return i;\n    else i +&#x3D; j + 1;\n  &#125;\n  return -1;\n&#125;;\n\n135 分发糖果分析\nf[i]表示每个孩子分到的糖果，ans = f[0] +f[1] +….+ f[n]。每个孩子最少分到 1 个糖果。把小朋友的积分想象成一个台阶，只要是你的台阶数别两边的高，你的糖果数目必须最大一遍多一个才能保证最少。而且最少的只有一个。\n\n题解&#x2F;**\n * @param &#123;number[]&#125; ratings\n * @return &#123;number&#125;\n *&#x2F;\nvar candy &#x3D; function (ratings) &#123;\n  let n &#x3D; ratings.length;\n  let f &#x3D; new Array(n).fill(-1);\n  let w &#x3D; ratings;\n  let ans &#x3D; 0;\n\n  for (let x &#x3D; 0; x &lt; n; x++) &#123;\n    ans +&#x3D; dp(x);\n  &#125;\n\n  return ans;\n\n  function dp(i) &#123;\n    if (f[i] !&#x3D;&#x3D; -1) return f[i]; &#x2F;&#x2F; 分过了糖果不需要再分\n\n    f[i] &#x3D; 1;\n    if (i &amp;&amp; w[i - 1] &lt; w[i]) f[i] &#x3D; Math.max(f[i], dp(i - 1) + 1);\n    if (i + 1 &lt; n &amp;&amp; w[i + 1] &lt; w[i]) f[i] &#x3D; Math.max(f[i], dp(i + 1) + 1);\n\n    return f[i];\n  &#125;\n&#125;;\n","slug":"leetcode题解合集","date":"2021-04-06T14:27:28.256Z","categories_index":"leetcode","tags_index":"leetcode","author_index":"麦当"}]