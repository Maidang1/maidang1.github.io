[{"id":"d99453202fb96ed4663408801fbf0008","title":"Vuex 源码分析","content":"vuex 简易实现\n\nlet Vue;\n\nclass ModuleCollection &#123;\n  constructor(options) &#123;\n    this.register([], options);\n  &#125;\n\n  register(path, rootModule) &#123;\n    let module = &#123;\n      _rawModule: rootModule,\n      _children: &#123;&#125;,\n      state: rootModule.state,\n    &#125;;\n\n    if (path.length == 0) &#123;\n      this.root = module;\n    &#125;\n\n    if(rootModule.modules) &#123;\n      for\n    &#125;\n  &#125;\n&#125;\n\nclass Store &#123;\n  constructor(options = &#123;&#125;) &#123;\n    // 状态赋值\n    this.s = new Vue(&#123;\n      data() &#123;\n        return &#123; state: options.state &#125;;\n      &#125;,\n    &#125;);\n    let getters = options.getters;\n\n    this.getters = &#123;&#125;;\n\n    Object.keys(getters).forEach((getterName) => &#123;\n      Object.defineProperty(this.getters, getterName, &#123;\n        get: () => &#123;\n          return getters[getterName](this.state);\n        &#125;,\n      &#125;);\n    &#125;);\n\n    let mutations = options.mutations;\n    this.mutations = &#123;&#125;;\n    // 发布订阅模式\n    Object.keys(mutations).forEach((mutation) => &#123;\n      this.mutations[mutation] = (payload) => &#123;\n        mutations[mutation](this.state, payload);\n      &#125;;\n    &#125;);\n\n    // action\n\n    let actions = options.actions;\n    this.action = &#123;&#125;;\n    Object.keys(actions).forEach((action) => &#123;\n      this.actions[action] = (payload, fn) => &#123;\n        fn(this, payload);\n      &#125;;\n    &#125;);\n\n    this._modules = new ModuleCollection(); // 数据格式化\n  &#125;\n\n  dispatch = (actionName, payload) => &#123;\n    this.action[actionName](payload);\n  &#125;;\n  //提交更改\n  commit = (mutationName, payload) => &#123;\n    this.mutations[mutationName](payload);\n  &#125;;\n\n  get state() &#123;\n    return this.s.state;\n  &#125;\n&#125;\n\nconst install = (_Vue) => &#123;\n  Vue = _Vue; // vue构造函数\n\n  Vue.mixin(&#123;\n    beforeCreate() &#123;\n      // 需要拿到store 给每个组件增加了$store属性\n      // 可能有很多Vue实例 有的不需要store 没有放在Vue原型上面\n      if (this.$options &amp;&amp; this.$options.store) &#123;\n        // 给根实例增加$store属性\n        this.$store = this.$options.store;\n      &#125; else &#123;\n        // 单独创建的实例\n        this.store = this.$parent &amp;&amp; this.$parent.store;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;;\n\nexport default &#123;\n  // 默认执行 vue方法\n  install,\n&#125;;\n\n","slug":"vuex","date":"2021-04-06T14:27:28.497Z","categories_index":"vue","tags_index":"vuex,vue","author_index":"麦当"},{"id":"b491bd34f265533799a79211838a0e41","title":"Vue3 响应式原理","content":"简单的实现 Vue3 响应式原理\n\nlet toProxy = new WeakMap(); // 原对象：代理过得对象\nlet toRaw = new WeakMap(); // 被代理过得对象: 原对象\nfunction isObject(val) &#123;\n  return typeof val === 'object' &amp;&amp; val !== null;\n&#125;\n\nfunction reactive(target) &#123;\n  return createReactiveObject(target);\n&#125;\n\nfunction hasOwn(target, key) &#123;\n  return target.hasOwnProperty(key);\n&#125;\n\nlet proxy = reactive(&#123; name: 'zf' &#125;);\n\nfunction createReactiveObject(target) &#123;\n  if (!isObject(target)) return target;\n\n  // 处理多次代理的操作\n  let proxy = toProxy.get(target);\n  if (proxy) return proxy;\n  if (toRaw.has(target)) return target;\n  let baseHandler = &#123;\n    get(target, key, receiver) &#123;\n      let res = Reflect.get(target, key, receiver);\n      // 实现多层代理\n\n      track(target, key);\n      return isObject(res) ? reactive(res) : res;\n    &#125;,\n    set(target, key, value, receiver) &#123;\n      let hadKey = hasOwn(target, key);\n      let oldValue = target[key];\n      let res = Reflect.set(target, key, value, receiver);\n      if (!hadKey) &#123;\n        // 增加属性\n        trigger(target, 'add', key);\n      &#125; else if (oldValue !== value) &#123;\n        // 修改属性 屏蔽没有意义的更新\n        trigger(target, 'set', key);\n      &#125;\n      return res;\n    &#125;,\n    deleteProperty(target, key) &#123;\n      let res = Reflect.defineProperty(target, key);\n      return res;\n    &#125;,\n  &#125;;\n  let proxy = new Proxy(target, baseHandler);\n  toProxy.set(target, proxy);\n  toRaw.set(proxy, target);\n  return proxy;\n&#125;\n\n// 依赖收集 发布订阅\n\nlet activeEffectStacks = [];\nlet targetsMap = new WeakMap();\nfunction track(target, key) &#123;\n  let effect = activeEffectStacks[activeEffectStacks.length - 1];\n  if (effect) &#123;\n    let depMap = targetsMap.get(target);\n    if (!depMap) &#123;\n      targetsMap.set(target, (depMap = new Map()));\n    &#125;\n    let deps = depMap.get(key);\n    if (!deps) &#123;\n      depMap, set(key, (deps = new Set()));\n    &#125;\n\n    if (!deps.has(effect)) &#123;\n      deps.add(effect);\n    &#125;\n  &#125;\n&#125;\n\nfunction trigger(target, type, key) &#123;\n  let depsMap = targetsMap.get(target);\n  if (depsMap) &#123;\n    let deps = depsMap.get(key);\n    if (deps) &#123;\n      deps.forEach((effect) => &#123;\n        effect();\n      &#125;);\n    &#125;\n  &#125;\n&#125;\n\nfunction effect(fn) &#123;\n  // fn是响应的\n  let effect = createReactiveEffect(fn);\n  effect();\n&#125;\n\nfunction createReactiveEffect(fn) &#123;\n  let effect = function () &#123;\n    return run(effect, fn);\n  &#125;;\n  return effect;\n&#125;\n\nfunction run(effect, fn) &#123;\n  try &#123;\n    activeEffectStacks.push(effect);\n    fn();\n  &#125; finally &#123;\n    activeEffectStacks.pop();\n  &#125;\n&#125;\n","slug":"vue3-reactive","date":"2021-04-06T14:27:28.471Z","categories_index":"vue","tags_index":"vue3","author_index":"麦当"},{"id":"eb7ed51aa22769817771964a330ff0d5","title":"dataFetchHook","content":"Encapsulating data request with hook\nimport React, &#123; Fragment, useState, useEffect &#125; from 'react';\nimport axios from 'axios';\n\nfunction App() &#123;\n  const [data, setData] = useState(&#123; hits: [] &#125;);\n  const [query, setQuery] = useState('redux');\n  const [url, setUrl] = useState(\n    'https://hn.algolia.com/api/v1/search?query=redux'\n  );\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n\n  useEffect(() => &#123;\n    const fetchData = async () => &#123;\n      setIsError(false);\n      setIsLoading(true);\n\n      try &#123;\n        const result = await axios(url);\n\n        setData(result.data);\n      &#125; catch (error) &#123;\n        setIsError(true);\n      &#125;\n\n      setIsLoading(false);\n    &#125;;\n\n    fetchData();\n  &#125;, [url]);\n  return (\n    &lt;Fragment>\n      &lt;input\n        type='text'\n        value=&#123;query&#125;\n        onChange=&#123;(event) => setQuery(event.target.value)&#125;\n      />\n      &lt;button\n        type='button'\n        onClick=&#123;() =>\n          setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`)\n        &#125;\n      >\n        Search\n      &lt;/button>\n\n      &#123;isError &amp;&amp; &lt;div>Something went wrong ...&lt;/div>&#125;\n\n      &#123;isLoading ? (\n        &lt;div>Loading ...&lt;/div>\n      ) : (\n        &lt;ul>\n          &#123;data.hits.map((item) => (\n            &lt;li key=&#123;item.objectID&#125;>\n              &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a>\n            &lt;/li>\n          ))&#125;\n        &lt;/ul>\n      )&#125;\n    &lt;/Fragment>\n  );\n&#125;\nexport default App;\n\nCustom hookimport React, &#123; Fragment, useState, useEffect &#125; from 'react';\nimport axios from 'axios';\n\nconst useDataApi = (initialUrl, initialData) => &#123;\n  const [data, setData] = useState(initialData);\n  const [url, setUrl] = useState(initialUrl);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isError, setIsError] = useState(false);\n\n  useEffect(() => &#123;\n    const fetchData = async () => &#123;\n      setIsError(false);\n      setIsLoading(true);\n\n      try &#123;\n        const result = await axios(url);\n\n        setData(result.data);\n      &#125; catch (error) &#123;\n        setIsError(true);\n      &#125;\n\n      setIsLoading(false);\n    &#125;;\n\n    fetchData();\n  &#125;, [url]);\n\n  return [&#123; data, isLoading, isError &#125;, setUrl];\n&#125;;\n\nfunction App() &#123;\n  const [query, setQuery] = useState('redux');\n  const [&#123; data, isLoading, isError &#125;, doFetch] = useDataApi(\n    'https://hn.algolia.com/api/v1/search?query=redux',\n    &#123;\n      hits: [],\n    &#125;\n  );\n\n  return (\n    &lt;Fragment>\n      &lt;form\n        onSubmit=&#123;(event) => &#123;\n          doFetch(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`);\n\n          event.preventDefault();\n        &#125;&#125;\n      >\n        &lt;input\n          type='text'\n          value=&#123;query&#125;\n          onChange=&#123;(event) => setQuery(event.target.value)&#125;\n        />\n        &lt;button type='submit'>Search&lt;/button>\n      &lt;/form>\n\n      &#123;isError &amp;&amp; &lt;div>Something went wrong ...&lt;/div>&#125;\n\n      &#123;isLoading ? (\n        &lt;div>Loading ...&lt;/div>\n      ) : (\n        &lt;ul>\n          &#123;data.hits.map((item) => (\n            &lt;li key=&#123;item.objectID&#125;>\n              &lt;a href=&#123;item.url&#125;>&#123;item.title&#125;&lt;/a>\n            &lt;/li>\n          ))&#125;\n        &lt;/ul>\n      )&#125;\n    &lt;/Fragment>\n  );\n&#125;\n\nexport default App;\n","slug":"useFetchData","date":"2021-04-06T14:27:28.438Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"ba2efac7316616866db1719079267951","title":"Symbol 基础学习","content":"Symbol 内置符号\nECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道 for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。\n\n\n\nSymbol.asyncIterator\n// for-await-of 实现调用\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max = max;\n    this.asyncIdx = 0;\n  &#125;\n  async *[Symbol.asyncIterator]() &#123;\n    while (this.asyncIdx &lt; this.max) &#123;\n      yield new Promise((resolve) => resolve(this.asyncIdx++));\n    &#125;\n  &#125;\n&#125;\nasync function asyncCount() &#123;\n  let emitter = new Emitter(5);\n  for await (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\nasyncCount();\n// 0 1 2 3 4\n\nSymbol.hasInstance\n// instanceof 调用\n\nSymbol.isConcatSpreadable\n// 使用concat的时候会不会被打平\nlet initial = ['foo'];\nlet arrayLikeObject = &#123; length: 1, 0: 'baz' &#125;;\nconsole.log(arrayLikeObject[Symbol.isConcatSpreadable]); // undefined\nconsole.log(initial.concat(arrayLikeObject)); // ['foo', &#123;...&#125;]\narrayLikeObject[Symbol.isConcatSpreadable] = true;\nconsole.log(initial.concat(arrayLikeObject)); // ['foo', 'baz']\n/*\n  [ 'foo', &#123; '0': 'baz', length: 1 &#125; ]\n  [ 'foo', 'baz' ]\n*/\n\nSymbol.iterator\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max = max;\n    this.idx = 0;\n  &#125;\n  *[Symbol.iterator]() &#123;\n    while (this.idx &lt; this.max) &#123;\n      yield this.idx++;\n    &#125;\n  &#125;\n&#125;\nfunction count() &#123;\n  let emitter = new Emitter(5);\n  for (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\ncount();\n\nSymbol.match\n// String.prototype.match() 调用\n\nSymbol.replaceSymbol.searchSymbol.split\nSymbol.toPrimitiveSymbol.toStringTag\n","slug":"symbol","date":"2021-04-06T14:27:28.412Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"f45f275952c50e73ccfd35d25a4b9c92","title":"redux && redux-middleware","content":"redux\n\nimport &#123; createStore &#125; from 'redux';\nlet INC = Symbol.for('INC');\nlet DEC = Symbol.for('DEC');\nlet initialState = 0;\nfunction reducer(state = initialState, action) &#123;\n  switch (action.type) &#123;\n    case INC:\n      return state + 1;\n    case DEC:\n      return state - 1;\n    default:\n      return state;\n  &#125;\n&#125;\n\n/**\n * redux action有要求 有个不是undefined的type类型\n */\nlet store = createStore(reducer);\n\nlet state = store.getState();\nlet countValue = document.getElementById('counter-value');\nlet inc = document.getElementById('inc-btn');\nlet dec = document.getElementById('dec-btn');\nconsole.log(state);\n\nfunction render() &#123;\n  countValue.innerHTML = store.getState();\n&#125;\n\nrender();\n\nstore.subscribe(render);\n\ninc.addEventListener('click', function () &#123;\n  store.dispatch(&#123; type: INC &#125;);\n&#125;);\n\ndec.addEventListener('click', function () &#123;\n  store.dispatch(&#123; type: DEC &#125;);\n&#125;);\n\ncreate-store.js(版本一)import isPlainObject from './utils/isPlainObject';\nimport ActionTypes from './utils/actionType';\nexport default function createStore(reducer, preloadedState) &#123;\n  if (typeof reducer !== 'function') &#123;\n    throw new Error('reducer must be a function');\n  &#125;\n\n  /*******************************/\n  /** initiallize the base property  */\n  let currentState = preloadedState;\n  let currentReducer = reducer;\n  let currentListeners = [];\n  /*******************************/\n\n  function getState() &#123;\n    return currentState;\n  &#125;\n\n  function dispatch(action) &#123;\n    if (!isPlainObject(action)) &#123;\n      throw new Error('action must be a plainObject');\n    &#125;\n    if (typeof action.type === 'undefined') &#123;\n      throw new Error('action need a type property');\n    &#125;\n    currentState = currentReducer(currentState, action);\n    for (let i = 0; i &lt; currentListeners.length; i++) &#123;\n      let listener = currentListeners[i];\n      listener();\n    &#125;\n    return action;\n  &#125;\n\n  dispatch(&#123; type: ActionTypes.INIT &#125;);\n  function subScribe(listener) &#123;\n    currentListeners.push(listener);\n    return function unsubScribe() &#123;\n      const index = currentListeners.indexOf(listener);\n      currentListeners.splice(index, 1);\n    &#125;;\n  &#125;\n\n  return &#123;\n    getState,\n    subScribe,\n    dispatch,\n  &#125;;\n&#125;\n\nbindActionCreatorfunction bindActionCreator(actionCreator, dispatch) &#123;\n  return function () &#123;\n    return dispatch(actionCreator.apply(this, arguments));\n  &#125;;\n&#125;\n\nfunction bindActionCreators(actionCreators, dispatch) &#123;\n  if (typeof actionCreators === 'function') &#123;\n    return bindActionCreator(actionCreators, dispatch);\n  &#125;\n  const boundActionCreators = &#123;&#125;;\n  for (const key in actionCreators) &#123;\n    boundActionCreators[key] = bindActionCreator(actionCreators[key], dispatch);\n  &#125;\n  return boundActionCreators;\n&#125;\n\nexport default bindActionCreators;\n\ncombineReducerexport default function combineReducer(reducers) &#123;\n  const reducerkeys = Object.keys(reducers);\n\n  return function (state = &#123;&#125;, action) &#123;\n    let nextState = &#123;&#125;;\n    for (let i = 0; i &lt; reducerkeys.length; i++) &#123;\n      const key = reducerkeys[i];\n      const reducer = reducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForkey = reducer(previousStateForKey, action);\n      nextState[key] = nextStateForkey;\n    &#125;\n\n    return nextState;\n  &#125;;\n&#125;\n\nutilexport default function isPlainObject(obj) &#123;\n  if (typeof obj !== 'object' || obj === null) &#123;\n    return false;\n  &#125;\n\n  let proto = obj;\n  while (Object.getPrototypeOf(proto)) &#123;\n    proto = Object.getPrototypeOf(proto);\n  &#125;\n\n  return Object.getPrototypeOf(obj) === proto;\n&#125;\n\napplyMiddleWarefunction applyMiddleWare(...middlewares) &#123;\n  return function (createStore) &#123;\n    return function (reducer) &#123;\n      let store = createStore();\n      let dispath = () => &#123;\n        throw new Error();\n      &#125;;\n      let middlewareAPI = &#123;\n        getStore: store.getState,\n        dispatch: (...args) => dispath(...args),\n      &#125;;\n      // middleware = middleware(store);\n      // dispath = middleware(store.dispatch);\n\n      const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n      dispath = componse(...chain)(store.dispatch)\n      return &#123;\n        ...store,\n        dispath,\n      &#125;;\n    &#125;;\n  &#125;;\n&#125;\n\ncomposefunction compose(...funcs) &#123;\n  if (funcs.length === 0) &#123;\n    return (args) => args;\n  &#125;\n  if (funcs.length === 1) &#123;\n    return funcs[0];\n  &#125;\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n&#125;\n\nexport default compose;\n\nreact-reudxindex.jsimport Provider from './Provider';\nimport connect from './connect';\n\nexport &#123; Provider, connect &#125;;\n\nProvider.jsimport React, &#123; Component &#125; from 'react';\nimport ReduxContext from './context';\n\nclass Provider extends Component &#123;\n  render() &#123;\n    return (\n      &lt;ReduxContext.Provider value=&#123;this.props.store&#125;>\n        &#123;this.props.children&#125;\n      &lt;/ReduxContext.Provider>\n    );\n  &#125;\n&#125;\n\nexport default Provider;\n\nconnect.jsimport React from 'react';\nimport ReduxContext from './context';\nimport bindActionCreator from '../redux/bindActionCreator';\nexport default function connect(mapStateToProps, mapDispatchToProps) &#123;\n  return function (WrappedComponent) &#123;\n    return class extends React.Component &#123;\n      static contextType = ReduxContext;\n      constructor(props, context) &#123;\n        super(props);\n        /** context = &#123;store: this.props.store&#125; */\n        this.state = mapDispatchToProps(context.store.getState());\n      &#125;\n      componentDidCatch() &#123;\n        this.unsubscribe = this.context.store.subscribe(() => &#123;\n          this.setState(mapStateToProps(this.context.store.getState()));\n        &#125;);\n      &#125;\n      componentWillUnmount() &#123;\n        this.unsubscribe();\n      &#125;\n      render() &#123;\n        let action = bindActionCreator(\n          mapDispatchToProps,\n          this.context.store.dispatch\n        );\n        return &lt;WrappedComponent &#123;...this.state&#125; &#123;...action&#125; />;\n      &#125;\n    &#125;;\n  &#125;;\n&#125;\n\ncontext.jsimport React from 'react';\n\nconst ReduxContext = React.createContext(null);\nexport default ReduxContext;\n\nredux-promisefunction isPromise(obj) &#123;\n  return (\n    !!obj &amp;&amp;\n    (typeof obj === 'object' || typeof obj === 'function') &amp;&amp;\n    typeof obj.then === 'function'\n  );\n&#125;\nexport default function (&#123; dispatch, getState &#125;) &#123;\n  return (next) => (action) => &#123;\n    return isPromise(action.payload)\n      ? action.payload.then((result) => &#123;\n          dispatch(&#123; ...action, payload: result &#125;);\n        &#125;)\n      : next(action);\n  &#125;;\n&#125;\n\nreudx-thunkfunction createThunkMiddleware() &#123;\n  return (&#123; dispatch, getState &#125; /** middlewareAPI */) => (next) => (\n    action\n  ) => &#123;\n    if (typeof action === 'function') &#123;\n      return action(dispatch, getState);\n    &#125;\n    return next(action);\n  &#125;;\n&#125;\n\n","slug":"redux && redux-middleware","date":"2021-04-06T14:27:28.404Z","categories_index":"React","tags_index":"React,redux,redux-middleware","author_index":"麦当"},{"id":"89dff2a6379feafc73b36875ccf71035","title":"react-setState","content":"react-state 流程\n\nindex.js/** 事务 用wrapper包装起来 */\nclass Transaction &#123;\n  constructor(wrappers) &#123;\n    this.wrappers = wrappers;\n  &#125;\n  /** AOP 编程概念  */\n  perform(anyMethod) &#123;\n    this.wrappers.forEach((wrapper) => wrapper.initialize());\n    anyMethod();\n    this.wrappers.forEach((wrapper) => wrapper.close());\n  &#125;\n&#125;\nlet batchingStrategy = &#123;\n  isBatchingStrates: false /** 标记是否是批量更新模式 */,\n  dirtyComponent: [] /** 脏组件 组件的状态和UI不匹配  */,\n  batchedUpdates() &#123;\n    /** 执行所有的更新操作 */\n    this.dirtyComponent.forEach((component) => component.updateComonent());\n  &#125;,\n&#125;;\nclass Updater &#123;\n  constructor(component) &#123;\n    this.component = component;\n    this.pendingState = [];\n  &#125;\n  addState(partcialState) &#123;\n    this.pendingState.push(partcialState);\n    /** 判断是不是批量更新模式 如果是批量更新 将组件放到脏组件里 做到异步更新 */\n    batchingStrategy.isBatchingStrates\n      ? batchingStrategy.dirtyComponent.push(this.component)\n      : this.component.updateComonent();\n  &#125;\n&#125;\nclass Component &#123;\n  constructor(props) &#123;\n    this.props = props;\n    this.$updater = new Updater(this);\n  &#125;\n  createDOMFromDOMString(domString) &#123;\n    let div = document.createElement('div');\n    div.innerHTML = domString;\n    return div.children[0];\n  &#125;\n  setState(partcialState) &#123;\n    this.$updater.addState(partcialState);\n  &#125;\n\n  /** 组件的更新方法 合并所有的状态 然后进行统一的页面元素UI的替换 */\n  updateComonent() &#123;\n    this.$updater.pendingState.forEach((partcialState) =>\n      Object.assign(this.setState, partcialState)\n    );\n    this.$updater.pendingState.length = 0; /** 清空队列 */\n    let oldElemet = this.domElement;\n    let newElement = this.renderElement();\n    oldElemet.parentElement.replaceChild(newElement, oldElemet);\n  &#125;\n\n  /** 创建页面元素 */\n  renderElement() &#123;\n    let htmlString = this.render();\n    this.domElement = this.createDOMFromDOMString(htmlString);\n    this.domElement.component = this;\n    return this.domElement;\n  &#125;\n\n  /** 组件的挂载方法  */\n  mount(container) &#123;\n    container.appendChild(this.renderElement());\n  &#125;\n&#125;\n\nlet transaction = new Transaction([\n  &#123;\n    initialize() &#123;\n      /** 事件开启的时候进入批量更新模式  */\n      batchingStrategy.isBatchingStrates = true;\n    &#125;,\n    close() &#123;\n      /** 事件结束的时候关闭批量更新模式  */\n      batchingStrategy.isBatchingStrates = false;\n      /** 脏组件进行状态的更新 */\n      batchingStrategy.batchedUpdates();\n    &#125;,\n  &#125;,\n]);\n\n/** 统一的事件处理 挂载到全局  */\nwindow.trigger = function (event, mothodName) &#123;\n  /** 拿到组件的实例(事件委托) 执行绑定的方法 */\n  let component = event.target.component;\n  /** wrapper包装起来 处理一些相关的事件 */\n  transaction.perform(component[mothodName].bind(component));\n&#125;;\n\n/** 子组件 */\nclass Counter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123; number: 0 &#125;;\n  &#125;\n  add() &#123;\n    this.setState(&#123; number: this.state.number + 1 &#125;);\n  &#125;\n\n  render() &#123;\n    return `&lt;button onclick=\"trigger(event, 'add')\">$&#123;this.state.number&#125;&lt;/button>`;\n  &#125;\n&#125;\n\nindex.html&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    &lt;title>Document&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;div id=\"count-app\">&lt;/div>\n  &lt;/body>\n  &lt;script src=\"./index.js\">&lt;/script>\n  &lt;script>\n    let countApp = document.getElementById('count-app');\n    let res = new Counter().render();\n    res.mount(countApp);\n  &lt;/script>\n&lt;/html>\n","slug":"react-setState","date":"2021-04-06T14:27:28.394Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"50552075ed1d1cbaae410e21993db179","title":"react-router-dom","content":"BrowserRouter\n\nimport React, &#123; Component &#125; from 'react';\nimport Context from './context';\n\nlet pushState = window.history.pushState;\n\nclass HashRouter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;\n      location: &#123; pathname: window.location.pathname, state: null &#125;,\n    &#125;;\n  &#125;\n  componentDidMount() &#123;\n    window.history.pushState = (state, title, url) => &#123;\n      pushState.call(window.history, state, title, url);\n      window.onpushstate.call(this, state, url);\n    &#125;;\n    window.onpopstate = (event) => &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: window.location.pathname,\n          state: event.state,\n        &#125;,\n      &#125;);\n    &#125;;\n    window.onpushstate = (state, pathname) => &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: pathname,\n          state: state,\n        &#125;,\n      &#125;);\n    &#125;;\n  &#125;\n  render() &#123;\n    let that = this;\n    let value = &#123;\n      location: that.state.location,\n      history: &#123;\n        push(to) &#123;\n          /** 阻止跳转 */\n          if (that.block) &#123;\n            let confirm = window.confirm(\n              that.block(typeof to === 'object' ? to : &#123; pathname: to &#125;)\n            );\n            if (!confirm) return;\n          &#125;\n          if (typeof to === 'object') &#123;\n            let &#123; pathname, state &#125; = to;\n            window.history.pushState(state, '', pathname);\n          &#125; else &#123;\n            window.history.pushState(null, '', to);\n          &#125;\n        &#125;,\n        block(message) &#123;\n          that.block = message;\n        &#125;,\n      &#125;,\n    &#125;;\n    return (\n      &lt;Context.Provider value=&#123;value&#125;>&#123;this.props.children&#125;&lt;/Context.Provider>\n    );\n  &#125;\n&#125;\n\nexport default HashRouter;\n\ncontext/** 暴露出整个库的context上下文  */\nimport React from 'react';\n\nconst Context = React.createContext();\n\nexport default Context;\n\nHashRouterimport React, &#123; Component &#125; from 'react';\nimport Context from './context';\nclass HashRouter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;\n      location: &#123; pathname: window.location.hash.slice(1), state: null &#125;,\n    &#125;;\n    this.locationState = null;\n  &#125;\n  componentDidMount() &#123;\n    window.location.hash = window.location.hash || '/';\n    window.addEventListener('hashchange', () => &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: window.location.hash.slice(1),\n          state: this.locationState,\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  render() &#123;\n    let that = this;\n    let value = &#123;\n      location: that.state.location,\n      history: &#123;\n        push(to) &#123;\n          /** 阻止跳转 */\n          if (that.block) &#123;\n            let confirm = window.confirm(\n              that.block(typeof to === 'object' ? to : &#123; pathname: to &#125;)\n            );\n            if (!confirm) return;\n          &#125;\n          if (typeof to === 'object') &#123;\n            let &#123; pathname, state &#125; = to;\n            that.locationState = state;\n            window.location.hash = pathname;\n          &#125; else &#123;\n            that.locationState = null;\n            window.location.hash = to;\n          &#125;\n        &#125;,\n        block(message) &#123;\n          that.block = message;\n        &#125;,\n      &#125;,\n    &#125;;\n    return (\n      &lt;Context.Provider value=&#123;value&#125;>&#123;this.props.children&#125;&lt;/Context.Provider>\n    );\n  &#125;\n&#125;\n\nexport default HashRouter;\n\nLinkimport React, &#123; Component &#125; from 'react';\nimport Context from './context';\nclass Link extends Component &#123;\n  static contextType = Context;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;&#125;;\n  &#125;\n  render() &#123;\n    /** 注意合并上部传来的props */\n    return (\n      // eslint-disable-next-line jsx-a11y/anchor-is-valid\n      &lt;a\n        &#123;...this.props&#125;\n        onClick=&#123;() => &#123;\n          this.props.context.history.push(this.props.to);\n        &#125;&#125;\n      >\n        &#123;this.props.children&#125;\n      &lt;/a>\n    );\n  &#125;\n&#125;\n\nexport default Link;\n\n/**\n * &lt;a href=&#123;`#$&#123;this.props.to&#125;`&#125;>&#123;this.props.children&#125;&lt;/a>;\n */\n\nMenuLinkimport React, &#123; Component &#125; from 'react';\nimport Route from './Route';\nimport Link from './Link';\n/**自定义导航 正增加高亮属性 */\n\n/** Route渲染内容有三种方法 component render children */\n// component render 路径匹配渲染\n// children 都会渲染\nfunction MenuLink(&#123; to, exact, children &#125;) &#123;\n  return (\n    &lt;Route\n      path=&#123;to&#125;\n      exact=&#123;exact&#125;\n      children=&#123;(props) => (\n        &lt;li className=&#123;props.match ? 'active' : ''&#125;>\n          &lt;Link to=&#123;to&#125;>&#123;children&#125;&lt;/Link>\n        &lt;/li>\n      )&#125;\n    >&lt;/Route>\n  );\n&#125;\n\nexport default MenuLink;\n\nPromptimport React, &#123; Component &#125; from 'react';\nimport Context from './context';\nclass Prompt extends Component &#123;\n  static contextType = Context;\n\n  componentWillUnmount() &#123;\n    this.history.block(null);\n  &#125;\n  render() &#123;\n    let history = this.context.history;\n    const &#123; when, messaga &#125; = this.props;\n    if (when) &#123;\n      history.block(messaga);\n    &#125; else &#123;\n      history.block(null);\n    &#125;\n\n    return null;\n  &#125;\n&#125;\n\nexport default Prompt;\n\nRedirectimport &#123; Component &#125; from 'react';\nimport Context from './context';\nclass Redirect extends Component &#123;\n  static contextType = Context;\n  render() &#123;\n    this.context.history.push(this.props.to);\n    return null;\n  &#125;\n&#125;\n\nexport default Redirect;\n\nRouteimport PathToRegexp from 'path-to-regexp';\nimport React, &#123; Component &#125; from 'react';\nimport Context from './context';\nclass Route extends Component &#123;\n  static contextType = Context;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;&#125;;\n  &#125;\n  render() &#123;\n    let &#123; pathname &#125; = this.context.location;\n    let &#123;\n      path = '/',\n      component: Component,\n      exact = false,\n      render,\n      children,\n    &#125; = this.props;\n    let paramNames = [];\n    let regxp = PathToRegexp(path, paramNames, &#123; end: exact &#125;);\n    let result = pathname.match(regxp);\n    let props = &#123;\n      location: this.context.location,\n      history: this.props.history,\n    &#125;;\n    if (result) &#123;\n      paramNames = paramNames.map((item) => item.name);\n      let [url, ...values] = result;\n      let params = &#123;&#125;;\n      for (let i = 0; i &lt; paramNames.length; i++) &#123;\n        params[paramNames[i]] = values[i];\n      &#125;\n      props.match = &#123; params, path, url, isExect: url === pathname &#125;;\n      if (Component) &#123;\n        return &lt;Component &#123;...props&#125; />;\n      &#125; else if (render) &#123;\n        /** 检查属性 兼容性 */\n        return render(props);\n      &#125; else if (children) &#123;\n        return children(props);\n      &#125; else &#123;\n        return null;\n      &#125;\n    &#125; else &#123;\n      if (children) return children(props);\n      else return null;\n    &#125;\n  &#125;\n&#125;\n\nexport default Route;\n\nSwitchimport &#123; Component &#125; from 'react';\nimport PathToRegexp from 'path-to-regexp';\nclass Switch extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;&#125;;\n  &#125;\n  render() &#123;\n    let &#123; pathname &#125; = this.context.location;\n    let children = Array.isArray(this.props.children)\n      ? this.props\n      : [this.props.children];\n    for (let i = 0; i &lt; children.length; i++) &#123;\n      let child = children[i];\n      let &#123; path = '/', exect = false &#125; = child.props;\n      let pathNames = [];\n      let reg = PathToRegexp(path, pathNames, &#123; end: exect &#125;);\n      let result = pathname.match(reg);\n      if (result) &#123;\n        return child; /** react的元素 React.createElement */\n      &#125;\n    &#125;\n    return null;\n  &#125;\n&#125;\n\nexport default Switch;\n\nWithRouterimport React from 'react';\nimport Route from './Route';\n\n// eslint-disable-next-line import/no-anonymous-default-export\nexport default function (WrappedComponent) &#123;\n  return (props) => &lt;Route component=&#123;WrappedComponent&#125; />;\n&#125;\n","slug":"react-router-dom","date":"2021-04-06T14:27:28.383Z","categories_index":"React","tags_index":"React,react-router-dom","author_index":"麦当"},{"id":"fa08fd35cb36d755ed7492a61cf66138","title":"react Hooks","content":"useState\n\n每次渲染都是一个独立的闭包\n每次渲染都会有自己的 props 和 state\n每次渲染后会有自己的时间处理函数\n\nfunction Counter() &#123;\n  let [num, setNum] = useState(0);\n  function alertNum() &#123;\n    setTimeout(() => &#123;\n      alert(num);\n    &#125;, 3000);\n  &#125;\n  return (\n    &lt;div>\n      &lt;p>&#123;num&#125;&lt;/p>\n      &lt;button onClick=&#123;() => setNum&#125;>&lt;/button>\n      &lt;button onClick=&#123;alertNum&#125;>alert&lt;/button>\n    &lt;/div>\n  );\n&#125;\n\nfunction Counter() &#123;\n  let [num, setNum] = useState(0);\n  function lazy()&#123;\n    setTimeout((\n      // 有差别\n -     setNum(num + 1);\n -     setNum(num => num + 1);\n    )=>&#123;&#125;, 3000)\n  &#125;\n  return (\n    &lt;div>\n      &lt;p>&#123;num&#125;&lt;/p>\n      &lt;button onClick=&#123;() => setNum&#125;>&lt;/button>\n      &lt;button onClick=&#123;lazy&#125;>lazy&lt;/button>\n    &lt;/div>\n  );\n&#125;\n\n惰性初始化\nfunction Counter(props) &#123;\n  let [counter, setCounter] = useState(function () &#123;\n    return &#123; num: props.num &#125;;\n  &#125;);\n  return (\n    &lt;div>\n      &lt;p>&#123;counter.num&#125;&lt;/p>\n      &lt;button onClick=&#123;() => setCounter&#125;>&lt;/button>\n    &lt;/div>\n  );\n&#125;\n\nefect每次我们重新渲染 都会生成新的 effect 替换之前的 effect 属于渲染结果的一部分 effect 属于特定的渲染\n","slug":"react-hook","date":"2021-04-06T14:27:28.370Z","categories_index":"React","tags_index":"React,react hook","author_index":"麦当"},{"id":"b9a37f021de474295d3010955ace362e","title":"react base","content":"生命周期(老版)\n\n\nimport React, &#123; Component &#125; from 'react';\n\nclass LifeCycle extends Component &#123;\n  /**组件的静态属性 */\n  static defaultProps = &#123; name: '计数器' &#125;;\n  constructor(props) &#123;\n    /** setup props and state */\n    super(props);\n    this.state = &#123; number: 0 &#125;;\n    console.log('setup');\n  &#125;\n  componentWillMount() &#123;\n    console.log('2 组件将要挂载');\n  &#125;\n  componentDidMount() &#123;\n    console.log('4.组件挂载完成');\n  &#125;\n  shouldComponentUpdate() &#123;\n    console.log('5. 询问组件是否要更新');\n    return true;\n  &#125;\n  componentWillUpdate() &#123;\n    console.log('6 组件将要更新');\n  &#125;\n  componentDidUpdate() &#123;\n    console.log('7 组件已经更新完毕');\n  &#125;\n  add = () => &#123;\n    this.setState(&#123;\n      number: this.state.number + 1,\n    &#125;);\n  &#125;;\n  render() &#123;\n    console.log('parent render');\n    return (\n      &lt;div>\n        &lt;p>&#123;this.state.name&#125;&lt;/p>\n        &lt;button onClick=&#123;this.add&#125;>+&lt;/button>\n        &lt;Sub />\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nexport default LifeCycle;\n\nclass Sub extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123; age: 10 &#125;;\n  &#125;\n  componentWillReceiveProps() &#123;\n    console.log('componentWillReceiveProps');\n  &#125;\n  render() &#123;\n    console.log('children render');\n    return (\n      &lt;div>\n        &lt;p>age:&#123;this.state.age&#125;&lt;/p>\n        &lt;button\n          onClick=&#123;() => &#123;\n            this.setState(&#123; age: this.state.age + 1 &#125;);\n          &#125;&#125;\n        >&lt;/button>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\n生命周期新版\ngetDerivedStateFromPropsimport React, &#123; Component &#125; from 'react';\nclass Counter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123; number: 0 &#125;;\n  &#125;\n  add = () => &#123;\n    this.setState(&#123;\n      number: this.state.number + 1,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div>\n        &lt;p>&#123;this.state.number&#125;&lt;/p>\n        &lt;button onClick=&#123;this.add&#125;>+&lt;/button>\n        &lt;SubCounter number=&#123;this.state.number&#125; />\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nclass SubCounter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123; number: 0 &#125;;\n  &#125;\n  /** 将State和Props传来的值全部整合到state上 */\n  static getDerivedStateFromProps(nextProps, prevState) &#123;\n    if (nextProps.number % 2 === 0) &#123;\n      return &#123; number: nextProps.number * 2 &#125;;\n    &#125; else &#123;\n      return &#123; number: nextProps.number * 3 &#125;;\n    &#125;\n  &#125;\n  render() &#123;\n    return &lt;div>&#123;this.state.number&#125;&lt;/div>;\n  &#125;\n&#125;\n\nexport default Counter;\n\ngetSnapshotBeforeUpdateimport React, &#123; Component &#125; from 'react';\nclass getSnapshotBeforeUpdateComponent extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.wrapper = React.createRef();\n    this.state = &#123; message: ['5', '4', '3', '2', '1'] &#125;;\n  &#125;\n\n  componentDidMount() &#123;\n    setInterval(() => &#123;\n      this.setState(&#123;\n        message: [this.state.message.length, ...this.state.message],\n      &#125;);\n    &#125;, 1000);\n  &#125;\n\n  getSnapshotBeforeUpdate() &#123;\n    return this.wrapper.current.scrollHeight;\n  &#125;\n  componentDidUpdate(prevProps, prevState, scrollHeight) &#123;\n    let Dom = this.wrapper.current;\n    Dom.scrollTop = Dom.scrollTop + (Dom.scrollHeight - scrollHeight);\n  &#125;\n  render() &#123;\n    let style = &#123;\n      height: '100p',\n      width: '200px',\n      border: '1px solid red',\n      overflow: 'auto',\n    &#125;;\n    return (\n      &lt;div style=&#123;style&#125; ref=&#123;this.wrapper&#125;>\n        &lt;ul>\n          &#123;this.state.message.map((item, index) => &#123;\n            return &lt;li key=&#123;index&#125;>&#123;item&#125;&lt;/li>;\n          &#125;)&#125;\n        &lt;/ul>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nexport default getSnapshotBeforeUpdateComponent;\n\ncontext(上下文)旧版import React, &#123; Component &#125; from 'react';\nimport propTypes from 'prop-types';\nclass Page extends Component &#123;\n  static childContextTypes = &#123;\n    color: propTypes.string,\n    setColor: propTypes.func,\n  &#125;;\n  getChildContext() &#123;\n    return &#123; color: 'gray', setColor: this.setColor &#125;;\n  &#125;\n\n  setColor = (color) => &#123;\n    this.setColor(&#123; color &#125;);\n  &#125;;\n  constructor() &#123;\n    super();\n    this.state = &#123; color: 'gray' &#125;;\n  &#125;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;Header>\n          &lt;Title>&lt;/Title>\n        &lt;/Header>\n        &lt;Main>\n          &lt;Content>&lt;/Content>\n        &lt;/Main>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\nclass Header extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div>\n        Header\n        &lt;Title>&lt;/Title>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nclass Title extends Component &#123;\n  /** 子集关系 */\n  static contextTypes = &#123;\n    color: propTypes.string,\n    setColor: propTypes.func,\n  &#125;;\n  /**\n   * this.context.color\n   * this.context.setColor\n   */\n\n  render() &#123;\n    return &lt;div>Title&lt;/div>;\n  &#125;\n&#125;\n\nclass Main extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div>\n        Main\n        &lt;Content>&lt;/Content>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nclass Content extends Component &#123;\n  render() &#123;\n    return &lt;div>Content&lt;/div>;\n  &#125;\n&#125;\n\nexport default Page;\n\n新版// import &#123; func &#125; from 'prop-types';\nimport React, &#123; Component &#125; from 'react';\n// import propTypes from 'prop-types';\nconst ThemeContext = React.createContext();\n/**\n * ThemeContext = &#123;Provider Consumer&#125;\n *\n */\n\n/**-------- createContext -----------------------------------*/\n\nfunction createContext() &#123;\n  class Provider extends Component &#123;\n    static value;\n    constructor(props) &#123;\n      super(props);\n      Provider.value = props.value;\n    &#125;\n    render() &#123;\n      return this.props.children;\n    &#125;\n  &#125;\n\n  class Consumer extends Component &#123;\n    render() &#123;\n      return this.props.children(Provider.value);\n    &#125;\n  &#125;\n\n  return &#123; Provider, Consumer &#125;;\n&#125;\n\n/**----------------------------------------------------------- */\n\nclass Page extends Component &#123;\n  constructor() &#123;\n    super();\n    this.state = &#123; color: 'gray' &#125;;\n  &#125;\n  setColor(color) &#123;\n    this.setState(&#123; color &#125;);\n  &#125;\n  render() &#123;\n    let ctx = &#123; color: 'gray', setColor: this.setColor &#125;;\n    return (\n      &lt;ThemeContext.Provider value=&#123;ctx&#125;>\n        &lt;Header>\n          &lt;Title>&lt;/Title>\n        &lt;/Header>\n        &lt;Main>\n          &lt;Content>&lt;/Content>\n        &lt;/Main>\n      &lt;/ThemeContext.Provider>\n    );\n  &#125;\n&#125;\n\nclass Header extends Component &#123;\n  /**----------------------------------------------- */\n  static contextType = ThemeContext;\n  /**----------------------------------------------- */\n\n  /**\n   * this.context 拿到了所有的值\n   */\n  render() &#123;\n    return (\n      &lt;div>\n        Header\n        &lt;Title>&lt;/Title>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nfunction Title(props) &#123;\n  return &lt;div>title&lt;/div>;\n&#125;\n\nclass Main extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div>\n        Main\n        &lt;Content>&lt;/Content>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nclass Content extends Component &#123;\n  render() &#123;\n    return &lt;div>Content&lt;/div>;\n  &#125;\n&#125;\n\nexport default Page;\n\npureComponentimport React, &#123; PureComponent &#125; from 'react';\n\nclass Title extends PureComponent &#123;\n  render() &#123;\n    return &lt;div>&#123;this.props.title&#125;&lt;/div>;\n  &#125;\n&#125;\n\nclass Counter extends PureComponent &#123;\n  render() &#123;\n    return &lt;div>&#123;this.props.number&#125;&lt;/div>;\n  &#125;\n&#125;\n\nexport default class App extends PureComponent &#123;\n  constructor(props) &#123;\n    super(props);\n    this.props = props;\n    this.state = &#123; title: '计数器', number: 0 &#125;;\n    this.inputRef = React.createRef();\n  &#125;\n  add = () => &#123;\n    this.setState(&#123;\n      number: this.state.number + parseInt(this.inputRef.current.value),\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div>\n        &lt;Title title=&#123;this.state.title&#125; />\n        &lt;Counter number=&#123;this.state.number&#125; />\n        &lt;input ref=&#123;inputRef&#125; />\n        &lt;button onClick=&#123;this.add&#125;>+&lt;/button>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nimport React, &#123; Component &#125; from 'react';\n\nexport default class PureComponent extends Component &#123;\n  isPureComponent = true;\n  shouldComponentUpdate(nextProps, nextState) &#123;\n    return (\n      !shallowEqual(this.props, nextProps) ||\n      !shallowEqual(this.state, nextState)\n    );\n  &#125;\n  render() &#123;\n    return &lt;div>1&lt;/div>;\n  &#125;\n&#125;\n\nfunction shallowEqual(obj1, obj2) &#123;\n  if (obj1 === obj2) return true;\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) &#123;\n    return false;\n  &#125;\n\n  let keys1 = Object.keys(obj1);\n  let keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  for (let key of keys1) &#123;\n    if (!obj2.hasOwnProperty(key)) &#123;\n      if (obj1[key] !== obj2[key]) &#123;\n        if (typeof obj1[key] === 'object' &amp;&amp; typeof obj2[key] === 'object') &#123;\n          return shallowEqual(obj1[key], obj2[key]);\n        &#125;\n      &#125; else &#123;\n        return false;\n      &#125;\n    &#125;\n  &#125;\n  return true;\n&#125;\n\nmemoimport React, &#123; PureComponent &#125; from &#39;react&#39;;\n\nfunction memo(FunComponent) &#123;\n  return class Proxy extends PureComponent &#123;\n    render() &#123;\n      return FunComponent(this.props)\n    &#125;\n  &#125;;\n&#125;\nexport default memo;\n\n\n高阶组件&#x2F;**\n * 高阶函数 传入一个函数 返回一个新的函数\n * 高阶组件 传入一个组件 返回一个新的组件\n *&#x2F;\n\nimport React from &#39;react&#39;;\nexport default function withLogger(Comp) &#123;\n  return class extends React.Component &#123;\n    componentWillMount() &#123;\n      this.start &#x3D; Date.now();\n    &#125;\n    componentDidMount() &#123;\n      console.log(Date.now() - this.start + &#39;ms&#39;);\n    &#125;\n\n    render() &#123;\n      return &lt;Comp &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n&#125;\n\n\nrender props&lt;MouseTracker&gt;\n\t&#123;\n        (props)&#x3D;&gt;&lt;Pirture &#123;...props&#125;&#x2F;&gt;\n    &#125;\n&lt;&#x2F;MouseTracker&gt;\n\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\nclass MouseTracker extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; x: 0, y: 0 &#125;;\n  &#125;\n  handleMouseMove &#x3D; (event) &#x3D;&gt; &#123;\n    this.setState(&#123;\n      x: event.clientX,\n      y: event.clientY,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div onMouseOver&#x3D;&#123;this.handleMouseMove&#125;&gt;\n            &#x2F;* 执行子组件 函数组件*&#x2F;\n        &#123;this.props.children(&#123; x: this.state.x, y: this.state.y &#125;)&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default MouseTracker;\n\n\nFrament&lt;React.Fragment>\n\nprotalimport React, &#123; Component &#125; from 'react';\nimport ReactDOM from 'react-dom';\nclass Modal extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.modal = document.getElementById('modal-root');\n  &#125;\n  render() &#123;\n    return ReactDOM.createPortal(this.props.children, this.modal);\n  &#125;\n&#125;\n\nclass Page extends Component &#123;\n  constructor(prop) &#123;\n    super(prop);\n    this.state = &#123; show: false &#125;;\n  &#125;\n  toggleModal = () => &#123;\n    this.setState(&#123;\n      show: !this.state.show,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div>\n        &lt;button onClick=&#123;this.toggleModal&#125;>关闭/显示&lt;/button>\n        &#123;this.state.show &amp;&amp; (\n          &lt;Modal>\n            &lt;div id='modal' className='modal'>\n              &lt;div id='content' className='content'>\n                Modal\n              &lt;/div>\n            &lt;/div>\n          &lt;/Modal>\n        )&#125;\n      &lt;/div>\n    );\n  &#125;\n&#125;\n\nexport default Page;\n\n错误边界import React, &#123; Component &#125; from 'react';\nclass ErrorBoundary extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123; hasErrors: false &#125;;\n  &#125;\n  /* 捕获异常 检查错误*/\n  componentDidCatch(err, info) &#123;\n    if (err) &#123;\n      this.setState(&#123;\n        hasErrors: true,\n      &#125;);\n    &#125;\n  &#125;\n  render() &#123;\n    if (this.state.hasErrors) &#123;\n      return &lt;div> error&lt;/div>;\n    &#125; else &#123;\n      return this.props.children;\n    &#125;\n  &#125;\n&#125;\n\nclass Clock extends Component &#123;\n  render() &#123;\n    return &lt;div>&#123;Date.now()&#125;&lt;/div>;\n  &#125;\n&#125;\n\nclass page extends Component &#123;\n  render() &#123;\n    return (\n      &lt;ErrorBoundary>\n        &lt;Clock />\n      &lt;/ErrorBoundary>\n    );\n  &#125;\n&#125;\n\nexport default page;\n","slug":"react-base","date":"2021-04-06T14:27:28.342Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"764ea20144bdcb36de34ee7af78c0567","title":"proxy 基础学习","content":"代理基础什么是代理\n代理是目标对象的抽象，类似于 c++的指针，可以用作目标的替身，又独立目标之外。\n\n\nconst target = &#123;\n  id: 'target',\n&#125;;\n\nconst handler = &#123;&#125;;\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.id);\n\n// proxy的prototype是undefined\n\n定义捕获器\nconst target = &#123;\n  id: 'target',\n&#125;;\n\nconst handler = &#123;\n  get() &#123;\n    return 'handler override';\n  &#125;,\n&#125;;\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.id);\n// 只有代理才会产生捕获 原来的目标没有这样的行为\n\n反射 API\nconst target = &#123;\n  id: 'target',\n&#125;;\n\nconst handler = &#123;\n  get() &#123;\n    console.log('get handler');\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;;\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log('----------', proxy.id);\n\n捕获器不变式\nconst target = &#123;&#125;;\nObject.defineProperty(target, 'foo', &#123;\n  configurable: false,\n  writable: false,\n  value: 'bar',\n&#125;);\nconst handler = &#123;\n  get() &#123;\n    return 'qux';\n  &#125;,\n&#125;;\nconst proxy = new Proxy(target, handler);\nconsole.log(proxy.foo);\n\n撤销代理\nconst target = &#123;\n  foo: 'bar',\n&#125;;\nconst handler = &#123;\n  get() &#123;\n    return 'intercepted';\n  &#125;,\n&#125;;\nconst &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);\nconsole.log(proxy.foo); // intercepted\nconsole.log(target.foo); // bar\nrevoke();\nconsole.log(proxy.foo); // TypeError\n\n**实用反射 API **\n// 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功\nconst o = &#123;&#125;;\ntry &#123;\n  Object.defineProperty(o, 'foo', 'bar');\n  console.log('success');\n&#125; catch (e) &#123;\n  console.log('failure');\n&#125;\n// 使用代理之后\n// 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。\n// 因此使用这个反射方法可以这样重构上面的代码：\n// 重构后的代码\nconst o = &#123;&#125;;\nif (Reflect.defineProperty(o, 'foo', &#123; value: 'bar' &#125;)) &#123;\n  console.log('success');\n&#125; else &#123;\n  console.log('failure');\n&#125;\n\n其他的状态标记反射 API\nReflect.defineProperty();\nReflect.preventExtensions();\nReflect.setPrototypeOf();\nReflect.set();\nReflect.deleteProperty();\n\n用一等函数替代操作符\n以下反射方法提供只有通过操作符才能完成的操作。\nReflect.get()：可以替代对象属性访问操作符。\nReflect.set()：可以替代=赋值操作符。\nReflect.has()：可以替代 in 操作符或 with()。\nReflect.deleteProperty()：可以替代 delete 操作符。\nReflect.construct()：可以替代 new 操作符。\n代理的问题\nconst wm = new WeakMap();\n\nclass User &#123;\n\n constructor(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n set id(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n get id() &#123;\n\n \treturn wm.get(this);\n\n &#125;\n\n&#125;\n\n由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：\n\nconst user = new User(123);\n\nconsole.log(user.id); // 123\n\nconst userInstanceProxy = new Proxy(user, &#123;&#125;);\n\nconsole.log(userInstanceProxy.id); // undefined\n\n// 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实\n\n// 例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代\n\n// 理的实例就会以代理实例作为 WeakMap 的键了：\n\nconst UserClassProxy = new Proxy(User, &#123;&#125;);\n\nconst proxyUser = new UserClassProxy(456);\n\nconsole.log(proxyUser.id);  //\n\n代理与内部槽位\n/*\n代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可\n能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的\n内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通\n的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：\n*/\nconst target = new Date();\nconst proxy = new Proxy(target, &#123;&#125;);\nconsole.log(proxy instanceof Date); // true\nproxy.getDate(); // TypeError: 'this' is not a Date object\n\n代理捕获器get()\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  get(target, property, receiver) &#123;\n    console.log('get()');\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;);\nproxy.foo;\n\n拦截的操作\n\nproxy.property\nproxy[property]\nObject.create(proxy)[property]\nReflect.get(proxy, property, receiver)\n\nset\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  set(target, property, value, receiver) &#123;\n    console.log('set()');\n    return Reflect.set(...arguments);\n  &#125;,\n&#125;);\nproxy.foo = 'bar';\n// 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。\n\n拦截的操作\n\nproxy.property = value\nproxy[property] = value\nObject.create(proxy)[property] = value\nReflect.set(proxy, property, value, receiver)\n\nhas\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  has(target, property) &#123;\n    console.log('has()');\n    return Reflect.has(...arguments);\n  &#125;,\n&#125;);\n'foo' in proxy;\n// has()\n\n\nproperty in proxy\nproperty in Object.create(proxy)\nwith(proxy) {(property);}\nReflect.has(proxy, property)\n\ndefineProperty()\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  defineProperty(target, property, descriptor) &#123;\n    console.log('defineProperty()');\n    return Reflect.defineProperty(...arguments);\n  &#125;,\n&#125;);\nObject.defineProperty(proxy, 'foo', &#123; value: 'bar' &#125;);\n// Object.defineProperty(proxy, property, descriptor)\n// Reflect.defineProperty(proxy, property, descriptor)\n\ngetOwnPropertyDescriptor\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  getOwnPropertyDescriptor(target, property) &#123;\n    console.log('getOwnPropertyDescriptor()');\n    return Reflect.getOwnPropertyDescriptor(...arguments);\n  &#125;,\n&#125;);\nObject.getOwnPropertyDescriptor(proxy, 'foo');\n// getOwnPropertyDescriptor()\n\n// Object.getOwnPropertyDescriptor(proxy, property)\n// Reflect.getOwnPropertyDescriptor(proxy, property)\n\ndeleteProperty\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  deleteProperty(target, property) &#123;\n    console.log('deleteProperty()');\n    return Reflect.deleteProperty(...arguments);\n  &#125;,\n&#125;);\ndelete proxy.foo;\n// deleteProperty()\n/*\n    delete proxy.property\n    delete proxy[property]\n    Reflect.deleteProperty(proxy, property)\n*/\n\nownKeys\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  ownKeys(target) &#123;\n    console.log('ownKeys()');\n    return Reflect.ownKeys(...arguments);\n  &#125;,\n&#125;);\nObject.keys(proxy);\n// ownKeys()\n/*\n    Object.getOwnPropertyNames(proxy)\n    Object.getOwnPropertySymbols(proxy)\n    Object.keys(proxy)\n    Reflect.ownKeys(proxy)\n*/\n\ngetPrototypeOf\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  getPrototypeOf(target) &#123;\n    console.log('getPrototypeOf()');\n    return Reflect.getPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.getPrototypeOf(proxy);\n// getPrototypeOf()\n\n/*\n    Object.getPrototypeOf(proxy)\n    Reflect.getPrototypeOf(proxy)\n    proxy.__proto__\n    Object.prototype.isProt\n*/\n\nsetPrototypeOf\nconst myTarget = &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  setPrototypeOf(target, prototype) &#123;\n    console.log('setPrototypeOf()');\n    return Reflect.setPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.setPrototypeOf(proxy, Object);\n// setPrototypeOf()\n\n/*\n    Object.setPrototypeOf(proxy)\n    Reflect.setPrototypeOf(proxy)\n*/\n\nisExtensible\npreventExtensions\napply\nconst myTarget = () => &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  apply(target, thisArg, ...argumentsList) &#123;\n    console.log('apply()');\n    return Reflect.apply(...arguments);\n  &#125;,\n&#125;);\nproxy();\n/*\n    proxy(...argumentsList)\n    Function.prototype.apply(thisArg, argumentsList)\n    Function.prototype.call(thisArg, ...argumentsList)\n    Reflect.apply(target, thisArgument, argumentsList)\n*/\n\nconstruct\nconst myTarget = function () &#123;&#125;;\nconst proxy = new Proxy(myTarget, &#123;\n  construct(target, argumentsList, newTarget) &#123;\n    console.log('construct()');\n    return Reflect.construct(...arguments);\n  &#125;,\n&#125;);\nnew proxy();\n// construct()\n/*\n    new proxy(...argumentsList)\n    Reflect.construct(target, argumentsList, newTarget)\n*/\n","slug":"proxy","date":"2021-04-06T14:27:28.313Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"3a1de7864b72f88f991d2ad903723f46","title":"connected-react-router","content":"index.js\n\nimport routerMiddlware from './routerMiddlware';\nimport connectRouter from './connectRouter';\nimport push from './push';\nimport ConnectedRouter from './ConnectedRouter';\nexport &#123; routerMiddlware, connectRouter, push, ConnectedRouter &#125;;\n\n\n\nconstantsexport const CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';\nexport const LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nConnectedRouter.jsimport React, &#123; Component &#125; from 'react';\nimport &#123; ReactReduxContext &#125; from 'react-redux';\nimport &#123; Route &#125; from 'react-router';\nimport &#123; LOCATION_CHANGE &#125; from './constants';\nclass ConnectedRouter extends Component &#123;\n  static contextType = ReactReduxContext;\n  constructor(props) &#123;\n    super(props);\n    this.state = &#123;&#125;;\n  &#125;\n  componentDidMount() &#123;\n    // location 新的路径\n    // action 新的动作 POP PUSH\n    this.unlistener = this.props.history.listen((location, action) => &#123;\n      this.context.store.dispatch(&#123;\n        type: LOCATION_CHANGE,\n        payload: &#123; location, action &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  componentWillUnmount() &#123;\n    this.unlistener();\n  &#125;\n  render() &#123;\n    let &#123; history, children &#125; = this.props;\n    return &lt;Route history=&#123;history&#125;>&#123;children&#125;&lt;/Route>;\n  &#125;\n&#125;\n\nexport default ConnectedRouter;\n\nconnectRouter.jsimport &#123; LOCATION_CHANGE &#125; from './constants';\n// eslint-disable-next-line import/no-anonymous-default-export\nexport default function (history) &#123;\n  let initialState = &#123; action: history.action, location: history.location &#125;;\n  return function (state = initialState, action) &#123;\n    switch (action.type) &#123;\n      case LOCATION_CHANGE:\n        return action.payload;\n      default:\n        return state;\n    &#125;\n  &#125;;\n&#125;\n\npushimport &#123; CALL_HISTORY_METHOD &#125; from './constants';\nfunction push(path) &#123;\n  return &#123;\n    type: CALL_HISTORY_METHOD,\n    payload: &#123;\n      method: 'push',\n      path,\n    &#125;,\n  &#125;;\n&#125;\n\nexport default push;\n\nrouterMiddleware.jsimport &#123; CALL_HISTORY_METHOD &#125; from './constants';\n// eslint-disable-next-line import/no-anonymous-default-export\nexport default function (history) &#123;\n  return (&#123; dispatch, getState &#125;) => (next) => (action) => &#123;\n    if (action.type === CALL_HISTORY_METHOD) &#123;\n      let &#123; method, path &#125; = action.payload;\n      history[method](path);\n    &#125; else &#123;\n      next();\n    &#125;\n  &#125;;\n&#125;\n","slug":"connected-react-router","date":"2021-04-06T14:27:28.294Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"20aabeefe97ee970307cf5d861ceb05e","title":"leetcode 加油站","content":"分析\n\n\n枚举每个站点 然后尝试从这个站点走n次, 如果可以顺利走了n 次的话 就是可以绕一周，就是题解，如果如果中途不可以继续走下去了，那个 i-j 中的子集部分也不可能走下去了。时间复杂度:O(n)空间复杂度:O(1)\n\n题解/**\n * @param &#123;number[]&#125; gas\n * @param &#123;number[]&#125; cost\n * @return &#123;number&#125;\n */\nvar canCompleteCircuit = function (gas, cost) &#123;\n  let n = gas.length;\n\n  let i, j;\n  for (i = 0; i &lt; n; ) &#123;\n    let left = 0;\n\n    for (j = 0; j &lt; n; j++) &#123;\n      let k = (i + j) % n;\n      left = left + gas[k] - cost[k];\n      if (left &lt; 0) break;\n    &#125;\n\n    if (j == n) return i;\n    else i += j + 1;\n  &#125;\n  return -1;\n&#125;;\n","slug":"134加油站","date":"2021-04-06T14:27:28.256Z","categories_index":"leetcode","tags_index":"leetcode","author_index":"麦当"}]