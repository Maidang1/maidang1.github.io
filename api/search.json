[{"id":"f7da3a6dbd8139fcbf33c613ff852d63","title":"cssnext介绍以及使用","content":"什么是cssnext\nPostCSS-cssnext is a PostCSS plugin that helps you to use the latest CSS syntax today. It transforms new CSS specs into more compatible CSS so you don’t need to wait for browser support. \n意思就是你现在就可以使用css的一些新的语法 即使现在的浏览器不支持 你也可以去使用\n\nFeatures变量:root &#123;\n    --mainColor: red;\n&#125;\n\na &#123;\n    color: var(--mainColor);\n&#125;\n\n&#x2F;&#x2F; limited to :root selector\n\n:root &#123;\n    --danger-theme: &#123;\n        color: white;\n        background-color: red;\n    &#125;\n&#125;\n\n.danger &#123;\n    @apply --danger-theme;\n&#125;\n\n计算:root &#123;\n    --fontSize: 1rem;\n&#125;\nh1 &#123;\n    font-size: calc(var(--fontSize) *  2);\n&#125;\n\nnestinga &#123;\n    color: #fff;\n    &amp;:hover &#123;\n        color: red;\n    &#125;\n&#125;\n\nimage-set.foot &#123;\n    background-image: image-set(\n    \turl(img&#x2F;test.png) 1x,\n        url(img&#x2F;test2.png) 2x,\n        url(default.png) 600dpi,\n    )\n&#125;\n\n更多\n使用create-react-appnpm run eject\n\n然后在webpack.config.js\nloader: require.resolve(&quot;postcss-loader&quot;),\n       options: &#123;\n         &#x2F;&#x2F; Necessary for external CSS imports to work\n         &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;create-react-app&#x2F;issues&#x2F;2677\n         ident: &quot;postcss&quot;,\n         plugins: () &#x3D;&gt; [\n           require(&quot;postcss-flexbugs-fixes&quot;),\n           require(&quot;postcss-preset-env&quot;)(&#123;\n             autoprefixer: &#123;\n               flexbox: &quot;no-2009&quot;,\n             &#125;,\n            &#x2F;* start *&#x2F;\n             stage: 3,\n             features: &#123;\n               &quot;nesting-rules&quot;: true,\n             &#125;,\n           &#x2F;* end *&#x2F;\n           &#125;),\n         &#125;\n\n","slug":"cssnext介绍以及使用","date":"2021-05-16T07:26:00.000Z","categories_index":"","tags_index":"","author_index":"麦当"},{"id":"b23d813ab87380625160f23e617b9635","title":"vue3响应式API原理","content":"\nvue3响应式API的简单实现\n\nreactiveimport &#123;\n  isObject,\n  isSymbol,\n  isArray,\n  isInteger,\n  hasOwnProperty,\n  hasOwn,\n  hasChange,\n&#125; from &quot;..&#x2F;share&#x2F;index&quot;;\nimport &#123; track, trigger &#125; from &quot;.&#x2F;effect&quot;;\n\nfunction createGetter() &#123;\n  return function get(target, key, receiver) &#123;\n    const res &#x3D; Reflect.get(target, key, receiver);\n    &#x2F;&#x2F; res symbol 忽略\n    if (isSymbol(key)) &#123;\n      return res;\n    &#125;\n\n    &#x2F;&#x2F; 进行依赖收集\n    track(target, key);\n    &#x2F;&#x2F; 懒递归\n    if (isObject(res)) &#123;\n      return reactive(res);\n    &#125;\n\n    return res;\n  &#125;;\n&#125;\nfunction createSetter() &#123;\n  return function set(target, key, value, receiver) &#123;\n    const oldValue &#x3D; target[key];\n    const hadKey &#x3D;\n      isArray(target) &amp;&amp; isInteger(key)\n        ? Number(key) &lt; target.length\n        : hasOwn(target, key);\n    const result &#x3D; Reflect.set(target, key, value, receiver);\n\n    if (!hadKey) &#123;\n      &#x2F;&#x2F; 新增操作\n      trigger(target, &quot;add&quot;, key, value);\n    &#125; else if (hasChange(oldValue, value)) &#123;\n      &#x2F;&#x2F; 修改操作\n      trigger(target, &quot;set&quot;, key, value, oldValue);\n    &#125;\n\n    return result;\n  &#125;;\n&#125;\nconst set &#x3D; createSetter();\nconst get &#x3D; createGetter();\n\nconst mutableHandlers &#x3D; &#123;\n  get,\n  set,\n&#125;;\n\nexport function reactive(target: object) &#123;\n  return createReactiveObj(target, mutableHandlers);\n&#125;\n\nconst proxyMap &#x3D; new WeakMap();\n\nfunction createReactiveObj(target: object, mutableHandlers: any) &#123;\n  if (!isObject(target)) &#123;\n    return target;\n  &#125;\n  &#x2F;&#x2F; 取出代理过得数据\n  const existingProxy &#x3D; proxyMap.get(target);\n  if (existingProxy) &#123;\n    return existingProxy;\n  &#125;\n  const proxy &#x3D; new Proxy(target, mutableHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n&#125;\n\n\n\n\neffectimport &#123; isArray, isInteger &#125; from &quot;..&#x2F;share&#x2F;index&quot;;\n\nlet activeEffect; &#x2F;&#x2F; 存储effect函数 以后会执行\nlet uid &#x3D; 0;\nconst effectStack &#x3D; [];\nfunction createReactiveEffect(fn, options) &#123;\n  const effect &#x3D; function () &#123;\n    &#x2F;&#x2F; 防止递归执行\n    if (!effectStack.includes(effectStack)) &#123;\n      try &#123;\n        activeEffect &#x3D; effect;\n        effectStack.push(activeEffect);\n        return fn(); &#x2F;&#x2F; 用户写的逻辑 内部会有取值的操作 再去取值的时候 应该执行这个activeEffect\n      &#125; finally &#123;\n        effectStack.pop();\n        activeEffect &#x3D; effectStack[effectStack.length - 1];\n      &#125;\n    &#125;\n  &#125;;\n  effect.id &#x3D; uid++;\n  effect.deps &#x3D; []; &#x2F;&#x2F; 表示effect 依赖了那些属性\n  effect.options &#x3D; options;\n  return effect;\n&#125;\nexport function effect(fn, options: any &#x3D; &#123;&#125;) &#123;\n  const effect &#x3D; createReactiveEffect(fn, options);\n  if (!options.lazy) &#123;\n    effect();\n  &#125;\n  return effect;\n&#125;\n\nconst targetMap &#x3D; new WeakMap();\n&#x2F;&#x2F; 属性和effect关联\n&#x2F;&#x2F; &#123;object:&#123;key: [effect]&#125;&#125;\nexport function track(target, key) &#123;\n  if (!activeEffect) return;\n\n  let depsMap &#x3D; targetMap.get(target);\n  if (!depsMap) &#123;\n    targetMap.set(target, (depsMap &#x3D; new Map()));\n  &#125;\n  let dep &#x3D; depsMap.get(key);\n  if (!dep) &#123;\n    depsMap.set(key, (dep &#x3D; new Set()));\n  &#125;\n\n  if (!dep.has(activeEffect)) &#123;\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep); &#x2F;&#x2F; 双向记忆\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 触发更新\nexport function trigger(target, type, key, value?, oldValue?) &#123;\n  const depsMap &#x3D; targetMap.get(target);\n  if (!depsMap) return;\n\n  const run &#x3D; (effects) &#x3D;&gt; &#123;\n    if (effects.options.scheduler) &#123;\n      effects.options.scheduler();\n    &#125; else if (effects) effects.forEach((effect) &#x3D;&gt; effect());\n  &#125;;\n\n  &#x2F;&#x2F; 数组的特殊情况\n  if (key &#x3D;&#x3D;&#x3D; &quot;length&quot; &amp;&amp; isArray(target)) &#123;\n    depsMap.forEach((dep, key) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 如果改的长度小于数组的长度 更新视图\n      if (key &#x3D;&#x3D; &quot;length&quot; || key &gt;&#x3D; value) &#123;\n        run(dep);\n      &#125;\n    &#125;);\n  &#125; else &#123;\n    &#x2F;&#x2F; 对象的处理\n    if (key !&#x3D;&#x3D; void 0) &#123;\n      run(depsMap.get(key));\n    &#125;\n\n    switch (type) &#123;\n      case &quot;add&quot;:\n        if (isArray(target)) &#123;\n          if (isInteger(key)) &#123;\n            run(depsMap.get(&quot;length&quot;));\n            &#x2F;&#x2F; 如果页面中直接使用数组 会对length收集\n            &#x2F;&#x2F; 直接触发length就行\n          &#125;\n        &#125;\n        break;\n    &#125;\n  &#125;\n&#125;\n\n\n\n\ncomputedimport &#123; isFunction &#125; from &quot;..&#x2F;share&#x2F;index&quot;;\n\nimport &#123; effect, trigger, track &#125; from &quot;.&#x2F;effect&quot;;\n\nexport function computed(getterOrOptions) &#123;\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) &#123;\n    getter &#x3D; getterOrOptions;\n    setter &#x3D; () &#x3D;&gt; &#123;&#125;;\n  &#125; else &#123;\n    setter &#x3D; getterOrOptions.set;\n    getter &#x3D; getterOrOptions.get;\n  &#125;\n\n  let dirty &#x3D; true;\n  let computed;\n\n  let runner &#x3D; effect(getter, &#123;\n    lazy: true,\n    computed: true,\n    scheduler: () &#x3D;&gt; &#123;\n      if (!dirty) &#123;\n        dirty &#x3D; true;\n        trigger(computed, &quot;set&quot;, &quot;value&quot;); &#x2F;&#x2F; 更新变化\n      &#125;\n    &#125;,\n  &#125;);\n  let value;\n\n  computed &#x3D; &#123;\n    get value() &#123;\n      value &#x3D; runner();\n      dirty &#x3D; false;\n      track(computed, &quot;value&quot;); &#x2F;&#x2F; 收集\n      return value;\n    &#125;,\n    set value(newVal) &#123;\n      setter(newVal);\n    &#125;,\n  &#125;;\n\n  return computed;\n&#125;\n\n\n\n\nrefimport &#123; hasChange, isArray, isObject &#125; from &quot;..&#x2F;share&#x2F;index&quot;;\nimport &#123; track, trigger &#125; from &quot;.&#x2F;effect&quot;;\nimport &#123; reactive &#125; from &quot;.&#x2F;reactive&quot;;\n\nconst convert &#x3D; (val) &#x3D;&gt; (isObject(val) ? reactive(val) : val);\n\nclass RefImpl &#123;\n  public _value;\n  public _v_isRef &#x3D; true;\n  constructor(public rawValue, public shadow) &#123;\n    this._value &#x3D; shadow ? rawValue : convert(rawValue);\n  &#125;\n  &#x2F;&#x2F; 类的属性访问器\n\n  public get value(): string &#123;\n    track(this, &quot;value&quot;);\n    return this._value;\n  &#125;\n\n  public set value(newValue: string) &#123;\n    if (hasChange(newValue, this.rawValue)) &#123;\n      this.rawValue &#x3D; newValue;\n      this._value &#x3D; this.shadow ? newValue : convert(newValue);\n      trigger(this, &quot;set&quot;, &quot;value&quot;, newValue);\n    &#125;\n  &#125;\n&#125;\nfunction createRef(value, shallow &#x3D; false) &#123;\n  return new RefImpl(value, shallow);\n&#125;\nexport function ref(value) &#123;\n  return createRef(value);\n&#125;\n\nclass ObjectRefImpl &#123;\n  public __v_isRef &#x3D; true;\n  constructor(public target, public key) &#123;&#125;\n\n  public get value(): string &#123;\n    return this.target[this.key];\n  &#125;\n\n  public set value(v: string) &#123;\n    this.target[this.key] &#x3D; v;\n  &#125;\n&#125;\n\nexport function toRef(target, key) &#123;\n  return new ObjectRefImpl(target, key);\n&#125;\n\nexport function toRefs(object) &#123;\n  &#x2F;&#x2F; 数组或者对象\n  const ret &#x3D; isArray(object) ? new Array(object.length) : &#123;&#125;;\n  for (let key in object) &#123;\n    ret[key] &#x3D; toRef(object, key);\n  &#125;\n  return ret;\n&#125;\n\n\n\n\nshareexport const isObject &#x3D; (val: any) &#x3D;&gt;\n  typeof val &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp; typeof val !&#x3D;&#x3D; null;\n\nexport const isSymbol &#x3D; (val: any) &#x3D;&gt; typeof val &#x3D;&#x3D;&#x3D; &quot;string&quot;;\n\nexport const isArray &#x3D; Array.isArray;\n\nexport const isInteger &#x3D; (key) &#x3D;&gt; &quot;&quot; + parseInt(key, 10) &#x3D;&#x3D;&#x3D; key;\nexport const hasOwnProperty &#x3D; Object.prototype.hasOwnProperty;\nexport const hasOwn &#x3D; (val, key) &#x3D;&gt; hasOwnProperty.call(val, key);\n\nexport const hasChange &#x3D; (newVal, oldVal) &#x3D;&gt; newVal !&#x3D;&#x3D; oldVal;\n\nexport const isFunction &#x3D; (val: any) &#x3D;&gt; typeof val &#x3D;&#x3D;&#x3D; &quot;function&quot;;\n\n\n","slug":"vue3响应式原理","date":"2021-05-15T10:50:15.000Z","categories_index":"","tags_index":"","author_index":"麦当"},{"id":"8ff19d3d1f7a02625729a0691839588e","title":"vue+ts案例","content":"main.tsimport &#123; createApp &#125; from &quot;vue&quot;;\nimport App from &quot;.&#x2F;App.vue&quot;;\nimport router from &quot;.&#x2F;router&quot;;\nimport store from &quot;.&#x2F;store&quot;;\nimport Vant from &quot;vant&quot;;\n\nimport &quot;vant&#x2F;lib&#x2F;index.css&quot;;\ncreateApp(App)\n  .use(Vant)\n  .use(store)\n  .use(router)\n  .mount(&quot;#app&quot;);\n\n\n\n\nApp.vue&lt;template&gt;\n  &lt;div class&#x3D;&quot;nav&quot;&gt;\n    &lt;router-view v-slot&#x3D;&quot;&#123; Com &#125;&quot;&gt;\n      &lt;keep-alive&gt;\n        &lt;component :is&#x3D;&quot;Com&quot;&gt;&lt;&#x2F;component&gt;\n      &lt;&#x2F;keep-alive&gt;\n    &lt;&#x2F;router-view&gt;\n    &lt;van-tabbar route&gt;\n      &lt;van-tabbar-item replace to&#x3D;&quot;&#x2F;&quot; icon&#x3D;&quot;home-o&quot;&gt;home&lt;&#x2F;van-tabbar-item&gt;\n      &lt;van-tabbar-item replace to&#x3D;&quot;&#x2F;mime&quot; icon&#x3D;&quot;orders-o&quot;&gt;mime&lt;&#x2F;van-tabbar-item&gt;\n      &lt;van-tabbar-item replace to&#x3D;&quot;&#x2F;profile&quot; icon&#x3D;&quot;manager-o&quot;\n        &gt;profile&lt;&#x2F;van-tabbar-item\n      &gt;\n    &lt;&#x2F;van-tabbar&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n\n\nRouterimport &#123; createRouter, createWebHistory, RouteRecordRaw &#125; from &quot;vue-router&quot;;\nimport Home from &quot;..&#x2F;views&#x2F;Home&#x2F;index.vue&quot;;\n\nconst routes: Array&lt;RouteRecordRaw&gt; &#x3D; [\n  &#123;\n    path: &quot;&#x2F;&quot;,\n    name: &quot;Home&quot;,\n    component: Home,\n  &#125;,\n  &#123;\n    path: &quot;&#x2F;mime&quot;,\n    name: &quot;Mime&quot;,\n    &#x2F;&#x2F; route level code-splitting\n    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route\n    &#x2F;&#x2F; which is lazy-loaded when the route is visited.\n    component: () &#x3D;&gt;\n      import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &quot;..&#x2F;views&#x2F;Mime&#x2F;index.vue&quot;),\n  &#125;,\n  &#123;\n    path: &quot;&#x2F;profile&quot;,\n    name: &quot;Profile&quot;,\n    &#x2F;&#x2F; route level code-splitting\n    &#x2F;&#x2F; this generates a separate chunk (about.[hash].js) for this route\n    &#x2F;&#x2F; which is lazy-loaded when the route is visited.\n    component: () &#x3D;&gt;\n      import(&#x2F;* webpackChunkName: &quot;about&quot; *&#x2F; &quot;..&#x2F;views&#x2F;Profile&#x2F;index.vue&quot;),\n  &#125;,\n];\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHistory(process.env.BASE_URL),\n  routes,\n&#125;);\n\nexport default router;\n\n\n\n\nviewhome&#x2F;&#x2F; index.vue\n\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;home&quot;&gt;\n    &#123;&#123; category &#125;&#125;\n    &lt;!-- 首页头部 --&gt;\n    &lt;HomeHeader\n      :category&#x3D;&quot;category&quot;\n      @setCurrentCategory&#x3D;&quot;setCurrentCategory&quot;\n    &gt;&lt;&#x2F;HomeHeader&gt;\n    &lt;div class&#x3D;&quot;home-container&quot; ref&#x3D;&quot;refreshElm&quot;&gt;\n      &lt;!-- 轮播图 --&gt;\n      &lt;Suspense&gt;\n        &lt;template #default&gt;\n          &lt;HomeSwiper&gt;&lt;&#x2F;HomeSwiper&gt;\n        &lt;&#x2F;template&gt;\n        &lt;template #fallback&gt;\n          &lt;div&gt;loading.....&lt;&#x2F;div&gt;\n        &lt;&#x2F;template&gt;\n      &lt;&#x2F;Suspense&gt;\n      &lt;!-- 课程列表 --&gt;\n      &lt;HomeList :lessonList&#x3D;&quot;lessonList&quot;&gt;&lt;&#x2F;HomeList&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; useLoadMore &#125; from &quot;@&#x2F;hooks&quot;;\nimport &#123; GlobalState &#125; from &quot;@&#x2F;store&quot;;\nimport &#123; Store, useStore &#125; from &quot;vuex&quot;;\nimport &#123; computed, defineComponent, onMounted, ref &#125; from &quot;vue&quot;;\nimport HomeHeader from &quot;.&#x2F;HomeHeader.vue&quot;;\nimport HomeList from &quot;.&#x2F;HomeList.vue&quot;;\nimport HomeSwiper from &quot;.&#x2F;HomeSwiper.vue&quot;;\nimport &#123; CATEGORY_TYPES &#125; from &quot;@&#x2F;typings&#x2F;home&quot;;\nimport * as Types from &quot;..&#x2F;..&#x2F;store&#x2F;actionType&quot;;\n\nfunction useCategory(store: Store&lt;GlobalState&gt;) &#123;\n  let category &#x3D; computed(() &#x3D;&gt; store.state.home.currentCategory);\n  function setCurrentCategory(category: CATEGORY_TYPES) &#123;\n    store.commit(&#96;home&#x2F;$&#123;Types.SET_CATEGORY&#125;&#96;, category);\n  &#125;\n  return &#123;\n    category,\n    setCurrentCategory,\n  &#125;;\n&#125;\n\nfunction useLessonList(store: Store&lt;GlobalState&gt;) &#123;\n  const lessonList &#x3D; computed(() &#x3D;&gt; store.state.home.lessons.list);\n  onMounted(() &#x3D;&gt; &#123;\n    if (lessonList.value.length &#x3D;&#x3D; 0) &#123;\n      store.dispatch(&#96;home&#x2F;$&#123;Types.SET_LESSON_LIST&#125;&#96;);\n    &#125;\n  &#125;);\n\n  return &#123;\n    lessonList,\n  &#125;;\n&#125;\n\nexport default defineComponent(&#123;\n  name: &quot;Home&quot;,\n  components: &#123;\n    HomeHeader,\n    HomeList,\n    HomeSwiper,\n  &#125;,\n  setup() &#123;\n    const store &#x3D; useStore&lt;GlobalState&gt;();\n    &#x2F;&#x2F; 真实的DOM\n    const refreshElm &#x3D; ref&lt;null | HTMLElement&gt;(null);\n    const &#123; isLoading, hasMore &#125; &#x3D; useLoadMore(\n      refreshElm,\n      store,\n      &#96;home&#x2F;$&#123;Types.SET_LESSON_LIST&#125;&#96;\n    );\n    const &#123; category, setCurrentCategory &#125; &#x3D; useCategory(store);\n    const &#123; lessonList &#125; &#x3D; useLessonList(store);\n    return &#123;\n      category,\n      setCurrentCategory,\n      lessonList,\n      refreshElm,\n    &#125;;\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n.home-container &#123;\n  position: absolute;\n  top: 65px;\n  bottom: 50px;\n  width: 100%;\n  overflow-y: scroll;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n&#x2F;&#x2F; HomeHeader.vue\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;home-header&quot;&gt;\n    &lt;img src&#x3D;&quot;@&#x2F;assets&#x2F;logo.png&quot; alt&#x3D;&quot;logo&quot; &#x2F;&gt;\n    &lt;van-dropdown-menu&gt;\n      &lt;van-dropdown-item\n        :modelValue&#x3D;&quot;category&quot;\n        :options&#x3D;&quot;options&quot;\n        @change&#x3D;&quot;change&quot;\n      &#x2F;&gt;\n    &lt;&#x2F;van-dropdown-menu&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; CATEGORY_TYPES &#125; from &quot;@&#x2F;typings&#x2F;home&quot;;\nimport &#123; defineComponent, PropType, reactive, toRefs &#125; from &quot;vue&quot;;\nexport default defineComponent(&#123;\n  name: &quot;HomeHeader&quot;,\n  props: &#123;\n    category: &#123;\n      type: Number as PropType&lt;CATEGORY_TYPES&gt;,\n      required: true,\n    &#125;,\n  &#125;,\n  emits: [&quot;setCurrentCategory&quot;],\n  setup(props, context) &#123;\n    function change(value: CATEGORY_TYPES) &#123;\n      context.emit(&quot;setCurrentCategory&quot;, value);\n    &#125;\n    const state &#x3D; reactive(&#123;\n      options: [\n        &#123; text: &quot;全部课程&quot;, value: CATEGORY_TYPES.ALL &#125;,\n        &#123; text: &quot;REACT&quot;, value: CATEGORY_TYPES.REACT &#125;,\n        &#123; text: &quot;VUE&quot;, value: CATEGORY_TYPES.VUE &#125;,\n        &#123; text: &quot;NODE&quot;, value: CATEGORY_TYPES.NODE &#125;,\n      ],\n    &#125;);\n\n    return &#123; ...toRefs(state), change &#125;;\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot;&gt;\n.home-header &#123;\n  height: 65px;\n  background: #2a2a2a;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0 2.5%;\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 95%;\n  img &#123;\n    height: 50px;\n  &#125;\n  .van-dropdown-menu__title &#123;\n    color: #fff;\n  &#125;\n  .van-dropdown-menu__bar &#123;\n    background: #2a2a2a;\n  &#125;\n&#125;\n&lt;&#x2F;style&gt;\n\n&#x2F;&#x2F; HomeList.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;van-card\n      v-for&#x3D;&quot;l in lessonList&quot;\n      :key&#x3D;&quot;l.id&quot;\n      :price&#x3D;&quot;l.price&quot;\n      :title&#x3D;&quot;l.title&quot;\n      :thumb&#x3D;&quot;l.poster&quot;\n    &gt;\n      &lt;template #tags&gt;\n        &lt;van-tag plain&gt;\n          &#123;&#123; formatCategory(l.category) &#125;&#125;\n        &lt;&#x2F;van-tag&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;van-card&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; defineComponent, PropType &#125; from &quot;vue&quot;;\nimport &#123; ILesson &#125; from &quot;@&#x2F;typings&#x2F;home&quot;;\nexport default defineComponent(&#123;\n  props: &#123;\n    lessonList: &#123;\n      type: Array as PropType&lt;ILesson[]&gt;,\n    &#125;,\n  &#125;,\n  setup() &#123;\n    function formatCategory(type: number) &#123;\n      switch (type) &#123;\n        case 1:\n          return &quot;react&quot;;\n        case 2:\n          return &quot;vue&quot;;\n        case 3:\n          return &quot;node&quot;;\n        default:\n          return &quot;all&quot;;\n      &#125;\n    &#125;\n    return &#123;\n      formatCategory,\n    &#125;;\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n&#x2F;&#x2F; HomeSwiper.vue\n&lt;template&gt;\n  &lt;van-swipe v-if&#x3D;&quot;sliderList.length&quot;&gt;\n    &lt;van-swipe-item v-for&#x3D;&quot;l in sliderList&quot; :key&#x3D;&quot;l.url&quot;&gt;\n      &lt;img :src&#x3D;&quot;l.url&quot; alt&#x3D;&quot;&quot; style&#x3D;&quot;max-width: 100%&quot; &#x2F;&gt;\n    &lt;&#x2F;van-swipe-item&gt;\n  &lt;&#x2F;van-swipe&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; computed, defineComponent &#125; from &quot;vue&quot;;\nimport &#123; GlobalState &#125; from &quot;@&#x2F;store&#x2F;index&quot;;\nimport &#123; useStore &#125; from &quot;vuex&quot;;\nimport * as Types from &quot;@&#x2F;store&#x2F;actionType&quot;;\nexport default defineComponent(&#123;\n  async setup() &#123;\n    const store &#x3D; useStore&lt;GlobalState&gt;();\n    let sliderList &#x3D; computed(() &#x3D;&gt; store.state.home.sliders);\n    if (sliderList.value.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      await store.dispatch(&#96;home&#x2F;$&#123;Types.SET_SLIDER_LIST&#125;&#96;);\n    &#125;\n    return &#123;\n      sliderList,\n    &#125;;\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n\n\n\n\nstoreactionType&#x2F;&#x2F; 分类信息\nexport const SET_CATEGORY &#x3D; &quot;SET_CATEGORY&quot;;\n&#x2F;&#x2F; 轮播图信息\nexport const SET_SLIDER_LIST &#x3D; &quot;SET_SLIDER_LIST&quot;;\n\n&#x2F;&#x2F; 设置课程列表\nexport const SET_LESSON_LIST &#x3D; &quot;SET_LESSON_LIST&quot;;\n&#x2F;&#x2F; 加载状态\nexport const SET_LOADING &#x3D; &quot;SET_LOADING&quot;;\n\n\nindeximport &#123; IHomeState &#125; from &quot;@&#x2F;typings&#x2F;home&quot;;\nimport &#123; createStore &#125; from &quot;vuex&quot;;\nimport home from &quot;.&#x2F;modules&#x2F;home&quot;;\n\nexport interface GlobalState &#123;\n  home: IHomeState;\n&#125;\n\nconst store &#x3D; createStore&lt;GlobalState&gt;(&#123;\n  mutations: &#123;&#125;,\n  actions: &#123;&#125;,\n  modules: &#123;\n    home,\n  &#125;,\n&#125;);\n\nexport default store;\n\n\nmodules&#x2F;&#x2F; home.ts\nimport &#123; getLesson, getSlider &#125; from &quot;@&#x2F;api&#x2F;home&quot;;\nimport &#123; Module &#125; from &quot;vuex&quot;;\nimport &#123; GlobalState &#125; from &quot;..&quot;;\nimport &#123;\n  CATEGORY_TYPES,\n  IHomeState,\n  ILessons,\n  ISlider,\n&#125; from &quot;..&#x2F;..&#x2F;typings&#x2F;home&quot;;\nimport * as Types from &quot;..&#x2F;actionType&quot;;\n\n&#x2F;&#x2F; 首页的数据\n\nconst state: IHomeState &#x3D; &#123;\n  currentCategory: CATEGORY_TYPES.ALL,\n  sliders: [],\n  lessons: &#123;\n    hasMore: true,\n    loading: false,\n    offset: 0,\n    limit: 5,\n    list: [],\n  &#125;,\n&#125;;\n\nconst home: Module&lt;IHomeState, GlobalState&gt; &#x3D; &#123;\n  namespaced: true,\n  state,\n  mutations: &#123;\n    [Types.SET_CATEGORY](state, payload: CATEGORY_TYPES) &#123;\n      state.currentCategory &#x3D; payload;\n    &#125;,\n    [Types.SET_SLIDER_LIST](state, payload: ISlider[]) &#123;\n      state.sliders &#x3D; payload;\n    &#125;,\n    [Types.SET_LOADING](state, payload: boolean) &#123;\n      state.lessons.loading &#x3D; payload;\n    &#125;,\n    [Types.SET_LESSON_LIST](state, payload: ILessons) &#123;\n      state.lessons.list &#x3D; [...state.lessons.list, ...payload.list];\n      state.lessons.hasMore &#x3D; payload.hasMore;\n      state.lessons.offset &#x3D; state.lessons.offset + payload.list.length;\n    &#125;,\n  &#125;,\n  actions: &#123;\n    async [Types.SET_SLIDER_LIST](&#123; commit &#125;) &#123;\n      let sliders &#x3D; await getSlider&lt;ISlider&gt;();\n      commit(Types.SET_SLIDER_LIST, sliders);\n    &#125;,\n    async [Types.SET_LESSON_LIST](&#123; commit &#125;) &#123;\n      if (state.lessons.loading) &#123;\n        return;\n      &#125;\n      if (!state.lessons.hasMore) &#123;\n        return;\n      &#125;\n      commit(Types.SET_LOADING, true);\n      const lessons &#x3D; await getLesson&lt;ILessons&gt;(\n        state.currentCategory,\n        state.lessons.offset,\n        state.lessons.limit\n      );\n\n      commit(Types.SET_LESSON_LIST, lessons);\n      commit(Types.SET_LOADING, false);\n    &#125;,\n  &#125;,\n&#125;;\n\nexport default home;\n\n\n\n\n## api\n\n### index.ts\n\n&#96;&#96;&#96;javascript\nimport axios, &#123; AxiosRequestConfig, AxiosResponse &#125; from &quot;axios&quot;;\naxios.defaults.baseURL &#x3D; &quot;http:&#x2F;&#x2F;www.fullstackjavascript.cn:3000&quot;;\n\naxios.interceptors.request.use((config: AxiosRequestConfig) &#x3D;&gt; &#123;\n  return config;\n&#125;);\n\naxios.interceptors.response.use(\n  (response: AxiosResponse) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 出错了\n    if (response.data.err &#x3D;&#x3D; 1) &#123;\n      return Promise.reject(response.data.data);\n    &#125;\n    return response.data;\n  &#125;,\n  (err) &#x3D;&gt; &#123;\n    return Promise.reject(err);\n  &#125;\n);\n\nexport default axios;\n\n\nhome.tsimport &#123; CATEGORY_TYPES &#125; from &quot;@&#x2F;typings&#x2F;home&quot;;\nimport axios from &quot;.&quot;;\n\nexport function getSlider&lt;T&gt;() &#123;\n  return axios.get&lt;T, T&gt;(&quot;&#x2F;slider&#x2F;list&quot;);\n&#125;\n\nexport function getLesson&lt;T&gt;(\n  category: CATEGORY_TYPES,\n  offset: number &#x3D; 0,\n  limit: number &#x3D; 5\n) &#123;\n  return axios.get&lt;T, T&gt;(\n    &#96;&#x2F;lesson&#x2F;list?category&#x3D;$&#123;category&#125;&amp;offset&#x3D;$&#123;offset&#125;&amp;limit&#x3D;$&#123;limit&#125;&#96;\n  );\n&#125;\n\n\n\n\nhooksimport &#123; GlobalState &#125; from &quot;@&#x2F;store&quot;;\nimport &#123; Ref &#125; from &quot;@vue&#x2F;reactivity&quot;;\nimport &#123; Store &#125; from &quot;vuex&quot;;\nimport _ from &quot;lodash&quot;;\nimport &#123; computed, onMounted &#125; from &quot;@vue&#x2F;runtime-core&quot;;\n\nexport function useLoadMore(\n  refreshElm: Ref&lt;null | HTMLElement&gt;,\n  store: Store&lt;GlobalState&gt;,\n  type: string\n) &#123;\n  let element: HTMLElement;\n  &#x2F;&#x2F; 防抖\n\n  function _loadMore() &#123;\n    &#x2F;&#x2F; 可视高度\n    let containerHeight &#x3D; element.clientHeight;\n    &#x2F;&#x2F; 卷曲高度\n    let scrollTop &#x3D; element.scrollTop;\n\n    &#x2F;&#x2F; 整个高度\n    let scrollHeight &#x3D; element.scrollHeight;\n\n    if (containerHeight + scrollTop + 20 &gt;&#x3D; scrollHeight) &#123;\n      store.dispatch(type);\n    &#125;\n  &#125;\n  onMounted(() &#x3D;&gt; &#123;\n    element &#x3D; refreshElm.value as HTMLElement;\n    element.addEventListener(&quot;scroll&quot;, _.debounce(_loadMore, 200));\n  &#125;);\n\n  const isLoading &#x3D; computed(() &#x3D;&gt; store.state.home.lessons.loading);\n  const hasMore &#x3D; computed(() &#x3D;&gt; store.state.home.lessons.hasMore);\n  return &#123;\n    isLoading,\n    hasMore,\n  &#125;;\n&#125;\n\n\n\n\ntypingsexport enum CATEGORY_TYPES &#123;\n  ALL,\n  NODE,\n  VUE,\n  REACT,\n&#125;\n\nexport interface ILesson &#123;\n  title: string;\n  video: string;\n  poster: string;\n  price: number;\n  category?: string;\n&#125;\n\nexport interface ILessons &#123;\n  hasMore: boolean;\n  loading: boolean;\n  offset: number;\n  limit: number;\n  list: ILesson[];\n&#125;\n\nexport interface ISlider &#123;\n  url: string;\n&#125;\n\nexport interface IHomeState &#123;\n  currentCategory: CATEGORY_TYPES;\n  sliders: ISlider[];\n  lessons: ILessons;\n&#125;\n\n\n","slug":"vue-ts案例","date":"2021-05-13T12:12:07.000Z","categories_index":"vue","tags_index":"vue,ts","author_index":"麦当"},{"id":"71e26c228348b0d18f5bc168efb57865","title":"vue3 TodoList","content":"App.vue&lt;template&gt;\n  &lt;div class&#x3D;&quot;wrapper&quot;&gt;\n    &lt;TotoInput &#x2F;&gt;\n    &lt;TodoList :todoList&#x3D;&quot;todoList&quot; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; computed, defineComponent, onMounted &#125; from &#39;vue&#39;\nimport &#123; Store, useStore &#125; from &#39;vuex&#39;;\nimport TotoInput from &#39;.&#x2F;components&#x2F;TodoInput&#x2F;index.vue&#39;\nimport TodoList from &#39;.&#x2F;components&#x2F;TodoList&#x2F;index.vue&#39;\nimport &#123; useTodo &#125; from &#39;.&#x2F;hooks&#39;;\n\nexport default defineComponent(&#123;\n  name: &#39;App&#39;,\n  components: &#123;\n    TotoInput,\n    TodoList\n  &#125;,\n  setup() &#123;\n    const &#123; setTodoList &#125; &#x3D; useTodo();\n    const store: Store&lt;any&gt; &#x3D; useStore()\n    onMounted(() &#x3D;&gt; &#123;\n      setTodoList();\n    &#125;)\n    return &#123;\n      todoList: computed(() &#x3D;&gt; store.state.list)\n    &#125;\n  &#125;\n\n&#125;);\n&lt;&#x2F;script&gt;\n\n\n\ncomponents&#x2F;&#x2F; TodoInput&#x2F;index.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;todovalue&quot; @keyup&#x3D;&quot;setTodoValue&quot; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; defineComponent, ref &#125; from &#39;vue&#39;\nimport &#123; useTodo &#125; from &#39;..&#x2F;..&#x2F;hooks&#x2F;index&#39;\nexport default defineComponent(&#123;\n  name: &#39;todoinput&#39;,\n  setup() &#123;\n    const todovalue &#x3D; ref&lt;string&gt;(&#39;&#39;)\n    const &#123; setTodo &#125; &#x3D; useTodo()\n    const setTodoValue &#x3D; (e: KeyboardEvent): void &#x3D;&gt; &#123;\n      if (e.keyCode &#x3D;&#x3D;&#x3D; 13 &amp;&amp; todovalue.value.trim().length) &#123;\n        setTodo(todovalue.value);\n        todovalue.value &#x3D; &#39;&#39;\n      &#125;\n    &#125;\n    return &#123;\n      todovalue,\n      setTodoValue\n    &#125;\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F; TodoItem&#x2F;index.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; :checked&#x3D;&quot;item.status &#x3D;&#x3D;&#x3D; FINISH&quot; @click&#x3D;&quot;setStatus(item.id)&quot; &#x2F;&gt;\n    &lt;span :class&#x3D;&quot;item.status &#x3D;&#x3D;&#x3D; FINISH ? &#39;line-through&#39; : &#39;&#39;&quot;&gt;&#123;&#123; item.content &#125;&#125;&#123;&#123; item.status &#125;&#125;&lt;&#x2F;span&gt;\n    &lt;button @click&#x3D;&quot;removeTodo(item.id)&quot;&gt;删除&lt;&#x2F;button&gt;\n    &lt;button\n      v-if&#x3D;&quot;item.status !&#x3D;&#x3D; FINISH&quot;\n      @click&#x3D;&quot;setDoing(item.id)&quot;\n      :class&#x3D;&quot;item.status &#x3D;&#x3D;&#x3D; DOING ? &#39;doing&#39; : &#39;willdo&#39;&quot;\n    &gt;&#123;&#123; item.status &#x3D;&#x3D;&#x3D; DOING ? &#39;正在做&#39; : &#39;马上做&#39; &#125;&#125;&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; ITodo, TODO_STATUS &#125; from &#39;@&#x2F;types&#39;;\nimport &#123; defineComponent, PropType &#125; from &#39;vue&#39;\n\nexport default defineComponent(&#123;\n  name: &#39;todoitem&#39;,\n  props: &#123;\n    item: &#123;\n      type: Object as PropType&lt;ITodo&gt;,\n      required: true\n    &#125;\n  &#125;,\n  setup(props, &#123; emit &#125;) &#123;\n    const statusState &#x3D; &#123;\n      DOING: TODO_STATUS.DOING,\n      FINISH: TODO_STATUS.FINISH,\n      WILLDO: TODO_STATUS.WILLDO\n    &#125;\n\n    const removeTodo &#x3D; (id: number) &#x3D;&gt; &#123;\n      emit(&#39;removeTodo&#39;, id)\n    &#125;\n    const setDoing &#x3D; (id: number) &#x3D;&gt; &#123;\n      emit(&#39;setDoing&#39;, id)\n\n    &#125;\n    const setStatus &#x3D; (id: number) &#x3D;&gt; &#123;\n      emit(&#39;setStatus&#39;, id)\n\n    &#125;\n\n\n    return &#123;\n      ...statusState,\n      removeTodo,\n      setDoing,\n      setStatus,\n    &#125;\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;\n.line-through &#123;\n  text-decoration: line-through;\n&#125;\n.doing &#123;\n  background-color: #cdcdcd;\n  color: #ccc;\n&#125;\n.willdo &#123;\n  background-color: orange;\n  color: #fff;\n&#125;\n&lt;&#x2F;style&gt;\n&#x2F;&#x2F; TodoList&#x2F;index.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;TodoItem\n      v-for&#x3D;&quot;item of todoList&quot;\n      :key&#x3D;&quot;item.id&quot;\n      :item&#x3D;&quot;item&quot;\n      @removeTodo&#x3D;&quot;removeTodo&quot;\n      @setStatus&#x3D;&quot;setStatus&quot;\n      @setDoing&#x3D;&quot;setDoing&quot;\n    &gt;&lt;&#x2F;TodoItem&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport TodoItem from &#39;..&#x2F;TodoItem&#x2F;index.vue&#39;\nimport &#123; defineComponent, PropType &#125; from &#39;vue&#39;\nimport &#123; ITodo &#125; from &#39;@&#x2F;types&#39;;\nimport &#123; useTodo &#125; from &#39;@&#x2F;hooks&#39;;\nexport default defineComponent(&#123;\n  name: &#39;todolist&#39;,\n  props: &#123;\n    todoList: Array as PropType&lt;ITodo[]&gt;\n  &#125;,\n  components: &#123;\n    TodoItem\n  &#125;,\n  setup() &#123;\n    const &#123; removeTodo, setStatus, setDoing &#125; &#x3D; useTodo();\n    return &#123;\n      removeTodo,\n      setStatus,\n      setDoing\n    &#125;\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n\n\n\nhooksimport &#123;\n  SET_TODO,\n  SET_TODO_LIST,\n  REMOVE_TODO,\n  SET_TODO_STATUS,\n  SET_DOING_STATUS,\n&#125; from &quot;@&#x2F;store&#x2F;actionTypes&quot;;\nimport &#123; ITodo, TODO_STATUS &#125; from &quot;@&#x2F;types&quot;;\nimport &#123; watch &#125; from &quot;@vue&#x2F;runtime-core&quot;;\nimport &#123; Store, useStore &#125; from &quot;vuex&quot;;\n\ninterface IUseTodo &#123;\n  setTodo: (value: string) &#x3D;&gt; void;\n  setTodoList: () &#x3D;&gt; void;\n  removeTodo: (id: number) &#x3D;&gt; void;\n  setStatus: (id: number) &#x3D;&gt; void;\n  setDoing: (id: number) &#x3D;&gt; void;\n&#125;\n\ninterface IUseLocalStorage &#123;\n  getLocalList: () &#x3D;&gt; ITodo[];\n  setLocalList: (todoList: ITodo[]) &#x3D;&gt; void;\n&#125;\nfunction useTodo(): IUseTodo &#123;\n  const store: Store&lt;any&gt; &#x3D; useStore();\n  const &#123; setLocalList, getLocalList &#125; &#x3D; useLocalStorage();\n  const todoList: ITodo[] &#x3D; getLocalList();\n  watch(\n    () &#x3D;&gt; store.state.list,\n    (todoList) &#x3D;&gt; &#123;\n      setLocalList(todoList);\n    &#125;\n  );\n  function setTodo(value: string): void &#123;\n    const todo: ITodo &#x3D; &#123;\n      id: new Date().getTime(),\n      content: value,\n      status: TODO_STATUS.WILLDO,\n    &#125;;\n    store.dispatch(SET_TODO, todo);\n  &#125;\n  function setTodoList() &#123;\n    store.dispatch(SET_TODO_LIST, todoList);\n  &#125;\n  function removeTodo(id: number) &#123;\n    store.dispatch(REMOVE_TODO, id);\n  &#125;\n  function setStatus(id: number) &#123;\n    store.dispatch(SET_TODO_STATUS, id);\n  &#125;\n  function setDoing(id: number) &#123;\n    store.dispatch(SET_DOING_STATUS, id);\n  &#125;\n\n  return &#123;\n    setTodo,\n    setTodoList,\n    removeTodo,\n    setStatus,\n    setDoing,\n  &#125;;\n&#125;\n\nfunction useLocalStorage(): IUseLocalStorage &#123;\n  function getLocalList(): ITodo[] &#123;\n    return JSON.parse(localStorage.getItem(&quot;todoList&quot;) || &quot;[]&quot;);\n  &#125;\n  function setLocalList(todoList: ITodo[]): void &#123;\n    localStorage.setItem(&quot;todoList&quot;, JSON.stringify(todoList));\n  &#125;\n  return &#123;\n    getLocalList,\n    setLocalList,\n  &#125;;\n&#125;\n\nexport &#123; useTodo, useLocalStorage &#125;;\n\n\ntypesinterface ITodo &#123;\n  id: number;\n  content: string;\n  status: TODO_STATUS;\n&#125;\n\nenum TODO_STATUS &#123;\n  WILLDO &#x3D; &quot;willdo&quot;,\n  DOING &#x3D; &quot;doing&quot;,\n  FINISH &#x3D; &quot;finish&quot;,\n&#125;\ninterface IState &#123;\n  list: ITodo[];\n&#125;\n\nexport &#123; ITodo, TODO_STATUS, IState &#125;;\n\n\n\n\nstore&#x2F;&#x2F; index.ts\nimport &#123; createStore &#125; from &quot;vuex&quot;;\nimport state from &quot;.&#x2F;state&quot;;\nimport mutations from &quot;.&#x2F;mutations&quot;;\nimport actions from &quot;.&#x2F;actions&quot;;\n\nexport default createStore(&#123;\n  state,\n  mutations,\n  actions,\n&#125;);\n&#x2F;&#x2F; state.ts\nimport &#123; IState &#125; from &quot;..&#x2F;types&#x2F;index&quot;;\nexport default &lt;IState&gt;&#123;\n  list: [],\n&#125;;\n\n&#x2F;&#x2F; action.ts\nimport &#123; IState, ITodo &#125; from &quot;@&#x2F;types&quot;;\nimport &#123; Commit &#125; from &quot;vuex&quot;;\nimport &#123;\n  SET_TODO,\n  SET_TODO_LIST,\n  REMOVE_TODO,\n  SET_TODO_STATUS,\n  SET_DOING_STATUS,\n&#125; from &quot;.&#x2F;actionTypes&quot;;\n\ninterface ICtx &#123;\n  commit: Commit;\n  state: IState;\n&#125;\n\nexport default &#123;\n  [SET_TODO](&#123; commit &#125;: ICtx, todo: ITodo): void &#123;\n    commit(SET_TODO, todo);\n  &#125;,\n  [SET_TODO_LIST](&#123; commit &#125;: ICtx, todoList: ITodo[]): void &#123;\n    commit(SET_TODO_LIST, todoList);\n  &#125;,\n  [REMOVE_TODO](&#123; commit &#125;: ICtx, id: number): void &#123;\n    commit(REMOVE_TODO, id);\n  &#125;,\n  [SET_TODO_STATUS](&#123; commit &#125;: ICtx, id: number): void &#123;\n    commit(SET_TODO_STATUS, id);\n  &#125;,\n  [SET_DOING_STATUS](&#123; commit &#125;: ICtx, id: number): void &#123;\n    commit(SET_DOING_STATUS, id);\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; actionType.ts\nexport const SET_TODO &#x3D; &quot;SET_TODO&quot;;\nexport const SET_TODO_LIST &#x3D; &quot;SET_TODO_LIST&quot;;\nexport const REMOVE_TODO &#x3D; &quot;REMOVE_TODO&quot;;\nexport const SET_TODO_STATUS &#x3D; &quot;SET_TODO_STATUS&quot;;\nexport const SET_DOING_STATUS &#x3D; &quot;SET_DOING_STATUS&quot;;\n\n&#x2F;&#x2F; mutations.ts\nimport &#123; IState, ITodo, TODO_STATUS &#125; from &quot;@&#x2F;types&quot;;\nimport &#123;\n  SET_TODO,\n  SET_TODO_LIST,\n  REMOVE_TODO,\n  SET_TODO_STATUS,\n  SET_DOING_STATUS,\n&#125; from &quot;.&#x2F;actionTypes&quot;;\nimport state from &quot;.&#x2F;state&quot;;\n\nexport default &#123;\n  [SET_TODO](state: IState, todo: ITodo): void &#123;\n    state.list &#x3D; [todo, ...state.list];\n  &#125;,\n  [SET_TODO_LIST](state: IState, todoList: ITodo[]): void &#123;\n    state.list &#x3D; todoList;\n  &#125;,\n  [REMOVE_TODO](state: IState, id: number) &#123;\n    state.list &#x3D; state.list.filter((item: ITodo) &#x3D;&gt; &#123;\n      return item.id !&#x3D; id;\n    &#125;);\n  &#125;,\n  [SET_TODO_STATUS](status: IState, id: number) &#123;\n    state.list &#x3D; state.list.map((item: ITodo) &#x3D;&gt; &#123;\n      if (item.id &#x3D;&#x3D; id) &#123;\n        switch (item.status) &#123;\n          case TODO_STATUS.FINISH:\n            item.status &#x3D; TODO_STATUS.WILLDO;\n            break;\n          case TODO_STATUS.WILLDO:\n          case TODO_STATUS.DOING:\n            item.status &#x3D; TODO_STATUS.FINISH;\n            break;\n          default:\n            break;\n        &#125;\n      &#125;\n      return item;\n    &#125;);\n  &#125;,\n  [SET_DOING_STATUS](state: IState, id: number) &#123;\n    state.list &#x3D; state.list.map((item) &#x3D;&gt; &#123;\n      if (item.status &#x3D;&#x3D;&#x3D; TODO_STATUS.DOING) &#123;\n        item.status &#x3D; TODO_STATUS.WILLDO;\n      &#125;\n      if (item.id &#x3D;&#x3D; id) &#123;\n        item.status &#x3D; TODO_STATUS.DOING;\n      &#125;\n      return item;\n    &#125;);\n  &#125;,\n&#125;;\n\n\n","slug":"vue3todolist","date":"2021-05-04T10:50:16.000Z","categories_index":"vue","tags_index":"vue","author_index":"麦当"},{"id":"78bf35c97e41da6a2bdad05b63951aa3","title":"函数式编程","content":"函数式编程\n对运算过程的抽象 x –&gt;f(联系,映射)–&gt; y y = f(x)\n用来描述数据之间的映射\n\n&#x2F;&#x2F; 非函数\nlet a &#x3D; 1;\nlet b &#x3D; 2;\nlet sum &#x3D; a + b;\nconsole.log(sum)\n\n&#x2F;&#x2F; 函数式\nfunction(a, b) &#123;\n    return a + b; &#x2F;&#x2F; 运算过程抽象\n&#125;\n\nlet sum &#x3D; add(2,3);\nconsole.log(sum)\n\n函数式第一等公民\n函数可以是变量 参数 返回值\n\n&#x2F;&#x2F; 函数赋值给变量\n\nlet fn &#x3D; function () &#123;\n  console.log(&quot;hello first-class function&quot;);\n&#125;;\n\n高阶函数函数作为参数\nfunction forEach(array, fn) &#123;\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    fn(arr[i]);\n  &#125;\n&#125;\n\nlet arr &#x3D; [1, 2, 3, 4];\nforEach(arr, (item) &#x3D;&gt; &#123;\n  console.log(item);\n&#125;);\n\nfunction filter(arr, fn) &#123;\n  let res &#x3D; [];\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (fn(arr[i])) &#123;\n      res.push(arr[i]);\n    &#125;\n  &#125;\n  return res;\n&#125;\n\n函数作为返回值\nfunction makeFn() &#123;\n  let msg &#x3D; &quot;hello function&quot;;\n  return function () &#123;\n    console.log(msg);\n  &#125;;\n&#125;\n\nmakeFn()();\n\n&#x2F;&#x2F; 让函数只执行一次\nfunction once(fn) &#123;\n  let done &#x3D; false;\n  return function () &#123;\n    if (!done) &#123;\n      return fn.apply(this, arguments);\n    &#125;\n  &#125;;\n&#125;\n\n高阶函数意义\n\n屏蔽细节 只需要关注目标 用来抽象过程\n\n常用的高阶函数&#x2F;&#x2F; map\nconst map &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let res &#x3D; [];\n  for (let value of array) &#123;\n    res.push(fn(value));\n  &#125;\n  return res;\n&#125;;\n\nconst every &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let result &#x3D; true;\n  for (let value of array) &#123;\n    result &#x3D; fn(value);\n    if (!result) break;\n  &#125;\n  return result;\n&#125;;\n\nconst some &#x3D; (arr, fn) &#x3D;&gt; &#123;\n  let result &#x3D; false;\n  for (let value of array) &#123;\n    result &#x3D; fn(value);\n    if (result) break;\n  &#125;\n  return result;\n&#125;;\n\n闭包function fn()&#123;\n    let count &#x3D; 1;\n    return function()&#123;\n        console.log(count);\n        count ++;\n    &#125;\n\n&#125;\n\n纯函数\n相同的输入永远会有相同的输出 同时没有副作用\n\n&#x2F;&#x2F; slice(纯函数) splice(不纯的函数)\n&#x2F;&#x2F; 中间的变量是不可变得 没有记录 无状态的\n\nLodash\nconst _ &#x3D; require(&quot;lodash&quot;);\nconst array &#x3D; [&quot;jack&quot;, &quot;tom&quot;];\n\nconsole.log(_.first(array));\nconsole.log(_last(array));\nconsole.log(_reverse(array));\n_.each(array, (item, index) &#x3D;&gt; &#123;\n  console.log(item, index);\n&#125;);\n\n纯函数缓存\nconst _ &#x3D; require(&quot;lodash&quot;);\n\nfunction getArea(r) &#123;\n  return Math.PI * r * r;\n&#125;\nlet getAreaWithMemory &#x3D; _.memoize(getArea);\n\n&#x2F;&#x2F; 缓存函数实现\n\nfunction memoize(f) &#123;\n  let cache &#x3D; &#123;&#125;;\n  return function () &#123;\n    let key &#x3D; JSON.stringify(arguments);\n    cache[key] &#x3D; cache[key] || f.apply(f, arguments);\n    return cache[key];\n  &#125;;\n&#125;\n\n柯里化函数\nfunction checkAge(age) &#123;\n  let min &#x3D; 19;\n  return age &gt;&#x3D; min;\n&#125;\n\nfunction checkAge(min) &#123;\n  return function (age) &#123;\n    return age &gt;&#x3D; min;\n  &#125;;\n&#125;\n\nconst checkAge &#x3D; (min) &#x3D;&gt; (age) &#x3D;&gt; age &gt;&#x3D; min;\n&#x2F;&#x2F; lodash 中的柯里化\n\nconst _ &#x3D; require(&quot;lodash&quot;);\n\nfunction getSum(a, b, c) &#123;\n  return a + b + c;\n&#125;\n\nconst curried &#x3D; _.curry(getSum);\nconsole.log(curried(1)(2)(3));\n\n&#x2F;&#x2F; 柯里化案例\n\nconst match &#x3D; _.curry((reg, str) &#x3D;&gt; &#123;\n  return str.match(reg);\n&#125;);\n\nconst haveSpace &#x3D; match(&#x2F;\\s+&#x2F;g);\nconst haveNumber &#x3D; match(&#x2F;\\d+&#x2F;g);\n\nconst filter &#x3D; _.curry((func, array) &#x3D;&gt; &#123;\n  return array.filter(func);\n&#125;);\n\nconst findSpace &#x3D; filter(haveSpace);\nconst findNumber &#x3D; filter(haveNumber);\n\n实现函数柯里化\nfunction curry(func) &#123;\n  return function curriedFn(...args) &#123;\n    &#x2F;&#x2F; 判断实参的个数\n    if (args.length &lt; func.length) &#123;\n      return function () &#123;\n        return curriedFn(...args.concat(Array.form(arguments)));\n      &#125;;\n    &#125; else &#123;\n      return func(...args);\n    &#125;\n  &#125;;\n&#125;\n\n函数组合\nfunction compose(f, g) &#123;\n  return function (value) &#123;\n    return f(g(value));\n  &#125;;\n&#125;\n\nfunction reverse(arr) &#123;\n  return arr.reverse();\n&#125;\n\nfunction first(arr) &#123;\n  return arr[0];\n&#125;\n\nconst last &#x3D; compose(first, reverse);\n\n&#x2F;&#x2F; 实现组合函数\n\nfunction compose(...args) &#123;\n  return function(value) &#123;\n    return args.reverse().reduce((acc, fn) &#x3D;&gt; &#123;\n      return fn(acc)\n    &#125;,value)\n  &#125;\n&#125;\n\n\n&#x2F;&#x2F; 函数有结合律\n\n\nfp\n\n函数在前 数据在后\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;);\nfp.split(&#39; &#39;)(&#39;this is a string&#39;)\n\n\n\nPoint Free\n\n不需要指定处理的数据\n只需要合成运算的过程\n只需要定义一些基本的运算函数\n\nconst fp &#x3D; fp.flowRight(fp.join(&#39;-&#39;),fp.map(fp.toLower),fp.split(&#39; &#39;));\nconst f &#x3D; fp.flowRight(fp.replace(&#x2F;\\s+&#x2F;,&#39;_&#39;), fp.toLower);\nconst firstLetterToUpper &#x3D; fp.flowRight(fp.join(&#39;. &#39;),fp.map(fp.flowRight(fp.first,fp.toUpper))fp.split(&#39; &#39;))\n\n\n\n函子(Functor)class Container &#123;\n    constructor(value) &#123;\n        this._value &#x3D; value;\n    &#125;\n    map(fn) &#123;\n        return new Container(fn(this.value))\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 2\n\nclass Container() &#123;\n    static of (value) &#123;\n        return new Container(value)\n    &#125;\n     constructor(value) &#123;\n        this._value &#x3D; value;\n    &#125;\n    map(fn) &#123;\n        return Container.of(fn(this.value))\n    &#125;\n&#125;\n&#x2F;&#x2F; 空值问题\n\n\n\nMaybe函子\n&#x2F;&#x2F; 处理空值异常\nclass MayBe() &#123;\n    static of(value) &#123;\n        return new MayBe(value)\n    &#125;\n    constructor(value) &#123;\n        this._value &#x3D; value;\n    &#125;\n    \n    map(fn) &#123;\n        return this.isNothing(this._value)?\n        \tMayBe.of(null)\n            : MayBe.of(fn(this._value))\n    &#125;\n    isNothing() &#123;\n        return this._value &#x3D;&#x3D;&#x3D; null || this._value &#x3D;&#x3D;&#x3D; undefined\n    &#125;\n&#125;\n&#x2F;&#x2F; 不清楚空值出现的位置\n\nEither函子\nclass Left() &#123;\n    static of(value) &#123;\n        return new Left(value)\n    &#125;\n    constructor(value) &#123;\n        this._value &#x3D; value\n    &#125;\n    map(fn) &#123;\n        return this\n    &#125;\n&#125;\n\nclass Right() &#123;\n    static of(value) &#123;\n        return new Right(value)\n    &#125;\n    constructor(value) &#123;\n        this._value &#x3D; value;\n    &#125;\n    map(fn) &#123;\n        return Right.of(fn(this._value))\n    &#125;\n&#125;\n\nfunction parseJSON(str) &#123;\n    try &#123;\n        return Right.of(JSON.parse(str))\n    &#125; catch(e) &#123;\n        return Left.of(&#123;message:e.message&#125;)\n    &#125;\n&#125;\n\n\nIO函子\n\nIO函子中的_value是一个函数 把函数当成值来处理\nIO函子可以把不纯的动作存储到_value中 延迟执行不纯的操作\n把不纯的操作交给调用者来处理\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\n\nclass IO &#123;\n    static of(x) &#123;\n        return new IO(()&#x3D;&gt; x)\n    &#125;\n    constructor(fn) &#123;\n        this._value &#x3D; fn;\n    &#125;\n    map(fn) &#123;\n    \treturn IO.of(fp.flowRight(fn, this._value))   \n    &#125;\n&#125;\nlet r &#x3D; IO.of(process).map(p&#x3D;&gt;p.execPath)\nconsole.log(r._value())\n\nfolktale\nconst &#123; compose, curry &#125; &#x3D; require(&#39;folktale&#x2F;core&#x2F;lambda&#39;)\n\n&#x2F;&#x2F; task函子 异步任务\nconst fs &#x3D; require(&#39;fs&#39;)\nconst &#123; task &#125; &#x3D; require(&#39;folktale&#x2F;concurrency&#x2F;task&#39;)\nconst &#123; split, find&#125; &#x3D; require(&#39;lodash&#x2F;fp&#39;)\nfunction readFile(filename) &#123;\n    return task(resolver &#x3D;&gt; &#123;\n        fs.readFile(filename, &#39;utf-8&#39;,(err,data)&#x3D;&gt; &#123;\n            if(err) resolver.reject(err)\n            resolver(resolve(data))\n        &#125;)\n    &#125;)\n&#125;\n\nreadFile(&#39;.&#x2F;xxxx&#39;)\n\t.map(fplit(&#39; &#39;))\n\t.map(find(x&#x3D;&gt;x.includes(&#39;version&#39;)))\n\t.run()\n\t.listen((err)&#x3D;&gt;&#123;&#125;, (value)&#x3D;&gt;&#123;&#125;)\n\n&#x2F;&#x2F; 问题\n\nlet readFile &#x3D; function(file)&#123;\n    return new IO(function()&#123;\n        return fs.readFileSync(file,&#39;utf-8&#39;)\n    &#125;)\n&#125;\nlet print &#x3D; function(x)&#123;\n    return new IO(function()&#123;\n        console.log(x);\n        return x\n    &#125;)\n&#125;\nlet cat &#x3D; fp.flowRight(print, readFile)\nlet r &#x3D; cat(&#39;package.json&#39;)._value()._value();\nconsole.log(r)\n\nPointed函子\n&#x2F;&#x2F; 实现了用of创建数据\n\nMonad函子\n\nMonad函子可以是变扁的Pointed函子\n一个函子如果有join何of函子的话就是一个monad函子\n\nconst fp &#x3D; require(&#39;lodash&#x2F;fp&#39;)\nconst fs &#x3D; require(&#39;fs&#39;)\nclass IO &#123;\n    static of(x) &#123;\n        return new IO(()&#x3D;&gt; x)\n    &#125;\n    constructor(fn) &#123;\n        this._value &#x3D; fn;\n    &#125;\n    map(fn) &#123;\n    \treturn IO.of(fp.flowRight(fn, this._value))   \n    &#125;\n    join() &#123;\n        return this._value;\n    &#125;\n    flatMap(fn)&#123;\n        return this.map(fn).join()\n    &#125;\n&#125;\n\nlet r &#x3D; readFile(&#39;xxx&#39;)\n\t.map(x &#x3D;&gt; x.toUpperCase())\n\t.flatMap(print)\n\t.join()\nconsole.log(r);\n\n\n\n","slug":"函数式编程","date":"2021-04-24T03:54:13.000Z","categories_index":"JavaScript","tags_index":"JavaScript,函数式编程","author_index":"麦当"},{"id":"bbd6549d987a6d65496504fcf8d06748","title":"用typescript 增强vuex的类型","content":"index.tsimport &#123; createStore &#125; from &#39;vuex&#39;;\nimport &#123; modules &#125; from &#39;.&#x2F;modules&#39;;\nimport &#123; userState &#125; from &#39;.&#x2F;modules&#x2F;user&#x2F;store&#39;;\ntype State &#x3D; &#123;\n  user: userState,\n&#125;;\n\nconst store &#x3D;\n  createStore &lt;\n  State &gt;\n  &#123;\n    modules,\n  &#125;;\nexport &#123; State &#125;;\nexport default store;\n\nmodules.tsimport user from &#39;.&#x2F;modules&#x2F;user&#39;;\nimport wechat from &#39;.&#x2F;modules&#x2F;wechat&#39;;\nconst modules &#x3D; &#123;\n  user,\n  wechat,\n&#125;;\n\nexport &#123; modules &#125;;\n\nutils.ts&#x2F;&#x2F; &#123;\n&#x2F;&#x2F;     &quot;user&#x2F;isLogin&quot;:number\n&#x2F;&#x2F; &#125;\n&#x2F;**\n * 1.取到每一个 namespace 中的核心的getters\n * 2.user&#x2F;isLogin\n * 3.user.isLogin的returnType取出来\n *&#x2F;\nimport &#123; modules &#125; from &#39;.&#x2F;modules&#39;;\ntype GetGetter&lt;Module&gt; &#x3D; Module extends &#123; getters: infer G &#125; ? G : unknown;\n\ntype GetGetters&lt;Modules&gt; &#x3D; &#123;\n  [K in keyof Modules]: GetGetter&lt;Modules[K]&gt;;\n&#125;;\n\ntype YdGettes &#x3D; GetGetters&lt;typeof modules&gt;;\ntype Addprefix&lt;P, K&gt; &#x3D; &#96;$&#123;P &amp; string&#125;&#x2F;$&#123;K &amp; string&#125;&#96;;\ntype GetSpliceKey&lt;P, Module&gt; &#x3D; Addprefix&lt;P, keyof Module&gt;;\n\ntype GetSpliceKeys&lt;Modules&gt; &#x3D; &#123;\n  [K in keyof Modules]: GetSpliceKey&lt;K, Modules[K]&gt;;\n&#125;[keyof Modules];\n\n&#x2F;&#x2F;  type xx &#x3D; GetSpliceKeys&lt;YdGettes&gt;;\ntype GetFunc&lt;T, A, B&gt; &#x3D; T[A &amp; keyof T][B &amp; keyof T[A &amp; keyof T]];\n\ntype GetSpliceObj&lt;T&gt; &#x3D; &#123;\n  [K in GetSpliceKeys&lt;T&gt;]: K extends &#96;$&#123;infer A&#125;&#x2F;$&#123;infer B&#125;&#96;\n    ? GetFunc&lt;T, A, B&gt;\n    : unknown;\n&#125;;\n\ntype ModuleGeters &#x3D; GetSpliceObj&lt;YdGettes&gt;;\ntype Getters &#x3D; &#123;\n  [K in keyof ModuleGeters]: ReturnType&lt;ModuleGeters[K]&gt;;\n&#125;;\nexport &#123; Getters &#125;;\n\n\n\nmodules/useraction.tsimport &#123; ActionContext &#125; from &#39;vuex&#39;;\nimport &#123; GET_DATA &#125; from &#39;.&#x2F;constant&#39;;\nimport &#123; userState &#125; from &#39;.&#x2F;store&#39;;\n\nexport default &#123;\n  [GET_DATA](&#123; commit &#125;: ActionContext&lt;userState, unknown&gt;): void &#123;\n    console.log(&#39;action执行成功&#39;);\n    setTimeout(() &#x3D;&gt; &#123;\n      const payload &#x3D; false;\n      commit(GET_DATA, payload);\n    &#125;, 2000);\n  &#125;,\n&#125;;\n\nconstant.tsconst GET_DATA &#x3D; &#39;GET_DATA&#39;;\nexport &#123; GET_DATA &#125;;\n\ngetters.tsimport &#123; userState &#125; from &#39;.&#x2F;store&#39;;\n\nconst moduleGetters &#x3D; &#123;\n  isLogin: (state: userState): string &#x3D;&gt; &#123;\n    return &#96;🏮$&#123;state.loading&#125;&#96;;\n  &#125;,\n&#125;;\nexport default moduleGetters;\n\nindex.tsimport &#123; createState &#125; from &#39;.&#x2F;store&#39;;\nimport getters from &#39;.&#x2F;getters&#39;;\nimport mutations from &#39;.&#x2F;mutations&#39;;\nimport actions from &#39;.&#x2F;actions&#39;;\n\nconst state &#x3D; createState();\nexport default &#123;\n  namespaced: true,\n  state,\n  getters,\n  mutations,\n  actions,\n&#125;;\n\nmutations.tsimport &#123; GET_DATA &#125; from &#39;.&#x2F;constant&#39;;\nimport &#123; userState &#125; from &#39;.&#x2F;store&#39;;\n\nconst mutations &#x3D; &#123;\n  [GET_DATA](state: userState, payload: boolean): void &#123;\n    console.log(&#39;mutations执行成功&#39;);\n    state.loading &#x3D; payload;\n  &#125;,\n&#125;;\nexport default mutations;\n\nstore.tsexport const createState &#x3D; () &#x3D;&gt; &#123;\n  const store &#x3D; &#123;\n    loading: true,\n  &#125;;\n  return store;\n&#125;;\n&#x2F;&#x2F;类型推导\nexport type userState &#x3D; ReturnType&lt;typeof createState&gt;;\n\nhooksindex.tsexport &#123; useYdStore &#125; from &#39;.&#x2F;use-store&#39;;\n\nuse-store.tsimport &#123; useStore &#125; from &#39;vuex&#39;;\nimport &#123; State &#125; from &#39;..&#x2F;store&#39;;\nimport &#123; Getters &#125; from &#39;..&#x2F;store&#x2F;utils&#39;;\n\ninterface IUserYdStore &#123;\n  state: State;\n  getters: Getters;\n&#125;\nconst useYdStore &#x3D; (): IUserYdStore &#x3D;&gt; &#123;\n  const &#123; state, getters &#125;: IUserYdStore &#x3D; useStore&lt;State&gt;();\n  return &#123; state, getters &#125;;\n&#125;;\nexport &#123; useYdStore &#125;;\nexport default useYdStore;\n\n","slug":"vue-ts","date":"2021-04-14T02:36:02.000Z","categories_index":"vue","tags_index":"typescript,vuex","author_index":"麦当"},{"id":"d7f18c2655e3f93631b257b366acd0c3","title":"css 好看的案例","content":"渐变\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;h2&gt;Gradient&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;h2&gt;box&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;h2&gt;Shadow&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\nbody &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n  min-height: 100vh;\n&#125;\n.box &#123;\n  position: relative;\n  width: 300px;\n  height: 200px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 0 30px;\n&#125;\n.box::before &#123;\n  content: &#39;&#39;;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  filter: blur(25px);\n  transform: translateY(30px) scale(0.9);\n&#125;\n.box:nth-child(1),\n.box:nth-child(1)::before &#123;\n  background: linear-gradient(135deg, #f403d1, #64b5f6);\n&#125;\n.box:nth-child(2),\n.box:nth-child(2)::before &#123;\n  background: linear-gradient(135deg, #ffec61, #f321d7);\n&#125;\n.box:nth-child(3),\n.box:nth-child(3)::before &#123;\n  background: linear-gradient(135deg, #24ff72, #2196f3);\n&#125;\n.box h2 &#123;\n  position: relative;\n  z-index: 1;\n  color: #fff;\n  font-size: 3em;\n&#125;\n\n伪类\n&lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;div class&#x3D;&quot;ghost&quot;&gt;\n        &lt;div class&#x3D;&quot;ghostEyes&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;ghostDimples&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;ghostFeet&quot;&gt;\n          &lt;div class&#x3D;&quot;ghostFoot&quot;&gt;&lt;&#x2F;div&gt;\n          &lt;div class&#x3D;&quot;ghostFoot&quot;&gt;&lt;&#x2F;div&gt;\n          &lt;div class&#x3D;&quot;ghostFoot&quot;&gt;&lt;&#x2F;div&gt;\n          &lt;div class&#x3D;&quot;ghostFoot&quot;&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;shadow&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n* &#123;\n       &#x2F;* 页面初始化 清除元素的内外边距 *&#x2F;\n       padding: 0;\n       margin: 0;\n     &#125;\n     body &#123;\n       &#x2F;* 弹性布局 让元素在页面中垂直+水平居中 *&#x2F;\n       display: flex;\n       justify-content: center;\n       align-items: center;\n       &#x2F;* 让页面占浏览器可视区域的高度 *&#x2F;\n       height: 100vh;\n       background-color: #00034b;\n     &#125;\n     .container .ghost &#123;\n       &#x2F;* 相对定位 *&#x2F;\n       position: relative;\n       width: 150px;\n       height: 225px;\n       &#x2F;* 圆角属性 左上角和右上角为圆角 *&#x2F;\n       border-radius: 75px 75px 0 0;\n       background-color: #fff;\n       &#x2F;* 盒子阴影 inset是内阴影 啥都不加就是默认的外阴影(outset) *&#x2F;\n       box-shadow: -17px 0 0 #dbdbdb inset, 0 0 50px #5939db;\n       animation: ghost 2s infinite;\n     &#125;\n     &#x2F;* 眼睛 start *&#x2F;\n     .container .ghost .ghostEyes &#123;\n       &#x2F;* 弹性布局 *&#x2F;\n       display: flex;\n       &#x2F;* 让元素平均分配宽度 *&#x2F;\n       justify-content: space-around;\n       width: 90px;\n       padding-top: 70px;\n       margin: 0 auto;\n     &#125;\n     &#x2F;* 利用两个伪元素做出卡姿兰大眼睛 *&#x2F;\n     .container .ghost .ghostEyes::before,\n     .container .ghost .ghostEyes::after &#123;\n       content: &quot;&quot;;\n       width: 15px;\n       height: 25px;\n       border-radius: 50%;\n       background-color: #00034b;\n     &#125;\n     &#x2F;* 眼睛 end *&#x2F;\n\n     &#x2F;* 腮红 start  *&#x2F;\n     &#x2F;* 逻辑跟眼睛一样 *&#x2F;\n     .container .ghost .ghostDimples &#123;\n       display: flex;\n       justify-content: space-around;\n       width: 130px;\n       padding-top: 15px;\n       margin: 0 auto;\n     &#125;\n     .container .ghost .ghostDimples::before,\n     .container .ghost .ghostDimples::after &#123;\n       content: &quot;&quot;;\n       width: 15px;\n       height: 15px;\n       border-radius: 50%;\n       background-color: #ffbeff;\n     &#125;\n     &#x2F;* 腮红 end *&#x2F;\n\n     &#x2F;* 脚 start  *&#x2F;\n     .container .ghost .ghostFeet &#123;\n       &#x2F;* 这个主要是向让四只脚水平排列  *&#x2F;\n       display: flex;\n       &#x2F;* 绝对定位 *&#x2F;\n       position: absolute;\n       bottom: -13px;\n       width: 100%;\n     &#125;\n     .container .ghost .ghostFeet .ghostFoot &#123;\n       width: 25%;\n       height: 26px;\n       border-radius: 50%;\n       background-color: #fff;\n     &#125;\n     &#x2F;* 设置一下最后一个 让它跟身体的内阴影一样 *&#x2F;\n     .container .ghost .ghostFeet .ghostFoot:last-child &#123;\n       &#x2F;* 利用背景渐变色实现 to right 是从做到右 *&#x2F;\n       background-image: linear-gradient(to right, #fff 55%, #dbdbdb 45%);\n     &#125;\n     &#x2F;* 脚 end *&#x2F;\n\n     &#x2F;* 阴影 start *&#x2F;\n     .container .shadow &#123;\n       width: 150px;\n       height: 40px;\n       margin-top: 50px;\n       border-radius: 50%;\n       background-color: #000232;\n       &#x2F;* 动画  名称 时长 infinite是无限次播放 *&#x2F;\n       animation: shadow 2s infinite;\n     &#125;\n     &#x2F;* 阴影 end *&#x2F;\n     &#x2F;* 然后制作漂浮的动画 *&#x2F;\n     @keyframes ghost &#123;\n       0%,\n       100% &#123;\n         transform: translateY(0);\n       &#125;\n       50% &#123;\n         &#x2F;* 2D位移 -15px 是向上走 *&#x2F;\n         transform: translateY(-15px);\n       &#125;\n     &#125;\n     @keyframes shadow &#123;\n       0%,\n       100% &#123;\n         transform: scale(1);\n       &#125;\n       50% &#123;\n         &#x2F;* 缩放 .9比1小一点点 *&#x2F;\n         transform: scale(0.9);\n       &#125;\n     &#125;\n\n\n\n阴影background-image: linear-gradient(\n         to bottom,\n         rgba(0, 0, 0, 0) 0%,\n         rgba(0, 0, 0, 0.009) 11.7%,\n         rgba(0, 0, 0, 0.034) 22.1%,\n         rgba(0, 0, 0, 0.072) 31.2%,\n         rgba(0, 0, 0, 0.123) 39.4%,\n         rgba(0, 0, 0, 0.182) 46.6%,\n         rgba(0, 0, 0, 0.249) 53.1%,\n         rgba(0, 0, 0, 0.32) 58.9%,\n         rgba(0, 0, 0, 0.394) 64.3%,\n         rgba(0, 0, 0, 0.468) 69.3%,\n         rgba(0, 0, 0, 0.54) 74.1%,\n         rgba(0, 0, 0, 0.607) 78.8%,\n         rgba(0, 0, 0, 0.668) 83.6%,\n         rgba(0, 0, 0, 0.721) 88.7%,\n         rgba(0, 0, 0, 0.762) 94.1%,\n         rgba(0, 0, 0, 0.79) 100%\n       );\n       transform: translateY(-50%);\n\n","slug":"cssExample","date":"2021-04-11T10:15:28.048Z","categories_index":"css","tags_index":"css","author_index":"麦当"},{"id":"0d342afe6af4aff548d2b83f7ab3c19b","title":"React哲学","content":"浏览器运行环境js 运行 ---&gt; v8&#x2F;quickJs\n浏览器 js&#x2F;html&#x2F;css &#x3D;&#x3D;&#x3D;&#x3D; 框架\nReact UI框架 ----&gt; 快速响应 配合浏览器的特性开发 不是压榨浏览器性能\n\n环境特点配合框架\n框架有个运行时环境 根据不同的环境生成不同的描述语言 放进不同的容器中\n然后配合生成不同的程序， 配合不同的操作系统\n\n浏览器浏览器进程\n\n网络线程 (dns tcp ip 跨域 mime)\nUI 线程\n文件读写(store)线程\n\n渲染进程\n\n合成线程\n主线程 (js 执行 html 解析 垃圾回收)\ntile work 线程\n\nGPU 进程\n\nGPU 线程 (绘图)\n\n渲染\n资源经过网络线程加载之后 送给合成线程\n一帧进行的操作requestAnimationFrame(上一帧绑定的回调)Parse HTML (DOM 树)Receive Styles （CSSOM）LayoutUI (真正要展示的树 每个节点有相应的属性 宽高 没有层级)Update Layer Tree 层叠上下文 Z 轴(分层)Paint 绘制记录表 (Skia Graphics Library)\n\nComposite (合成阶段)\n光栅化 (切块) CPU(几何数据) ===&gt; GPU(像素点信息结合) 存储\n合成线程返回信息\n{(几何信息): (像素信息 内存地址) 同时标记非快速滚动区域(注册事件)}\n下次渲染 合成线程 (点击的鼠标有位置和非快速滚动区域作比较，不是非快速滚动区域作比较 不需要主线程参与本次更新)\nrequestidleCallback 本真执行(有时间就执行 没时间就延后执行)\nreact &lt; 17 事件绑定在 document 所以每次都会有主线程react &gt; 17 进行了更加细致的事件绑定\n========&gt; 如何让框架更加契合浏览器的特点\n长任务拆分成小任务\n中断\nreact—-&gt; js\n管理数据\njs 协程 (yeild) 任务中断\nrequestAnimitionFrame ===&gt; requestidleCallback\nrect 任务维度 UI\n维护一个数据结构 fiber 类似于 PCB 记录中断的状态\nreact 契合浏览器框架 ====&gt;v8(js 引擎) 可以做跨端应用\nv8 quickjs ====&gt; libuv(事件调度) skia 引擎\nflutter(dart) ====&gt; skia浏览器 js(canvas)====&gt; skia\n用户卡顿 渲染频率 ====&gt; 执行时间少\ndom 长任务 js ====&gt; 可中断 ====&gt; yeild PCB\n长任务：每一帧 dom 的删除和插入操作 遍历dom 的创建 插入 遍历 编程可中断的结构\ndom 树结构 保留结构的关系中断节点和其他节点的关联关系 维护一个 fiber 节点的信息即可\n小任务:\n可以恢复的数据结构（fiber）\nrender ===&gt; 查找多任务调度（优先级调度）=====&gt; schedule 每次最多执行 5ms\nrender(同步)\\setState\\foreUpdate\nfiber 更新 收集所有的任务每次做的小任务 创建本节点的 dom 结构 创建本节点的子 fiber（保留了他们之间的关系）实现了可中断更新\n","slug":"react哲学","date":"2021-04-07T14:08:51.000Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"159e1d8888631750dd50b9032a4b1226","title":"svelte","content":"SvelteVue.min.js\nVue.runtime.js (dom diff 虚拟 dom) 运行时\nReact Vue\n虚拟 dom ---&gt; dom diff\n\n提升性能?\nhtml 输出 domReady 提前\n\n重绘 重排(重新布局)\nFID FP FCP LCP\n\nJQuery 没有响应式\n\nSvelte 相当于 store + 响应式 + JQuery\n\n自己对于 Vue, React, Svelte 的理解现在的框架都是基于响应式的，这样的好处就是我们不要关心对于DOM的操作\n我们只需要注重于数据驱动视图即可。所以Vue, React就是专注于于数据和\n视图。追求的极致就是追求最小的DOM操作，为此诞生出了大名鼎鼎的DOM DIFF\n算法。 通过虚拟DOM 来寻找最小的元素更新。为此出现了一大推的编译，调度\n更新。Svelte并没有虚拟DOM 去直接跟踪最小的元素节点。避免了虚拟DOM的\n大量比对 相当于一个编译器\n\n优点\n编译出来的代码小 状态管理 响应式\nTs Scoped Style\n没有虚拟 dom dom diff\n\n缺点\n组件库 路由 少\n\n","slug":"svelte","date":"2021-04-07T12:07:51.000Z","categories_index":"JavaScript","tags_index":"svelte","author_index":"麦当"},{"id":"e292dba6baac8421f1f811c59a127952","title":"JavaScript基础知识","content":"ArrayBuffer\n特殊的构造函数，可以分配指定大小的字节空间，空间分配之后不在变化 可以用 slice()方法截取部分\n\nconst buf &#x3D; new ArrayBuffer(16); &#x2F;&#x2F; 16字节\nconst buf1 &#x3D; new ArrayBuffer(16);\nbuf1 &#x3D; buf.slice(4, 10);\n\n\n类似于 mallocmalloc 分配失败返回 null ArrayBuffer 抛出错误malloc 可以利用虚拟内存 ArrayBuffer 不超过 Number.MAX_SAFE_InTEGER(2^52 - 1)malloc 不会进行初始化 ArrayBuffer 初始化为 0malloc 自己释放内存 ArrayBuffer 自动释放\n\nDataView(文件 I/O 和网络 I/O )\n必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换。DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置\n\n&#x2F;&#x2F; 默认全部使用\n&#x2F;&#x2F; 写入操作\nconst buf &#x3D; new ArrayBuffer(16);\nalert(fullDataView.buffer &#x3D;&#x3D;&#x3D; buf); &#x2F;&#x2F; true\nconst firstHalfDataView &#x3D; new DataView(buf, 0, 8);\nalert(firstHalfDataView.byteOffset); &#x2F;&#x2F; 0\nalert(firstHalfDataView.byteLength); &#x2F;&#x2F; 8\nconst secondHalfDataView &#x3D; new DataView(buf, 8);\nalert(secondHalfDataView.byteOffset); &#x2F;&#x2F; 8\n\n&#x2F;&#x2F; 读操作\n\nconst buf &#x3D; new ArrayBuffer(2);\nconst view &#x3D; new DataView(buf);\n&#x2F;&#x2F; 说明整个缓冲确实所有二进制位都是 0\n&#x2F;&#x2F; 检查第一个和第二个字符\nalert(view.getInt8(0)); &#x2F;&#x2F; 0\nalert(view.getInt8(1)); &#x2F;&#x2F; 0\n&#x2F;&#x2F; 检查整个缓冲\nalert(view.getInt16(0)); &#x2F;&#x2F; 0\n&#x2F;&#x2F; 将整个缓冲都设置为 1\n&#x2F;&#x2F; 255 的二进制表示是 11111111（2^8 - 1）\nview.setUint8(0, 255);\n&#x2F;&#x2F; DataView 会自动将数据转换为特定的 ElementType\n&#x2F;&#x2F; 255 的十六进制表示是 0xFF\nview.setUint8(1, 0xff);\n&#x2F;&#x2F; 现在，缓冲里都是 1 了\n&#x2F;&#x2F; 如果把它当成二补数的有符号整数，则应该是-1\nalert(view.getInt16(0)); &#x2F;&#x2F; -1\n\n字节序\n大端对齐或者小端对齐\n\nconst buf &#x3D; new ArrayBuffer(2);\nconst view &#x3D; new DataView(buf);\n&#x2F;&#x2F; 填充缓冲，让第一位和最后一位都是 1\nview.setUint8(0, 0x80); &#x2F;&#x2F; 设置最左边的位等于 1\nview.setUint8(1, 0x01); &#x2F;&#x2F; 设置最右边的位等于 1\n\n\n注：DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：\n\n定型数组const ints &#x3D; new Int32Array(buf);\n&#x2F;&#x2F; 方法和普通数组类似\n\nMap &amp;&amp; Object\n内存占用 (但给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对)\n插入性能\n查找速度\n删除性能使用 delete 删除 Object 属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪删除对象属性的操作，包括把属性值设置为 undefined 或 null。但很多时候，这都是一种讨厌的或不适宜的折中。而对大多数浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map\n\nWeakMap\nWeakMap 中的“weak”（弱），描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。键必须是 Object 或者是继承 Object 的类型\n\n弱键\nWeakMap 中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收\n\nconst vm &#x3D; new WeakMap();\nvm.set(&#123;&#125;, &#39;val&#39;);\n&#x2F;&#x2F; 这个对象没有被其他对象引用 执行完之后就会被回收 变成了空映射\n\nconst wm &#x3D; new WeakMap();\nconst container &#x3D; &#123;\n  key: &#123;&#125;,\n&#125;;\nwm.set(container.key, &#39;val&#39;);\nfunction removeReference() &#123;\n  container.key &#x3D; null;\n&#125;\n&#x2F;&#x2F; 一开始不会被回收 保持着对外的引用 执行完removeReference 就会被回收掉\n\nWeakSet\n和 WeakMap 类似\n\n可迭代对象for of数组结构扩展运算符Array.from创建集合创建映射Promise.allPromise.receyield *\n如果对象的原型链上实现了iterable接口 也就可以迭代了\n迭代器协议\n一种一次使用的对象 用 next()方法遍历对象 返回一个 IteratorResult 对象IterattorResult 有 done value 通过判断这个来判断迭代结果迭代器不是快照 如果迭代的过程中发生了变化 迭代器也会反映变化迭代器维护一个引用 迭代器会阻止来垃圾回收\n\n自定义迭代器class Counter &#123;\n  constructor(limit) &#123;\n    this.count &#x3D; 1;\n    this.limit &#x3D; limit;\n  &#125;\n\n  [Symbol.iterator]() &#123;\n    return &#123;\n      next() &#123;\n        if (this.count &lt;&#x3D; this.limit) &#123;\n          return &#123; done: false, value: this.count++ &#125;;\n        &#125; else &#123;\n          return &#123; done: true, value: undefined &#125;;\n        &#125;\n      &#125;,\n\n      return() &#123;\n        &#x2F;&#x2F; 提前退出\n        console.log(&#39;exiting early&#39;);\n        return &#123; done: true &#125;;\n      &#125;,\n    &#125;;\n  &#125;\n&#125;\n\n如果迭代器没有关闭 可以保存状态 继续执行\nlet a &#x3D; [1, 2, 3, 4, 5];\nlet iter &#x3D; a[Symbol.iterator]();\n\nfor (let i of iter) &#123;\n  console.log(i);\n  break;\n&#125;\n\n&#x2F;&#x2F; 1\nfor (let i of iter) &#123;\n  console.log(i);\n&#125;\n&#x2F;&#x2F; 2 3 4 5\n\n生成器function* gen() &#123;&#125;\n&#x2F;&#x2F; 箭头函数不能使用生成器函数\n\nfunction* gen() &#123;&#125;\n\nconst g &#x3D; gen();\n\ng.next(); &#x2F;&#x2F; 返回值类似于一个迭代器\n\ng &#x3D;&#x3D;&#x3D; g[Symbol.iterator]();\n&#x2F;&#x2F;  true\n&#x2F;&#x2F; yeild 会保存当前的作用域 然后执行别的代码 然后返回\n\nfunction* generatorFn() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nfor (let x of generatorFn()) &#123;\n  console.log(x);\n&#125;\n\n&#x2F;&#x2F; 1 2 3\n\nfunction* gen(initial) &#123;\n  &#x2F;&#x2F; console.log(initial);\n  console.log(yield);\n  console.log(yield);\n&#125;\n&#x2F;&#x2F; let g &#x3D; gen(&#39;foo&#39;);\nlet g &#x3D; gen();\ng.next(&#39;bar&#39;);\ng.next(&#39;bar&#39;); &#x2F;&#x2F; bar\ng.next(&#39;bar&#39;); &#x2F;&#x2F; bar\n\nfunction* fn() &#123;\n  return yield &#39;foo&#39;;\n&#125;\n\nlet g &#x3D; fn();\nlet res &#x3D; g.next();\nconsole.log(res);\n\nfunction* gen() &#123;\n  yield* [1, 2, 3];\n&#125;\n\nfunction* gen() &#123;\n  for (const x of [1, 2, 3]) &#123;\n    yield x;\n  &#125;\n&#125;\n\nlet g &#x3D; gen();\n\nfor (let x of gen()) &#123;\n  console.log(x);\n&#125;\n&#x2F;&#x2F; yield 会把可迭代对象序列化为一系列单独产生的值\n","slug":"JavaScript","date":"2021-04-07T08:34:27.488Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"d99453202fb96ed4663408801fbf0008","title":"Vuex 源码分析","content":"vuex 简易实现\n\nlet Vue;\n\nclass ModuleCollection &#123;\n  constructor(options) &#123;\n    this.register([], options);\n  &#125;\n\n  register(path, rootModule) &#123;\n    let module &#x3D; &#123;\n      _rawModule: rootModule,\n      _children: &#123;&#125;,\n      state: rootModule.state,\n    &#125;;\n\n    if (path.length &#x3D;&#x3D; 0) &#123;\n      this.root &#x3D; module;\n    &#125;\n\n    if(rootModule.modules) &#123;\n      for\n    &#125;\n  &#125;\n&#125;\n\nclass Store &#123;\n  constructor(options &#x3D; &#123;&#125;) &#123;\n    &#x2F;&#x2F; 状态赋值\n    this.s &#x3D; new Vue(&#123;\n      data() &#123;\n        return &#123; state: options.state &#125;;\n      &#125;,\n    &#125;);\n    let getters &#x3D; options.getters;\n\n    this.getters &#x3D; &#123;&#125;;\n\n    Object.keys(getters).forEach((getterName) &#x3D;&gt; &#123;\n      Object.defineProperty(this.getters, getterName, &#123;\n        get: () &#x3D;&gt; &#123;\n          return getters[getterName](this.state);\n        &#125;,\n      &#125;);\n    &#125;);\n\n    let mutations &#x3D; options.mutations;\n    this.mutations &#x3D; &#123;&#125;;\n    &#x2F;&#x2F; 发布订阅模式\n    Object.keys(mutations).forEach((mutation) &#x3D;&gt; &#123;\n      this.mutations[mutation] &#x3D; (payload) &#x3D;&gt; &#123;\n        mutations[mutation](this.state, payload);\n      &#125;;\n    &#125;);\n\n    &#x2F;&#x2F; action\n\n    let actions &#x3D; options.actions;\n    this.action &#x3D; &#123;&#125;;\n    Object.keys(actions).forEach((action) &#x3D;&gt; &#123;\n      this.actions[action] &#x3D; (payload, fn) &#x3D;&gt; &#123;\n        fn(this, payload);\n      &#125;;\n    &#125;);\n\n    this._modules &#x3D; new ModuleCollection(); &#x2F;&#x2F; 数据格式化\n  &#125;\n\n  dispatch &#x3D; (actionName, payload) &#x3D;&gt; &#123;\n    this.action[actionName](payload);\n  &#125;;\n  &#x2F;&#x2F;提交更改\n  commit &#x3D; (mutationName, payload) &#x3D;&gt; &#123;\n    this.mutations[mutationName](payload);\n  &#125;;\n\n  get state() &#123;\n    return this.s.state;\n  &#125;\n&#125;\n\nconst install &#x3D; (_Vue) &#x3D;&gt; &#123;\n  Vue &#x3D; _Vue; &#x2F;&#x2F; vue构造函数\n\n  Vue.mixin(&#123;\n    beforeCreate() &#123;\n      &#x2F;&#x2F; 需要拿到store 给每个组件增加了$store属性\n      &#x2F;&#x2F; 可能有很多Vue实例 有的不需要store 没有放在Vue原型上面\n      if (this.$options &amp;&amp; this.$options.store) &#123;\n        &#x2F;&#x2F; 给根实例增加$store属性\n        this.$store &#x3D; this.$options.store;\n      &#125; else &#123;\n        &#x2F;&#x2F; 单独创建的实例\n        this.store &#x3D; this.$parent &amp;&amp; this.$parent.store;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;;\n\nexport default &#123;\n  &#x2F;&#x2F; 默认执行 vue方法\n  install,\n&#125;;\n\n","slug":"vuex","date":"2021-04-06T14:27:28.497Z","categories_index":"vue","tags_index":"vuex,vue","author_index":"麦当"},{"id":"b491bd34f265533799a79211838a0e41","title":"Vue3 响应式原理","content":"简单的实现 Vue3 响应式原理\n\nlet toProxy &#x3D; new WeakMap(); &#x2F;&#x2F; 原对象：代理过得对象\nlet toRaw &#x3D; new WeakMap(); &#x2F;&#x2F; 被代理过得对象: 原对象\nfunction isObject(val) &#123;\n  return typeof val &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; val !&#x3D;&#x3D; null;\n&#125;\n\nfunction reactive(target) &#123;\n  return createReactiveObject(target);\n&#125;\n\nfunction hasOwn(target, key) &#123;\n  return target.hasOwnProperty(key);\n&#125;\n\nlet proxy &#x3D; reactive(&#123; name: &#39;zf&#39; &#125;);\n\nfunction createReactiveObject(target) &#123;\n  if (!isObject(target)) return target;\n\n  &#x2F;&#x2F; 处理多次代理的操作\n  let proxy &#x3D; toProxy.get(target);\n  if (proxy) return proxy;\n  if (toRaw.has(target)) return target;\n  let baseHandler &#x3D; &#123;\n    get(target, key, receiver) &#123;\n      let res &#x3D; Reflect.get(target, key, receiver);\n      &#x2F;&#x2F; 实现多层代理\n\n      track(target, key);\n      return isObject(res) ? reactive(res) : res;\n    &#125;,\n    set(target, key, value, receiver) &#123;\n      let hadKey &#x3D; hasOwn(target, key);\n      let oldValue &#x3D; target[key];\n      let res &#x3D; Reflect.set(target, key, value, receiver);\n      if (!hadKey) &#123;\n        &#x2F;&#x2F; 增加属性\n        trigger(target, &#39;add&#39;, key);\n      &#125; else if (oldValue !&#x3D;&#x3D; value) &#123;\n        &#x2F;&#x2F; 修改属性 屏蔽没有意义的更新\n        trigger(target, &#39;set&#39;, key);\n      &#125;\n      return res;\n    &#125;,\n    deleteProperty(target, key) &#123;\n      let res &#x3D; Reflect.defineProperty(target, key);\n      return res;\n    &#125;,\n  &#125;;\n  let proxy &#x3D; new Proxy(target, baseHandler);\n  toProxy.set(target, proxy);\n  toRaw.set(proxy, target);\n  return proxy;\n&#125;\n\n&#x2F;&#x2F; 依赖收集 发布订阅\n\nlet activeEffectStacks &#x3D; [];\nlet targetsMap &#x3D; new WeakMap();\nfunction track(target, key) &#123;\n  let effect &#x3D; activeEffectStacks[activeEffectStacks.length - 1];\n  if (effect) &#123;\n    let depMap &#x3D; targetsMap.get(target);\n    if (!depMap) &#123;\n      targetsMap.set(target, (depMap &#x3D; new Map()));\n    &#125;\n    let deps &#x3D; depMap.get(key);\n    if (!deps) &#123;\n      depMap, set(key, (deps &#x3D; new Set()));\n    &#125;\n\n    if (!deps.has(effect)) &#123;\n      deps.add(effect);\n    &#125;\n  &#125;\n&#125;\n\nfunction trigger(target, type, key) &#123;\n  let depsMap &#x3D; targetsMap.get(target);\n  if (depsMap) &#123;\n    let deps &#x3D; depsMap.get(key);\n    if (deps) &#123;\n      deps.forEach((effect) &#x3D;&gt; &#123;\n        effect();\n      &#125;);\n    &#125;\n  &#125;\n&#125;\n\nfunction effect(fn) &#123;\n  &#x2F;&#x2F; fn是响应的\n  let effect &#x3D; createReactiveEffect(fn);\n  effect();\n&#125;\n\nfunction createReactiveEffect(fn) &#123;\n  let effect &#x3D; function () &#123;\n    return run(effect, fn);\n  &#125;;\n  return effect;\n&#125;\n\nfunction run(effect, fn) &#123;\n  try &#123;\n    activeEffectStacks.push(effect);\n    fn();\n  &#125; finally &#123;\n    activeEffectStacks.pop();\n  &#125;\n&#125;\n","slug":"vue3-reactive","date":"2021-04-06T14:27:28.471Z","categories_index":"vue","tags_index":"vue3","author_index":"麦当"},{"id":"c6b8115d77691cd594407092998f8ad6","title":"React Hooks 简单用法","content":"Encapsulating data request with hook\n\nimport React, &#123; Fragment, useState, useEffect &#125; from &#39;react&#39;;\nimport axios from &#39;axios&#39;;\n\nfunction App() &#123;\n  const [data, setData] &#x3D; useState(&#123; hits: [] &#125;);\n  const [query, setQuery] &#x3D; useState(&#39;redux&#39;);\n  const [url, setUrl] &#x3D; useState(\n    &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;\n  );\n  const [isLoading, setIsLoading] &#x3D; useState(false);\n  const [isError, setIsError] &#x3D; useState(false);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const fetchData &#x3D; async () &#x3D;&gt; &#123;\n      setIsError(false);\n      setIsLoading(true);\n\n      try &#123;\n        const result &#x3D; await axios(url);\n\n        setData(result.data);\n      &#125; catch (error) &#123;\n        setIsError(true);\n      &#125;\n\n      setIsLoading(false);\n    &#125;;\n\n    fetchData();\n  &#125;, [url]);\n  return (\n    &lt;Fragment&gt;\n      &lt;input\n        type&#x3D;&#39;text&#39;\n        value&#x3D;&#123;query&#125;\n        onChange&#x3D;&#123;(event) &#x3D;&gt; setQuery(event.target.value)&#125;\n      &#x2F;&gt;\n      &lt;button\n        type&#x3D;&#39;button&#39;\n        onClick&#x3D;&#123;() &#x3D;&gt;\n          setUrl(&#96;http:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;$&#123;query&#125;&#96;)\n        &#125;\n      &gt;\n        Search\n      &lt;&#x2F;button&gt;\n\n      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;&#x2F;div&gt;&#125;\n\n      &#123;isLoading ? (\n        &lt;div&gt;Loading ...&lt;&#x2F;div&gt;\n      ) : (\n        &lt;ul&gt;\n          &#123;data.hits.map((item) &#x3D;&gt; (\n            &lt;li key&#x3D;&#123;item.objectID&#125;&gt;\n              &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;\n            &lt;&#x2F;li&gt;\n          ))&#125;\n        &lt;&#x2F;ul&gt;\n      )&#125;\n    &lt;&#x2F;Fragment&gt;\n  );\n&#125;\nexport default App;\n\nCustom hookimport React, &#123; Fragment, useState, useEffect &#125; from &#39;react&#39;;\nimport axios from &#39;axios&#39;;\n\nconst useDataApi &#x3D; (initialUrl, initialData) &#x3D;&gt; &#123;\n  const [data, setData] &#x3D; useState(initialData);\n  const [url, setUrl] &#x3D; useState(initialUrl);\n  const [isLoading, setIsLoading] &#x3D; useState(false);\n  const [isError, setIsError] &#x3D; useState(false);\n\n  useEffect(() &#x3D;&gt; &#123;\n    const fetchData &#x3D; async () &#x3D;&gt; &#123;\n      setIsError(false);\n      setIsLoading(true);\n\n      try &#123;\n        const result &#x3D; await axios(url);\n\n        setData(result.data);\n      &#125; catch (error) &#123;\n        setIsError(true);\n      &#125;\n\n      setIsLoading(false);\n    &#125;;\n\n    fetchData();\n  &#125;, [url]);\n\n  return [&#123; data, isLoading, isError &#125;, setUrl];\n&#125;;\n\nfunction App() &#123;\n  const [query, setQuery] &#x3D; useState(&#39;redux&#39;);\n  const [&#123; data, isLoading, isError &#125;, doFetch] &#x3D; useDataApi(\n    &#39;https:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;redux&#39;,\n    &#123;\n      hits: [],\n    &#125;\n  );\n\n  return (\n    &lt;Fragment&gt;\n      &lt;form\n        onSubmit&#x3D;&#123;(event) &#x3D;&gt; &#123;\n          doFetch(&#96;http:&#x2F;&#x2F;hn.algolia.com&#x2F;api&#x2F;v1&#x2F;search?query&#x3D;$&#123;query&#125;&#96;);\n\n          event.preventDefault();\n        &#125;&#125;\n      &gt;\n        &lt;input\n          type&#x3D;&#39;text&#39;\n          value&#x3D;&#123;query&#125;\n          onChange&#x3D;&#123;(event) &#x3D;&gt; setQuery(event.target.value)&#125;\n        &#x2F;&gt;\n        &lt;button type&#x3D;&#39;submit&#39;&gt;Search&lt;&#x2F;button&gt;\n      &lt;&#x2F;form&gt;\n\n      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;&#x2F;div&gt;&#125;\n\n      &#123;isLoading ? (\n        &lt;div&gt;Loading ...&lt;&#x2F;div&gt;\n      ) : (\n        &lt;ul&gt;\n          &#123;data.hits.map((item) &#x3D;&gt; (\n            &lt;li key&#x3D;&#123;item.objectID&#125;&gt;\n              &lt;a href&#x3D;&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;&#x2F;a&gt;\n            &lt;&#x2F;li&gt;\n          ))&#125;\n        &lt;&#x2F;ul&gt;\n      )&#125;\n    &lt;&#x2F;Fragment&gt;\n  );\n&#125;\n\nexport default App;\n\nuseToggleimport &#123; useCallback, useState &#125; from &#39;react&#39;;\nfunction App() &#123;\n  const [isTextChanged, setIsTextChanged] &#x3D; useToggle();\n  return (\n    &lt;button onClick&#x3D;&#123;setIsTextChanged&#125;&gt;\n      &#123;isTextChanged ? &#39;Toggled&#39; : &#39;Click to Toggle&#39;&#125;\n    &lt;&#x2F;button&gt;\n  );\n&#125;\nconst useToggle &#x3D; (initialState: boolean &#x3D; false): [boolean, any] &#x3D;&gt; &#123;\n  const [state, setState] &#x3D; useState &lt; boolean &gt; initialState;\n  const toggle &#x3D; useCallback((): void &#x3D;&gt; setState((state) &#x3D;&gt; !state), []);\n  return [state, toggle];\n&#125;;\n","slug":"useFetchData","date":"2021-04-06T14:27:28.438Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"ba2efac7316616866db1719079267951","title":"Symbol 基础学习","content":"Symbol 内置符号\nECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道 for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。\n\n\n\nSymbol.asyncIterator\n&#x2F;&#x2F; for-await-of 实现调用\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max &#x3D; max;\n    this.asyncIdx &#x3D; 0;\n  &#125;\n  async *[Symbol.asyncIterator]() &#123;\n    while (this.asyncIdx &lt; this.max) &#123;\n      yield new Promise((resolve) &#x3D;&gt; resolve(this.asyncIdx++));\n    &#125;\n  &#125;\n&#125;\nasync function asyncCount() &#123;\n  let emitter &#x3D; new Emitter(5);\n  for await (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\nasyncCount();\n&#x2F;&#x2F; 0 1 2 3 4\n\nSymbol.hasInstance\n&#x2F;&#x2F; instanceof 调用\n\nSymbol.isConcatSpreadable\n&#x2F;&#x2F; 使用concat的时候会不会被打平\nlet initial &#x3D; [&#39;foo&#39;];\nlet arrayLikeObject &#x3D; &#123; length: 1, 0: &#39;baz&#39; &#125;;\nconsole.log(arrayLikeObject[Symbol.isConcatSpreadable]); &#x2F;&#x2F; undefined\nconsole.log(initial.concat(arrayLikeObject)); &#x2F;&#x2F; [&#39;foo&#39;, &#123;...&#125;]\narrayLikeObject[Symbol.isConcatSpreadable] &#x3D; true;\nconsole.log(initial.concat(arrayLikeObject)); &#x2F;&#x2F; [&#39;foo&#39;, &#39;baz&#39;]\n&#x2F;*\n  [ &#39;foo&#39;, &#123; &#39;0&#39;: &#39;baz&#39;, length: 1 &#125; ]\n  [ &#39;foo&#39;, &#39;baz&#39; ]\n*&#x2F;\n\nSymbol.iterator\nclass Emitter &#123;\n  constructor(max) &#123;\n    this.max &#x3D; max;\n    this.idx &#x3D; 0;\n  &#125;\n  *[Symbol.iterator]() &#123;\n    while (this.idx &lt; this.max) &#123;\n      yield this.idx++;\n    &#125;\n  &#125;\n&#125;\nfunction count() &#123;\n  let emitter &#x3D; new Emitter(5);\n  for (const x of emitter) &#123;\n    console.log(x);\n  &#125;\n&#125;\ncount();\n\nSymbol.match\n&#x2F;&#x2F; String.prototype.match() 调用\n\nSymbol.replaceSymbol.searchSymbol.split\nSymbol.toPrimitiveSymbol.toStringTag\n","slug":"symbol","date":"2021-04-06T14:27:28.412Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"f45f275952c50e73ccfd35d25a4b9c92","title":"redux && redux-middleware","content":"redux\n\nimport &#123; createStore &#125; from &#39;redux&#39;;\nlet INC &#x3D; Symbol.for(&#39;INC&#39;);\nlet DEC &#x3D; Symbol.for(&#39;DEC&#39;);\nlet initialState &#x3D; 0;\nfunction reducer(state &#x3D; initialState, action) &#123;\n  switch (action.type) &#123;\n    case INC:\n      return state + 1;\n    case DEC:\n      return state - 1;\n    default:\n      return state;\n  &#125;\n&#125;\n\n&#x2F;**\n * redux action有要求 有个不是undefined的type类型\n *&#x2F;\nlet store &#x3D; createStore(reducer);\n\nlet state &#x3D; store.getState();\nlet countValue &#x3D; document.getElementById(&#39;counter-value&#39;);\nlet inc &#x3D; document.getElementById(&#39;inc-btn&#39;);\nlet dec &#x3D; document.getElementById(&#39;dec-btn&#39;);\nconsole.log(state);\n\nfunction render() &#123;\n  countValue.innerHTML &#x3D; store.getState();\n&#125;\n\nrender();\n\nstore.subscribe(render);\n\ninc.addEventListener(&#39;click&#39;, function () &#123;\n  store.dispatch(&#123; type: INC &#125;);\n&#125;);\n\ndec.addEventListener(&#39;click&#39;, function () &#123;\n  store.dispatch(&#123; type: DEC &#125;);\n&#125;);\n\ncreate-store.js(版本一)import isPlainObject from &#39;.&#x2F;utils&#x2F;isPlainObject&#39;;\nimport ActionTypes from &#39;.&#x2F;utils&#x2F;actionType&#39;;\nexport default function createStore(reducer, preloadedState) &#123;\n  if (typeof reducer !&#x3D;&#x3D; &#39;function&#39;) &#123;\n    throw new Error(&#39;reducer must be a function&#39;);\n  &#125;\n\n  &#x2F;*******************************&#x2F;\n  &#x2F;** initiallize the base property  *&#x2F;\n  let currentState &#x3D; preloadedState;\n  let currentReducer &#x3D; reducer;\n  let currentListeners &#x3D; [];\n  &#x2F;*******************************&#x2F;\n\n  function getState() &#123;\n    return currentState;\n  &#125;\n\n  function dispatch(action) &#123;\n    if (!isPlainObject(action)) &#123;\n      throw new Error(&#39;action must be a plainObject&#39;);\n    &#125;\n    if (typeof action.type &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n      throw new Error(&#39;action need a type property&#39;);\n    &#125;\n    currentState &#x3D; currentReducer(currentState, action);\n    for (let i &#x3D; 0; i &lt; currentListeners.length; i++) &#123;\n      let listener &#x3D; currentListeners[i];\n      listener();\n    &#125;\n    return action;\n  &#125;\n\n  dispatch(&#123; type: ActionTypes.INIT &#125;);\n  function subScribe(listener) &#123;\n    currentListeners.push(listener);\n    return function unsubScribe() &#123;\n      const index &#x3D; currentListeners.indexOf(listener);\n      currentListeners.splice(index, 1);\n    &#125;;\n  &#125;\n\n  return &#123;\n    getState,\n    subScribe,\n    dispatch,\n  &#125;;\n&#125;\n\nbindActionCreatorfunction bindActionCreator(actionCreator, dispatch) &#123;\n  return function () &#123;\n    return dispatch(actionCreator.apply(this, arguments));\n  &#125;;\n&#125;\n\nfunction bindActionCreators(actionCreators, dispatch) &#123;\n  if (typeof actionCreators &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n    return bindActionCreator(actionCreators, dispatch);\n  &#125;\n  const boundActionCreators &#x3D; &#123;&#125;;\n  for (const key in actionCreators) &#123;\n    boundActionCreators[key] &#x3D; bindActionCreator(actionCreators[key], dispatch);\n  &#125;\n  return boundActionCreators;\n&#125;\n\nexport default bindActionCreators;\n\ncombineReducerexport default function combineReducer(reducers) &#123;\n  const reducerkeys &#x3D; Object.keys(reducers);\n\n  return function (state &#x3D; &#123;&#125;, action) &#123;\n    let nextState &#x3D; &#123;&#125;;\n    for (let i &#x3D; 0; i &lt; reducerkeys.length; i++) &#123;\n      const key &#x3D; reducerkeys[i];\n      const reducer &#x3D; reducers[key];\n      const previousStateForKey &#x3D; state[key];\n      const nextStateForkey &#x3D; reducer(previousStateForKey, action);\n      nextState[key] &#x3D; nextStateForkey;\n    &#125;\n\n    return nextState;\n  &#125;;\n&#125;\n\nutilexport default function isPlainObject(obj) &#123;\n  if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D;&#x3D; null) &#123;\n    return false;\n  &#125;\n\n  let proto &#x3D; obj;\n  while (Object.getPrototypeOf(proto)) &#123;\n    proto &#x3D; Object.getPrototypeOf(proto);\n  &#125;\n\n  return Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; proto;\n&#125;\n\napplyMiddleWarefunction applyMiddleWare(...middlewares) &#123;\n  return function (createStore) &#123;\n    return function (reducer) &#123;\n      let store &#x3D; createStore();\n      let dispath &#x3D; () &#x3D;&gt; &#123;\n        throw new Error();\n      &#125;;\n      let middlewareAPI &#x3D; &#123;\n        getStore: store.getState,\n        dispatch: (...args) &#x3D;&gt; dispath(...args),\n      &#125;;\n      &#x2F;&#x2F; middleware &#x3D; middleware(store);\n      &#x2F;&#x2F; dispath &#x3D; middleware(store.dispatch);\n\n      const chain &#x3D; middlewares.map((middleware) &#x3D;&gt; middleware(middlewareAPI));\n      dispath &#x3D; componse(...chain)(store.dispatch)\n      return &#123;\n        ...store,\n        dispath,\n      &#125;;\n    &#125;;\n  &#125;;\n&#125;\n\ncomposefunction compose(...funcs) &#123;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return (args) &#x3D;&gt; args;\n  &#125;\n  if (funcs.length &#x3D;&#x3D;&#x3D; 1) &#123;\n    return funcs[0];\n  &#125;\n\n  return funcs.reduce((a, b) &#x3D;&gt; (...args) &#x3D;&gt; a(b(...args)));\n&#125;\n\nexport default compose;\n\nreact-reudxindex.jsimport Provider from &#39;.&#x2F;Provider&#39;;\nimport connect from &#39;.&#x2F;connect&#39;;\n\nexport &#123; Provider, connect &#125;;\n\nProvider.jsimport React, &#123; Component &#125; from &#39;react&#39;;\nimport ReduxContext from &#39;.&#x2F;context&#39;;\n\nclass Provider extends Component &#123;\n  render() &#123;\n    return (\n      &lt;ReduxContext.Provider value&#x3D;&#123;this.props.store&#125;&gt;\n        &#123;this.props.children&#125;\n      &lt;&#x2F;ReduxContext.Provider&gt;\n    );\n  &#125;\n&#125;\n\nexport default Provider;\n\nconnect.jsimport React from &#39;react&#39;;\nimport ReduxContext from &#39;.&#x2F;context&#39;;\nimport bindActionCreator from &#39;..&#x2F;redux&#x2F;bindActionCreator&#39;;\nexport default function connect(mapStateToProps, mapDispatchToProps) &#123;\n  return function (WrappedComponent) &#123;\n    return class extends React.Component &#123;\n      static contextType &#x3D; ReduxContext;\n      constructor(props, context) &#123;\n        super(props);\n        &#x2F;** context &#x3D; &#123;store: this.props.store&#125; *&#x2F;\n        this.state &#x3D; mapDispatchToProps(context.store.getState());\n      &#125;\n      componentDidCatch() &#123;\n        this.unsubscribe &#x3D; this.context.store.subscribe(() &#x3D;&gt; &#123;\n          this.setState(mapStateToProps(this.context.store.getState()));\n        &#125;);\n      &#125;\n      componentWillUnmount() &#123;\n        this.unsubscribe();\n      &#125;\n      render() &#123;\n        let action &#x3D; bindActionCreator(\n          mapDispatchToProps,\n          this.context.store.dispatch\n        );\n        return &lt;WrappedComponent &#123;...this.state&#125; &#123;...action&#125; &#x2F;&gt;;\n      &#125;\n    &#125;;\n  &#125;;\n&#125;\n\ncontext.jsimport React from &#39;react&#39;;\n\nconst ReduxContext &#x3D; React.createContext(null);\nexport default ReduxContext;\n\nredux-promisefunction isPromise(obj) &#123;\n  return (\n    !!obj &amp;&amp;\n    (typeof obj &#x3D;&#x3D;&#x3D; &#39;object&#39; || typeof obj &#x3D;&#x3D;&#x3D; &#39;function&#39;) &amp;&amp;\n    typeof obj.then &#x3D;&#x3D;&#x3D; &#39;function&#39;\n  );\n&#125;\nexport default function (&#123; dispatch, getState &#125;) &#123;\n  return (next) &#x3D;&gt; (action) &#x3D;&gt; &#123;\n    return isPromise(action.payload)\n      ? action.payload.then((result) &#x3D;&gt; &#123;\n          dispatch(&#123; ...action, payload: result &#125;);\n        &#125;)\n      : next(action);\n  &#125;;\n&#125;\n\nreudx-thunkfunction createThunkMiddleware() &#123;\n  return (&#123; dispatch, getState &#125; &#x2F;** middlewareAPI *&#x2F;) &#x3D;&gt; (next) &#x3D;&gt; (\n    action\n  ) &#x3D;&gt; &#123;\n    if (typeof action &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n      return action(dispatch, getState);\n    &#125;\n    return next(action);\n  &#125;;\n&#125;\n\n","slug":"redux && redux-middleware","date":"2021-04-06T14:27:28.404Z","categories_index":"React","tags_index":"React,redux,redux-middleware","author_index":"麦当"},{"id":"89dff2a6379feafc73b36875ccf71035","title":"react-setState","content":"react-state 流程\n\nindex.js&#x2F;** 事务 用wrapper包装起来 *&#x2F;\nclass Transaction &#123;\n  constructor(wrappers) &#123;\n    this.wrappers &#x3D; wrappers;\n  &#125;\n  &#x2F;** AOP 编程概念  *&#x2F;\n  perform(anyMethod) &#123;\n    this.wrappers.forEach((wrapper) &#x3D;&gt; wrapper.initialize());\n    anyMethod();\n    this.wrappers.forEach((wrapper) &#x3D;&gt; wrapper.close());\n  &#125;\n&#125;\nlet batchingStrategy &#x3D; &#123;\n  isBatchingStrates: false &#x2F;** 标记是否是批量更新模式 *&#x2F;,\n  dirtyComponent: [] &#x2F;** 脏组件 组件的状态和UI不匹配  *&#x2F;,\n  batchedUpdates() &#123;\n    &#x2F;** 执行所有的更新操作 *&#x2F;\n    this.dirtyComponent.forEach((component) &#x3D;&gt; component.updateComonent());\n  &#125;,\n&#125;;\nclass Updater &#123;\n  constructor(component) &#123;\n    this.component &#x3D; component;\n    this.pendingState &#x3D; [];\n  &#125;\n  addState(partcialState) &#123;\n    this.pendingState.push(partcialState);\n    &#x2F;** 判断是不是批量更新模式 如果是批量更新 将组件放到脏组件里 做到异步更新 *&#x2F;\n    batchingStrategy.isBatchingStrates\n      ? batchingStrategy.dirtyComponent.push(this.component)\n      : this.component.updateComonent();\n  &#125;\n&#125;\nclass Component &#123;\n  constructor(props) &#123;\n    this.props &#x3D; props;\n    this.$updater &#x3D; new Updater(this);\n  &#125;\n  createDOMFromDOMString(domString) &#123;\n    let div &#x3D; document.createElement(&#39;div&#39;);\n    div.innerHTML &#x3D; domString;\n    return div.children[0];\n  &#125;\n  setState(partcialState) &#123;\n    this.$updater.addState(partcialState);\n  &#125;\n\n  &#x2F;** 组件的更新方法 合并所有的状态 然后进行统一的页面元素UI的替换 *&#x2F;\n  updateComonent() &#123;\n    this.$updater.pendingState.forEach((partcialState) &#x3D;&gt;\n      Object.assign(this.setState, partcialState)\n    );\n    this.$updater.pendingState.length &#x3D; 0; &#x2F;** 清空队列 *&#x2F;\n    let oldElemet &#x3D; this.domElement;\n    let newElement &#x3D; this.renderElement();\n    oldElemet.parentElement.replaceChild(newElement, oldElemet);\n  &#125;\n\n  &#x2F;** 创建页面元素 *&#x2F;\n  renderElement() &#123;\n    let htmlString &#x3D; this.render();\n    this.domElement &#x3D; this.createDOMFromDOMString(htmlString);\n    this.domElement.component &#x3D; this;\n    return this.domElement;\n  &#125;\n\n  &#x2F;** 组件的挂载方法  *&#x2F;\n  mount(container) &#123;\n    container.appendChild(this.renderElement());\n  &#125;\n&#125;\n\nlet transaction &#x3D; new Transaction([\n  &#123;\n    initialize() &#123;\n      &#x2F;** 事件开启的时候进入批量更新模式  *&#x2F;\n      batchingStrategy.isBatchingStrates &#x3D; true;\n    &#125;,\n    close() &#123;\n      &#x2F;** 事件结束的时候关闭批量更新模式  *&#x2F;\n      batchingStrategy.isBatchingStrates &#x3D; false;\n      &#x2F;** 脏组件进行状态的更新 *&#x2F;\n      batchingStrategy.batchedUpdates();\n    &#125;,\n  &#125;,\n]);\n\n&#x2F;** 统一的事件处理 挂载到全局  *&#x2F;\nwindow.trigger &#x3D; function (event, mothodName) &#123;\n  &#x2F;** 拿到组件的实例(事件委托) 执行绑定的方法 *&#x2F;\n  let component &#x3D; event.target.component;\n  &#x2F;** wrapper包装起来 处理一些相关的事件 *&#x2F;\n  transaction.perform(component[mothodName].bind(component));\n&#125;;\n\n&#x2F;** 子组件 *&#x2F;\nclass Counter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n  &#125;\n  add() &#123;\n    this.setState(&#123; number: this.state.number + 1 &#125;);\n  &#125;\n\n  render() &#123;\n    return &#96;&lt;button onclick&#x3D;&quot;trigger(event, &#39;add&#39;)&quot;&gt;$&#123;this.state.number&#125;&lt;&#x2F;button&gt;&#96;;\n  &#125;\n&#125;\n\nindex.html&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;count-app&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n  &lt;script src&#x3D;&quot;.&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script&gt;\n    let countApp &#x3D; document.getElementById(&#39;count-app&#39;);\n    let res &#x3D; new Counter().render();\n    res.mount(countApp);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n","slug":"react-setState","date":"2021-04-06T14:27:28.394Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"50552075ed1d1cbaae410e21993db179","title":"react-router-dom","content":"BrowserRouter\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\n\nlet pushState &#x3D; window.history.pushState;\n\nclass HashRouter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      location: &#123; pathname: window.location.pathname, state: null &#125;,\n    &#125;;\n  &#125;\n  componentDidMount() &#123;\n    window.history.pushState &#x3D; (state, title, url) &#x3D;&gt; &#123;\n      pushState.call(window.history, state, title, url);\n      window.onpushstate.call(this, state, url);\n    &#125;;\n    window.onpopstate &#x3D; (event) &#x3D;&gt; &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: window.location.pathname,\n          state: event.state,\n        &#125;,\n      &#125;);\n    &#125;;\n    window.onpushstate &#x3D; (state, pathname) &#x3D;&gt; &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: pathname,\n          state: state,\n        &#125;,\n      &#125;);\n    &#125;;\n  &#125;\n  render() &#123;\n    let that &#x3D; this;\n    let value &#x3D; &#123;\n      location: that.state.location,\n      history: &#123;\n        push(to) &#123;\n          &#x2F;** 阻止跳转 *&#x2F;\n          if (that.block) &#123;\n            let confirm &#x3D; window.confirm(\n              that.block(typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; ? to : &#123; pathname: to &#125;)\n            );\n            if (!confirm) return;\n          &#125;\n          if (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n            let &#123; pathname, state &#125; &#x3D; to;\n            window.history.pushState(state, &#39;&#39;, pathname);\n          &#125; else &#123;\n            window.history.pushState(null, &#39;&#39;, to);\n          &#125;\n        &#125;,\n        block(message) &#123;\n          that.block &#x3D; message;\n        &#125;,\n      &#125;,\n    &#125;;\n    return (\n      &lt;Context.Provider value&#x3D;&#123;value&#125;&gt;&#123;this.props.children&#125;&lt;&#x2F;Context.Provider&gt;\n    );\n  &#125;\n&#125;\n\nexport default HashRouter;\n\ncontext&#x2F;** 暴露出整个库的context上下文  *&#x2F;\nimport React from &#39;react&#39;;\n\nconst Context &#x3D; React.createContext();\n\nexport default Context;\n\nHashRouterimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass HashRouter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      location: &#123; pathname: window.location.hash.slice(1), state: null &#125;,\n    &#125;;\n    this.locationState &#x3D; null;\n  &#125;\n  componentDidMount() &#123;\n    window.location.hash &#x3D; window.location.hash || &#39;&#x2F;&#39;;\n    window.addEventListener(&#39;hashchange&#39;, () &#x3D;&gt; &#123;\n      this.setState(&#123;\n        location: &#123;\n          ...this.state.location,\n          pathname: window.location.hash.slice(1),\n          state: this.locationState,\n        &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  render() &#123;\n    let that &#x3D; this;\n    let value &#x3D; &#123;\n      location: that.state.location,\n      history: &#123;\n        push(to) &#123;\n          &#x2F;** 阻止跳转 *&#x2F;\n          if (that.block) &#123;\n            let confirm &#x3D; window.confirm(\n              that.block(typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; ? to : &#123; pathname: to &#125;)\n            );\n            if (!confirm) return;\n          &#125;\n          if (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n            let &#123; pathname, state &#125; &#x3D; to;\n            that.locationState &#x3D; state;\n            window.location.hash &#x3D; pathname;\n          &#125; else &#123;\n            that.locationState &#x3D; null;\n            window.location.hash &#x3D; to;\n          &#125;\n        &#125;,\n        block(message) &#123;\n          that.block &#x3D; message;\n        &#125;,\n      &#125;,\n    &#125;;\n    return (\n      &lt;Context.Provider value&#x3D;&#123;value&#125;&gt;&#123;this.props.children&#125;&lt;&#x2F;Context.Provider&gt;\n    );\n  &#125;\n&#125;\n\nexport default HashRouter;\n\nLinkimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Link extends Component &#123;\n  static contextType &#x3D; Context;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  render() &#123;\n    &#x2F;** 注意合并上部传来的props *&#x2F;\n    return (\n      &#x2F;&#x2F; eslint-disable-next-line jsx-a11y&#x2F;anchor-is-valid\n      &lt;a\n        &#123;...this.props&#125;\n        onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n          this.props.context.history.push(this.props.to);\n        &#125;&#125;\n      &gt;\n        &#123;this.props.children&#125;\n      &lt;&#x2F;a&gt;\n    );\n  &#125;\n&#125;\n\nexport default Link;\n\n&#x2F;**\n * &lt;a href&#x3D;&#123;&#96;#$&#123;this.props.to&#125;&#96;&#125;&gt;&#123;this.props.children&#125;&lt;&#x2F;a&gt;;\n *&#x2F;\n\nMenuLinkimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Route from &#39;.&#x2F;Route&#39;;\nimport Link from &#39;.&#x2F;Link&#39;;\n&#x2F;**自定义导航 正增加高亮属性 *&#x2F;\n\n&#x2F;** Route渲染内容有三种方法 component render children *&#x2F;\n&#x2F;&#x2F; component render 路径匹配渲染\n&#x2F;&#x2F; children 都会渲染\nfunction MenuLink(&#123; to, exact, children &#125;) &#123;\n  return (\n    &lt;Route\n      path&#x3D;&#123;to&#125;\n      exact&#x3D;&#123;exact&#125;\n      children&#x3D;&#123;(props) &#x3D;&gt; (\n        &lt;li className&#x3D;&#123;props.match ? &#39;active&#39; : &#39;&#39;&#125;&gt;\n          &lt;Link to&#x3D;&#123;to&#125;&gt;&#123;children&#125;&lt;&#x2F;Link&gt;\n        &lt;&#x2F;li&gt;\n      )&#125;\n    &gt;&lt;&#x2F;Route&gt;\n  );\n&#125;\n\nexport default MenuLink;\n\nPromptimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Prompt extends Component &#123;\n  static contextType &#x3D; Context;\n\n  componentWillUnmount() &#123;\n    this.history.block(null);\n  &#125;\n  render() &#123;\n    let history &#x3D; this.context.history;\n    const &#123; when, messaga &#125; &#x3D; this.props;\n    if (when) &#123;\n      history.block(messaga);\n    &#125; else &#123;\n      history.block(null);\n    &#125;\n\n    return null;\n  &#125;\n&#125;\n\nexport default Prompt;\n\nRedirectimport &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Redirect extends Component &#123;\n  static contextType &#x3D; Context;\n  render() &#123;\n    this.context.history.push(this.props.to);\n    return null;\n  &#125;\n&#125;\n\nexport default Redirect;\n\nRouteimport PathToRegexp from &#39;path-to-regexp&#39;;\nimport React, &#123; Component &#125; from &#39;react&#39;;\nimport Context from &#39;.&#x2F;context&#39;;\nclass Route extends Component &#123;\n  static contextType &#x3D; Context;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  render() &#123;\n    let &#123; pathname &#125; &#x3D; this.context.location;\n    let &#123;\n      path &#x3D; &#39;&#x2F;&#39;,\n      component: Component,\n      exact &#x3D; false,\n      render,\n      children,\n    &#125; &#x3D; this.props;\n    let paramNames &#x3D; [];\n    let regxp &#x3D; PathToRegexp(path, paramNames, &#123; end: exact &#125;);\n    let result &#x3D; pathname.match(regxp);\n    let props &#x3D; &#123;\n      location: this.context.location,\n      history: this.props.history,\n    &#125;;\n    if (result) &#123;\n      paramNames &#x3D; paramNames.map((item) &#x3D;&gt; item.name);\n      let [url, ...values] &#x3D; result;\n      let params &#x3D; &#123;&#125;;\n      for (let i &#x3D; 0; i &lt; paramNames.length; i++) &#123;\n        params[paramNames[i]] &#x3D; values[i];\n      &#125;\n      props.match &#x3D; &#123; params, path, url, isExect: url &#x3D;&#x3D;&#x3D; pathname &#125;;\n      if (Component) &#123;\n        return &lt;Component &#123;...props&#125; &#x2F;&gt;;\n      &#125; else if (render) &#123;\n        &#x2F;** 检查属性 兼容性 *&#x2F;\n        return render(props);\n      &#125; else if (children) &#123;\n        return children(props);\n      &#125; else &#123;\n        return null;\n      &#125;\n    &#125; else &#123;\n      if (children) return children(props);\n      else return null;\n    &#125;\n  &#125;\n&#125;\n\nexport default Route;\n\nSwitchimport &#123; Component &#125; from &#39;react&#39;;\nimport PathToRegexp from &#39;path-to-regexp&#39;;\nclass Switch extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  render() &#123;\n    let &#123; pathname &#125; &#x3D; this.context.location;\n    let children &#x3D; Array.isArray(this.props.children)\n      ? this.props\n      : [this.props.children];\n    for (let i &#x3D; 0; i &lt; children.length; i++) &#123;\n      let child &#x3D; children[i];\n      let &#123; path &#x3D; &#39;&#x2F;&#39;, exect &#x3D; false &#125; &#x3D; child.props;\n      let pathNames &#x3D; [];\n      let reg &#x3D; PathToRegexp(path, pathNames, &#123; end: exect &#125;);\n      let result &#x3D; pathname.match(reg);\n      if (result) &#123;\n        return child; &#x2F;** react的元素 React.createElement *&#x2F;\n      &#125;\n    &#125;\n    return null;\n  &#125;\n&#125;\n\nexport default Switch;\n\nWithRouterimport React from &#39;react&#39;;\nimport Route from &#39;.&#x2F;Route&#39;;\n\n&#x2F;&#x2F; eslint-disable-next-line import&#x2F;no-anonymous-default-export\nexport default function (WrappedComponent) &#123;\n  return (props) &#x3D;&gt; &lt;Route component&#x3D;&#123;WrappedComponent&#125; &#x2F;&gt;;\n&#125;\n","slug":"react-router-dom","date":"2021-04-06T14:27:28.383Z","categories_index":"React","tags_index":"React,react-router-dom","author_index":"麦当"},{"id":"fa08fd35cb36d755ed7492a61cf66138","title":"react Hooks","content":"useState\n\n每次渲染都是一个独立的闭包\n每次渲染都会有自己的 props 和 state\n每次渲染后会有自己的时间处理函数\n\nfunction Counter() &#123;\n  let [num, setNum] &#x3D; useState(0);\n  function alertNum() &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      alert(num);\n    &#125;, 3000);\n  &#125;\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setNum&#125;&gt;&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;alertNum&#125;&gt;alert&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nfunction Counter() &#123;\n  let [num, setNum] &#x3D; useState(0);\n  function lazy()&#123;\n    setTimeout((\n      &#x2F;&#x2F; 有差别\n -     setNum(num + 1);\n -     setNum(num &#x3D;&gt; num + 1);\n    )&#x3D;&gt;&#123;&#125;, 3000)\n  &#125;\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setNum&#125;&gt;&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;lazy&#125;&gt;lazy&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n惰性初始化\nfunction Counter(props) &#123;\n  let [counter, setCounter] &#x3D; useState(function () &#123;\n    return &#123; num: props.num &#125;;\n  &#125;);\n  return (\n    &lt;div&gt;\n      &lt;p&gt;&#123;counter.num&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCounter&#125;&gt;&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nefect每次我们重新渲染 都会生成新的 effect 替换之前的 effect 属于渲染结果的一部分 effect 属于特定的渲染\n","slug":"react-hook","date":"2021-04-06T14:27:28.370Z","categories_index":"React","tags_index":"React,react hook","author_index":"麦当"},{"id":"b9a37f021de474295d3010955ace362e","title":"react base","content":"生命周期(老版)\n\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\n\nclass LifeCycle extends Component &#123;\n  &#x2F;**组件的静态属性 *&#x2F;\n  static defaultProps &#x3D; &#123; name: &#39;计数器&#39; &#125;;\n  constructor(props) &#123;\n    &#x2F;** setup props and state *&#x2F;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n    console.log(&#39;setup&#39;);\n  &#125;\n  componentWillMount() &#123;\n    console.log(&#39;2 组件将要挂载&#39;);\n  &#125;\n  componentDidMount() &#123;\n    console.log(&#39;4.组件挂载完成&#39;);\n  &#125;\n  shouldComponentUpdate() &#123;\n    console.log(&#39;5. 询问组件是否要更新&#39;);\n    return true;\n  &#125;\n  componentWillUpdate() &#123;\n    console.log(&#39;6 组件将要更新&#39;);\n  &#125;\n  componentDidUpdate() &#123;\n    console.log(&#39;7 组件已经更新完毕&#39;);\n  &#125;\n  add &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      number: this.state.number + 1,\n    &#125;);\n  &#125;;\n  render() &#123;\n    console.log(&#39;parent render&#39;);\n    return (\n      &lt;div&gt;\n        &lt;p&gt;&#123;this.state.name&#125;&lt;&#x2F;p&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;+&lt;&#x2F;button&gt;\n        &lt;Sub &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default LifeCycle;\n\nclass Sub extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; age: 10 &#125;;\n  &#125;\n  componentWillReceiveProps() &#123;\n    console.log(&#39;componentWillReceiveProps&#39;);\n  &#125;\n  render() &#123;\n    console.log(&#39;children render&#39;);\n    return (\n      &lt;div&gt;\n        &lt;p&gt;age:&#123;this.state.age&#125;&lt;&#x2F;p&gt;\n        &lt;button\n          onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n            this.setState(&#123; age: this.state.age + 1 &#125;);\n          &#125;&#125;\n        &gt;&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n生命周期新版\ngetDerivedStateFromPropsimport React, &#123; Component &#125; from &#39;react&#39;;\nclass Counter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n  &#125;\n  add &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      number: this.state.number + 1,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;p&gt;&#123;this.state.number&#125;&lt;&#x2F;p&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;+&lt;&#x2F;button&gt;\n        &lt;SubCounter number&#x3D;&#123;this.state.number&#125; &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass SubCounter extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; number: 0 &#125;;\n  &#125;\n  &#x2F;** 将State和Props传来的值全部整合到state上 *&#x2F;\n  static getDerivedStateFromProps(nextProps, prevState) &#123;\n    if (nextProps.number % 2 &#x3D;&#x3D;&#x3D; 0) &#123;\n      return &#123; number: nextProps.number * 2 &#125;;\n    &#125; else &#123;\n      return &#123; number: nextProps.number * 3 &#125;;\n    &#125;\n  &#125;\n  render() &#123;\n    return &lt;div&gt;&#123;this.state.number&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default Counter;\n\ngetSnapshotBeforeUpdateimport React, &#123; Component &#125; from &#39;react&#39;;\nclass getSnapshotBeforeUpdateComponent extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.wrapper &#x3D; React.createRef();\n    this.state &#x3D; &#123; message: [&#39;5&#39;, &#39;4&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;] &#125;;\n  &#125;\n\n  componentDidMount() &#123;\n    setInterval(() &#x3D;&gt; &#123;\n      this.setState(&#123;\n        message: [this.state.message.length, ...this.state.message],\n      &#125;);\n    &#125;, 1000);\n  &#125;\n\n  getSnapshotBeforeUpdate() &#123;\n    return this.wrapper.current.scrollHeight;\n  &#125;\n  componentDidUpdate(prevProps, prevState, scrollHeight) &#123;\n    let Dom &#x3D; this.wrapper.current;\n    Dom.scrollTop &#x3D; Dom.scrollTop + (Dom.scrollHeight - scrollHeight);\n  &#125;\n  render() &#123;\n    let style &#x3D; &#123;\n      height: &#39;100p&#39;,\n      width: &#39;200px&#39;,\n      border: &#39;1px solid red&#39;,\n      overflow: &#39;auto&#39;,\n    &#125;;\n    return (\n      &lt;div style&#x3D;&#123;style&#125; ref&#x3D;&#123;this.wrapper&#125;&gt;\n        &lt;ul&gt;\n          &#123;this.state.message.map((item, index) &#x3D;&gt; &#123;\n            return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;;\n          &#125;)&#125;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default getSnapshotBeforeUpdateComponent;\n\ncontext(上下文)旧版import React, &#123; Component &#125; from &#39;react&#39;;\nimport propTypes from &#39;prop-types&#39;;\nclass Page extends Component &#123;\n  static childContextTypes &#x3D; &#123;\n    color: propTypes.string,\n    setColor: propTypes.func,\n  &#125;;\n  getChildContext() &#123;\n    return &#123; color: &#39;gray&#39;, setColor: this.setColor &#125;;\n  &#125;\n\n  setColor &#x3D; (color) &#x3D;&gt; &#123;\n    this.setColor(&#123; color &#125;);\n  &#125;;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123; color: &#39;gray&#39; &#125;;\n  &#125;\n  render() &#123;\n    return (\n      &lt;&gt;\n        &lt;Header&gt;\n          &lt;Title&gt;&lt;&#x2F;Title&gt;\n        &lt;&#x2F;Header&gt;\n        &lt;Main&gt;\n          &lt;Content&gt;&lt;&#x2F;Content&gt;\n        &lt;&#x2F;Main&gt;\n      &lt;&#x2F;&gt;\n    );\n  &#125;\n&#125;\n\nclass Header extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Header\n        &lt;Title&gt;&lt;&#x2F;Title&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass Title extends Component &#123;\n  &#x2F;** 子集关系 *&#x2F;\n  static contextTypes &#x3D; &#123;\n    color: propTypes.string,\n    setColor: propTypes.func,\n  &#125;;\n  &#x2F;**\n   * this.context.color\n   * this.context.setColor\n   *&#x2F;\n\n  render() &#123;\n    return &lt;div&gt;Title&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nclass Main extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Main\n        &lt;Content&gt;&lt;&#x2F;Content&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass Content extends Component &#123;\n  render() &#123;\n    return &lt;div&gt;Content&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default Page;\n\n新版&#x2F;&#x2F; import &#123; func &#125; from &#39;prop-types&#39;;\nimport React, &#123; Component &#125; from &#39;react&#39;;\n&#x2F;&#x2F; import propTypes from &#39;prop-types&#39;;\nconst ThemeContext &#x3D; React.createContext();\n&#x2F;**\n * ThemeContext &#x3D; &#123;Provider Consumer&#125;\n *\n *&#x2F;\n\n&#x2F;**-------- createContext -----------------------------------*&#x2F;\n\nfunction createContext() &#123;\n  class Provider extends Component &#123;\n    static value;\n    constructor(props) &#123;\n      super(props);\n      Provider.value &#x3D; props.value;\n    &#125;\n    render() &#123;\n      return this.props.children;\n    &#125;\n  &#125;\n\n  class Consumer extends Component &#123;\n    render() &#123;\n      return this.props.children(Provider.value);\n    &#125;\n  &#125;\n\n  return &#123; Provider, Consumer &#125;;\n&#125;\n\n&#x2F;**----------------------------------------------------------- *&#x2F;\n\nclass Page extends Component &#123;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123; color: &#39;gray&#39; &#125;;\n  &#125;\n  setColor(color) &#123;\n    this.setState(&#123; color &#125;);\n  &#125;\n  render() &#123;\n    let ctx &#x3D; &#123; color: &#39;gray&#39;, setColor: this.setColor &#125;;\n    return (\n      &lt;ThemeContext.Provider value&#x3D;&#123;ctx&#125;&gt;\n        &lt;Header&gt;\n          &lt;Title&gt;&lt;&#x2F;Title&gt;\n        &lt;&#x2F;Header&gt;\n        &lt;Main&gt;\n          &lt;Content&gt;&lt;&#x2F;Content&gt;\n        &lt;&#x2F;Main&gt;\n      &lt;&#x2F;ThemeContext.Provider&gt;\n    );\n  &#125;\n&#125;\n\nclass Header extends Component &#123;\n  &#x2F;**----------------------------------------------- *&#x2F;\n  static contextType &#x3D; ThemeContext;\n  &#x2F;**----------------------------------------------- *&#x2F;\n\n  &#x2F;**\n   * this.context 拿到了所有的值\n   *&#x2F;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Header\n        &lt;Title&gt;&lt;&#x2F;Title&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nfunction Title(props) &#123;\n  return &lt;div&gt;title&lt;&#x2F;div&gt;;\n&#125;\n\nclass Main extends Component &#123;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        Main\n        &lt;Content&gt;&lt;&#x2F;Content&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nclass Content extends Component &#123;\n  render() &#123;\n    return &lt;div&gt;Content&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default Page;\n\npureComponentimport React, &#123; PureComponent &#125; from &#39;react&#39;;\n\nclass Title extends PureComponent &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.title&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nclass Counter extends PureComponent &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.number&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nexport default class App extends PureComponent &#123;\n  constructor(props) &#123;\n    super(props);\n    this.props &#x3D; props;\n    this.state &#x3D; &#123; title: &#39;计数器&#39;, number: 0 &#125;;\n    this.inputRef &#x3D; React.createRef();\n  &#125;\n  add &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      number: this.state.number + parseInt(this.inputRef.current.value),\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;Title title&#x3D;&#123;this.state.title&#125; &#x2F;&gt;\n        &lt;Counter number&#x3D;&#123;this.state.number&#125; &#x2F;&gt;\n        &lt;input ref&#x3D;&#123;inputRef&#125; &#x2F;&gt;\n        &lt;button onClick&#x3D;&#123;this.add&#125;&gt;+&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\n\nexport default class PureComponent extends Component &#123;\n  isPureComponent &#x3D; true;\n  shouldComponentUpdate(nextProps, nextState) &#123;\n    return (\n      !shallowEqual(this.props, nextProps) ||\n      !shallowEqual(this.state, nextState)\n    );\n  &#125;\n  render() &#123;\n    return &lt;div&gt;1&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nfunction shallowEqual(obj1, obj2) &#123;\n  if (obj1 &#x3D;&#x3D;&#x3D; obj2) return true;\n  if (\n    typeof obj1 !&#x3D;&#x3D; &#39;object&#39; ||\n    obj1 &#x3D;&#x3D;&#x3D; null ||\n    typeof obj2 !&#x3D;&#x3D; &#39;object&#39; ||\n    obj2 &#x3D;&#x3D;&#x3D; null\n  ) &#123;\n    return false;\n  &#125;\n\n  let keys1 &#x3D; Object.keys(obj1);\n  let keys2 &#x3D; Object.keys(obj2);\n  if (keys1.length !&#x3D;&#x3D; keys2.length) return false;\n\n  for (let key of keys1) &#123;\n    if (!obj2.hasOwnProperty(key)) &#123;\n      if (obj1[key] !&#x3D;&#x3D; obj2[key]) &#123;\n        if (typeof obj1[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof obj2[key] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;\n          return shallowEqual(obj1[key], obj2[key]);\n        &#125;\n      &#125; else &#123;\n        return false;\n      &#125;\n    &#125;\n  &#125;\n  return true;\n&#125;\n\nmemoimport React, &#123; PureComponent &#125; from &#39;react&#39;;\n\nfunction memo(FunComponent) &#123;\n  return class Proxy extends PureComponent &#123;\n    render() &#123;\n      return FunComponent(this.props)\n    &#125;\n  &#125;;\n&#125;\nexport default memo;\n\n\n高阶组件&#x2F;**\n * 高阶函数 传入一个函数 返回一个新的函数\n * 高阶组件 传入一个组件 返回一个新的组件\n *&#x2F;\n\nimport React from &#39;react&#39;;\nexport default function withLogger(Comp) &#123;\n  return class extends React.Component &#123;\n    componentWillMount() &#123;\n      this.start &#x3D; Date.now();\n    &#125;\n    componentDidMount() &#123;\n      console.log(Date.now() - this.start + &#39;ms&#39;);\n    &#125;\n\n    render() &#123;\n      return &lt;Comp &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n&#125;\n\n\nrender props&lt;MouseTracker&gt;\n\t&#123;\n        (props)&#x3D;&gt;&lt;Pirture &#123;...props&#125;&#x2F;&gt;\n    &#125;\n&lt;&#x2F;MouseTracker&gt;\n\n\nimport React, &#123; Component &#125; from &#39;react&#39;;\nclass MouseTracker extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; x: 0, y: 0 &#125;;\n  &#125;\n  handleMouseMove &#x3D; (event) &#x3D;&gt; &#123;\n    this.setState(&#123;\n      x: event.clientX,\n      y: event.clientY,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div onMouseOver&#x3D;&#123;this.handleMouseMove&#125;&gt;\n            &#x2F;* 执行子组件 函数组件*&#x2F;\n        &#123;this.props.children(&#123; x: this.state.x, y: this.state.y &#125;)&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default MouseTracker;\n\n\nFrament&lt;React.Fragment&gt;\n\nprotalimport React, &#123; Component &#125; from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nclass Modal extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.modal &#x3D; document.getElementById(&#39;modal-root&#39;);\n  &#125;\n  render() &#123;\n    return ReactDOM.createPortal(this.props.children, this.modal);\n  &#125;\n&#125;\n\nclass Page extends Component &#123;\n  constructor(prop) &#123;\n    super(prop);\n    this.state &#x3D; &#123; show: false &#125;;\n  &#125;\n  toggleModal &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      show: !this.state.show,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;button onClick&#x3D;&#123;this.toggleModal&#125;&gt;关闭&#x2F;显示&lt;&#x2F;button&gt;\n        &#123;this.state.show &amp;&amp; (\n          &lt;Modal&gt;\n            &lt;div id&#x3D;&#39;modal&#39; className&#x3D;&#39;modal&#39;&gt;\n              &lt;div id&#x3D;&#39;content&#39; className&#x3D;&#39;content&#39;&gt;\n                Modal\n              &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n          &lt;&#x2F;Modal&gt;\n        )&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default Page;\n\n错误边界import React, &#123; Component &#125; from &#39;react&#39;;\nclass ErrorBoundary extends Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123; hasErrors: false &#125;;\n  &#125;\n  &#x2F;* 捕获异常 检查错误*&#x2F;\n  componentDidCatch(err, info) &#123;\n    if (err) &#123;\n      this.setState(&#123;\n        hasErrors: true,\n      &#125;);\n    &#125;\n  &#125;\n  render() &#123;\n    if (this.state.hasErrors) &#123;\n      return &lt;div&gt; error&lt;&#x2F;div&gt;;\n    &#125; else &#123;\n      return this.props.children;\n    &#125;\n  &#125;\n&#125;\n\nclass Clock extends Component &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;Date.now()&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\nclass page extends Component &#123;\n  render() &#123;\n    return (\n      &lt;ErrorBoundary&gt;\n        &lt;Clock &#x2F;&gt;\n      &lt;&#x2F;ErrorBoundary&gt;\n    );\n  &#125;\n&#125;\n\nexport default page;\n","slug":"react-base","date":"2021-04-06T14:27:28.342Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"764ea20144bdcb36de34ee7af78c0567","title":"proxy 基础学习","content":"代理基础什么是代理\n代理是目标对象的抽象，类似于 c++的指针，可以用作目标的替身，又独立目标之外。\n\n\nconst target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(proxy.id);\n\n&#x2F;&#x2F; proxy的prototype是undefined\n\n定义捕获器\nconst target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;handler override&#39;;\n  &#125;,\n&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(proxy.id);\n&#x2F;&#x2F; 只有代理才会产生捕获 原来的目标没有这样的行为\n\n反射 API\nconst target &#x3D; &#123;\n  id: &#39;target&#39;,\n&#125;;\n\nconst handler &#x3D; &#123;\n  get() &#123;\n    console.log(&#39;get handler&#39;);\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;;\n\nconst proxy &#x3D; new Proxy(target, handler);\n\nconsole.log(&#39;----------&#39;, proxy.id);\n\n捕获器不变式\nconst target &#x3D; &#123;&#125;;\nObject.defineProperty(target, &#39;foo&#39;, &#123;\n  configurable: false,\n  writable: false,\n  value: &#39;bar&#39;,\n&#125;);\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;qux&#39;;\n  &#125;,\n&#125;;\nconst proxy &#x3D; new Proxy(target, handler);\nconsole.log(proxy.foo);\n\n撤销代理\nconst target &#x3D; &#123;\n  foo: &#39;bar&#39;,\n&#125;;\nconst handler &#x3D; &#123;\n  get() &#123;\n    return &#39;intercepted&#39;;\n  &#125;,\n&#125;;\nconst &#123; proxy, revoke &#125; &#x3D; Proxy.revocable(target, handler);\nconsole.log(proxy.foo); &#x2F;&#x2F; intercepted\nconsole.log(target.foo); &#x2F;&#x2F; bar\nrevoke();\nconsole.log(proxy.foo); &#x2F;&#x2F; TypeError\n\n**实用反射 API **\n&#x2F;&#x2F; 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功\nconst o &#x3D; &#123;&#125;;\ntry &#123;\n  Object.defineProperty(o, &#39;foo&#39;, &#39;bar&#39;);\n  console.log(&#39;success&#39;);\n&#125; catch (e) &#123;\n  console.log(&#39;failure&#39;);\n&#125;\n&#x2F;&#x2F; 使用代理之后\n&#x2F;&#x2F; 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。\n&#x2F;&#x2F; 因此使用这个反射方法可以这样重构上面的代码：\n&#x2F;&#x2F; 重构后的代码\nconst o &#x3D; &#123;&#125;;\nif (Reflect.defineProperty(o, &#39;foo&#39;, &#123; value: &#39;bar&#39; &#125;)) &#123;\n  console.log(&#39;success&#39;);\n&#125; else &#123;\n  console.log(&#39;failure&#39;);\n&#125;\n\n其他的状态标记反射 API\nReflect.defineProperty();\nReflect.preventExtensions();\nReflect.setPrototypeOf();\nReflect.set();\nReflect.deleteProperty();\n\n用一等函数替代操作符\n以下反射方法提供只有通过操作符才能完成的操作。\nReflect.get()：可以替代对象属性访问操作符。\nReflect.set()：可以替代=赋值操作符。\nReflect.has()：可以替代 in 操作符或 with()。\nReflect.deleteProperty()：可以替代 delete 操作符。\nReflect.construct()：可以替代 new 操作符。\n代理的问题\nconst wm &#x3D; new WeakMap();\n\nclass User &#123;\n\n constructor(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n set id(userId) &#123;\n\n \twm.set(this, userId);\n\n &#125;\n\n get id() &#123;\n\n \treturn wm.get(this);\n\n &#125;\n\n&#125;\n\n由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：\n\nconst user &#x3D; new User(123);\n\nconsole.log(user.id); &#x2F;&#x2F; 123\n\nconst userInstanceProxy &#x3D; new Proxy(user, &#123;&#125;);\n\nconsole.log(userInstanceProxy.id); &#x2F;&#x2F; undefined\n\n&#x2F;&#x2F; 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实\n\n&#x2F;&#x2F; 例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代\n\n&#x2F;&#x2F; 理的实例就会以代理实例作为 WeakMap 的键了：\n\nconst UserClassProxy &#x3D; new Proxy(User, &#123;&#125;);\n\nconst proxyUser &#x3D; new UserClassProxy(456);\n\nconsole.log(proxyUser.id);  &#x2F;&#x2F;\n\n代理与内部槽位\n&#x2F;*\n代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可\n能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。\n一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的\n内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通\n的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：\n*&#x2F;\nconst target &#x3D; new Date();\nconst proxy &#x3D; new Proxy(target, &#123;&#125;);\nconsole.log(proxy instanceof Date); &#x2F;&#x2F; true\nproxy.getDate(); &#x2F;&#x2F; TypeError: &#39;this&#39; is not a Date object\n\n代理捕获器get()\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  get(target, property, receiver) &#123;\n    console.log(&#39;get()&#39;);\n    return Reflect.get(...arguments);\n  &#125;,\n&#125;);\nproxy.foo;\n\n拦截的操作\n\nproxy.property\nproxy[property]\nObject.create(proxy)[property]\nReflect.get(proxy, property, receiver)\n\nset\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  set(target, property, value, receiver) &#123;\n    console.log(&#39;set()&#39;);\n    return Reflect.set(...arguments);\n  &#125;,\n&#125;);\nproxy.foo &#x3D; &#39;bar&#39;;\n&#x2F;&#x2F; 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。\n\n拦截的操作\n\nproxy.property = value\nproxy[property] = value\nObject.create(proxy)[property] = value\nReflect.set(proxy, property, value, receiver)\n\nhas\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  has(target, property) &#123;\n    console.log(&#39;has()&#39;);\n    return Reflect.has(...arguments);\n  &#125;,\n&#125;);\n&#39;foo&#39; in proxy;\n&#x2F;&#x2F; has()\n\n\nproperty in proxy\nproperty in Object.create(proxy)\nwith(proxy) {(property);}\nReflect.has(proxy, property)\n\ndefineProperty()\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  defineProperty(target, property, descriptor) &#123;\n    console.log(&#39;defineProperty()&#39;);\n    return Reflect.defineProperty(...arguments);\n  &#125;,\n&#125;);\nObject.defineProperty(proxy, &#39;foo&#39;, &#123; value: &#39;bar&#39; &#125;);\n&#x2F;&#x2F; Object.defineProperty(proxy, property, descriptor)\n&#x2F;&#x2F; Reflect.defineProperty(proxy, property, descriptor)\n\ngetOwnPropertyDescriptor\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  getOwnPropertyDescriptor(target, property) &#123;\n    console.log(&#39;getOwnPropertyDescriptor()&#39;);\n    return Reflect.getOwnPropertyDescriptor(...arguments);\n  &#125;,\n&#125;);\nObject.getOwnPropertyDescriptor(proxy, &#39;foo&#39;);\n&#x2F;&#x2F; getOwnPropertyDescriptor()\n\n&#x2F;&#x2F; Object.getOwnPropertyDescriptor(proxy, property)\n&#x2F;&#x2F; Reflect.getOwnPropertyDescriptor(proxy, property)\n\ndeleteProperty\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  deleteProperty(target, property) &#123;\n    console.log(&#39;deleteProperty()&#39;);\n    return Reflect.deleteProperty(...arguments);\n  &#125;,\n&#125;);\ndelete proxy.foo;\n&#x2F;&#x2F; deleteProperty()\n&#x2F;*\n    delete proxy.property\n    delete proxy[property]\n    Reflect.deleteProperty(proxy, property)\n*&#x2F;\n\nownKeys\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  ownKeys(target) &#123;\n    console.log(&#39;ownKeys()&#39;);\n    return Reflect.ownKeys(...arguments);\n  &#125;,\n&#125;);\nObject.keys(proxy);\n&#x2F;&#x2F; ownKeys()\n&#x2F;*\n    Object.getOwnPropertyNames(proxy)\n    Object.getOwnPropertySymbols(proxy)\n    Object.keys(proxy)\n    Reflect.ownKeys(proxy)\n*&#x2F;\n\ngetPrototypeOf\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  getPrototypeOf(target) &#123;\n    console.log(&#39;getPrototypeOf()&#39;);\n    return Reflect.getPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.getPrototypeOf(proxy);\n&#x2F;&#x2F; getPrototypeOf()\n\n&#x2F;*\n    Object.getPrototypeOf(proxy)\n    Reflect.getPrototypeOf(proxy)\n    proxy.__proto__\n    Object.prototype.isProt\n*&#x2F;\n\nsetPrototypeOf\nconst myTarget &#x3D; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  setPrototypeOf(target, prototype) &#123;\n    console.log(&#39;setPrototypeOf()&#39;);\n    return Reflect.setPrototypeOf(...arguments);\n  &#125;,\n&#125;);\nObject.setPrototypeOf(proxy, Object);\n&#x2F;&#x2F; setPrototypeOf()\n\n&#x2F;*\n    Object.setPrototypeOf(proxy)\n    Reflect.setPrototypeOf(proxy)\n*&#x2F;\n\nisExtensible\npreventExtensions\napply\nconst myTarget &#x3D; () &#x3D;&gt; &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  apply(target, thisArg, ...argumentsList) &#123;\n    console.log(&#39;apply()&#39;);\n    return Reflect.apply(...arguments);\n  &#125;,\n&#125;);\nproxy();\n&#x2F;*\n    proxy(...argumentsList)\n    Function.prototype.apply(thisArg, argumentsList)\n    Function.prototype.call(thisArg, ...argumentsList)\n    Reflect.apply(target, thisArgument, argumentsList)\n*&#x2F;\n\nconstruct\nconst myTarget &#x3D; function () &#123;&#125;;\nconst proxy &#x3D; new Proxy(myTarget, &#123;\n  construct(target, argumentsList, newTarget) &#123;\n    console.log(&#39;construct()&#39;);\n    return Reflect.construct(...arguments);\n  &#125;,\n&#125;);\nnew proxy();\n&#x2F;&#x2F; construct()\n&#x2F;*\n    new proxy(...argumentsList)\n    Reflect.construct(target, argumentsList, newTarget)\n*&#x2F;\n","slug":"proxy","date":"2021-04-06T14:27:28.313Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"3a1de7864b72f88f991d2ad903723f46","title":"connected-react-router","content":"index.js\n\nimport routerMiddlware from &#39;.&#x2F;routerMiddlware&#39;;\nimport connectRouter from &#39;.&#x2F;connectRouter&#39;;\nimport push from &#39;.&#x2F;push&#39;;\nimport ConnectedRouter from &#39;.&#x2F;ConnectedRouter&#39;;\nexport &#123; routerMiddlware, connectRouter, push, ConnectedRouter &#125;;\n\n\n\nconstantsexport const CALL_HISTORY_METHOD &#x3D; &#39;@@router&#x2F;CALL_HISTORY_METHOD&#39;;\nexport const LOCATION_CHANGE &#x3D; &#39;@@router&#x2F;LOCATION_CHANGE&#39;;\n\nConnectedRouter.jsimport React, &#123; Component &#125; from &#39;react&#39;;\nimport &#123; ReactReduxContext &#125; from &#39;react-redux&#39;;\nimport &#123; Route &#125; from &#39;react-router&#39;;\nimport &#123; LOCATION_CHANGE &#125; from &#39;.&#x2F;constants&#39;;\nclass ConnectedRouter extends Component &#123;\n  static contextType &#x3D; ReactReduxContext;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;&#125;;\n  &#125;\n  componentDidMount() &#123;\n    &#x2F;&#x2F; location 新的路径\n    &#x2F;&#x2F; action 新的动作 POP PUSH\n    this.unlistener &#x3D; this.props.history.listen((location, action) &#x3D;&gt; &#123;\n      this.context.store.dispatch(&#123;\n        type: LOCATION_CHANGE,\n        payload: &#123; location, action &#125;,\n      &#125;);\n    &#125;);\n  &#125;\n  componentWillUnmount() &#123;\n    this.unlistener();\n  &#125;\n  render() &#123;\n    let &#123; history, children &#125; &#x3D; this.props;\n    return &lt;Route history&#x3D;&#123;history&#125;&gt;&#123;children&#125;&lt;&#x2F;Route&gt;;\n  &#125;\n&#125;\n\nexport default ConnectedRouter;\n\nconnectRouter.jsimport &#123; LOCATION_CHANGE &#125; from &#39;.&#x2F;constants&#39;;\n&#x2F;&#x2F; eslint-disable-next-line import&#x2F;no-anonymous-default-export\nexport default function (history) &#123;\n  let initialState &#x3D; &#123; action: history.action, location: history.location &#125;;\n  return function (state &#x3D; initialState, action) &#123;\n    switch (action.type) &#123;\n      case LOCATION_CHANGE:\n        return action.payload;\n      default:\n        return state;\n    &#125;\n  &#125;;\n&#125;\n\npushimport &#123; CALL_HISTORY_METHOD &#125; from &#39;.&#x2F;constants&#39;;\nfunction push(path) &#123;\n  return &#123;\n    type: CALL_HISTORY_METHOD,\n    payload: &#123;\n      method: &#39;push&#39;,\n      path,\n    &#125;,\n  &#125;;\n&#125;\n\nexport default push;\n\nrouterMiddleware.jsimport &#123; CALL_HISTORY_METHOD &#125; from &#39;.&#x2F;constants&#39;;\n&#x2F;&#x2F; eslint-disable-next-line import&#x2F;no-anonymous-default-export\nexport default function (history) &#123;\n  return (&#123; dispatch, getState &#125;) &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; &#123;\n    if (action.type &#x3D;&#x3D;&#x3D; CALL_HISTORY_METHOD) &#123;\n      let &#123; method, path &#125; &#x3D; action.payload;\n      history[method](path);\n    &#125; else &#123;\n      next();\n    &#125;\n  &#125;;\n&#125;\n","slug":"connected-react-router","date":"2021-04-06T14:27:28.294Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"46450d7ba5c2c45a066c1b2bc4af0876","title":"leetcode学习记录","content":"\n我是一个算法的菜鸟，在面试的时候经常被算法绊倒在门槛。这篇文章就是记录自己刷 leetcode 的过程，记下来自己对每个问题的理解和想法，把好的想法记录下来，希望读者有帮助。希望自己可以坚持下去，一天写一道题，保持自己对算法的敏感度，保持思考。一起加油！！！\n\n前 100 题题解地址链接\n134 加油站分析\n\n\n枚举每个站点 然后尝试从这个站点走n次, 如果可以顺利走了n 次的话 就是可以绕一周，就是题解，如果如果中途不可以继续走下去了，那个 i-j 中的子集部分也不可能走下去了。时间复杂度:O(n)空间复杂度:O(1)\n\n题解&#x2F;**\n * @param &#123;number[]&#125; gas\n * @param &#123;number[]&#125; cost\n * @return &#123;number&#125;\n *&#x2F;\nvar canCompleteCircuit &#x3D; function (gas, cost) &#123;\n  let n &#x3D; gas.length;\n\n  let i, j;\n  for (i &#x3D; 0; i &lt; n; ) &#123;\n    let left &#x3D; 0;\n\n    for (j &#x3D; 0; j &lt; n; j++) &#123;\n      let k &#x3D; (i + j) % n;\n      left &#x3D; left + gas[k] - cost[k];\n      if (left &lt; 0) break;\n    &#125;\n\n    if (j &#x3D;&#x3D; n) return i;\n    else i +&#x3D; j + 1;\n  &#125;\n  return -1;\n&#125;;\n\n135 分发糖果分析\nf[i]表示每个孩子分到的糖果，ans = f[0] +f[1] +….+ f[n]。每个孩子最少分到 1 个糖果。把小朋友的积分想象成一个台阶，只要是你的台阶数别两边的高，你的糖果数目必须最大一遍多一个才能保证最少。而且最少的只有一个。\n\n题解&#x2F;**\n * @param &#123;number[]&#125; ratings\n * @return &#123;number&#125;\n *&#x2F;\nvar candy &#x3D; function (ratings) &#123;\n  let n &#x3D; ratings.length;\n  let f &#x3D; new Array(n).fill(-1);\n  let w &#x3D; ratings;\n  let ans &#x3D; 0;\n\n  for (let x &#x3D; 0; x &lt; n; x++) &#123;\n    ans +&#x3D; dp(x);\n  &#125;\n\n  return ans;\n\n  function dp(i) &#123;\n    if (f[i] !&#x3D;&#x3D; -1) return f[i]; &#x2F;&#x2F; 分过了糖果不需要再分\n\n    f[i] &#x3D; 1;\n    if (i &amp;&amp; w[i - 1] &lt; w[i]) f[i] &#x3D; Math.max(f[i], dp(i - 1) + 1);\n    if (i + 1 &lt; n &amp;&amp; w[i + 1] &lt; w[i]) f[i] &#x3D; Math.max(f[i], dp(i + 1) + 1);\n\n    return f[i];\n  &#125;\n&#125;;\n\n136 只出现一次的数字分析\n主要是运用了位操作的异或运算 a^a^b = a^b^a = b\n\n题解&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  for (let i &#x3D; 1; i &lt; nums.length; i++) &#123;\n    nums[0] ^&#x3D; nums[i];\n  &#125;\n  return nums[0];\n&#125;;\n\n137 只出现一次的数字 II分析\n用数组计数的方法使用位运算的操作 位运算 并行运算DFA 思路\n\n题解 1&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  let res &#x3D; &#123;&#125;;\n\n  nums.reduce((obj, key) &#x3D;&gt; &#123;\n    return obj[key]++ || (obj[key] &#x3D; 1), obj;\n  &#125;, res);\n\n  for (let key in res) &#123;\n    if (res[key] &#x3D;&#x3D;&#x3D; 1) &#123;\n      return key;\n    &#125;\n  &#125;\n&#125;;\n\n题解 2&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  &#x2F;&#x2F; let one &#x3D; 0, two &#x3D; 0;\n  let ans &#x3D; 0;\n  for (let i &#x3D; 0; i &lt; 32; i++) &#123;\n    let count &#x3D; 0;\n    for (let j &#x3D; 0; j &lt; nums.length; j++) &#123;\n      count +&#x3D; (nums[j] &gt;&gt; i) &amp; 1;\n    &#125;\n    ans +&#x3D; count % 3 &lt;&lt; i;\n  &#125;\n\n  return ans;\n&#125;;\n&#x2F;&#x2F; 统计每一位 是0或者是1\n\n题解 3&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;number&#125;\n *&#x2F;\nvar singleNumber &#x3D; function (nums) &#123;\n  &#x2F;&#x2F; let one &#x3D; 0, two &#x3D; 0;\n  let onceseen &#x3D; 0,\n    secondseen &#x3D; 0;\n  for (let x of nums) &#123;\n    onceseen &#x3D; ~secondseen &amp; (onceseen ^ x);\n    secondseen &#x3D; ~onceseen &amp; (secondseen ^ x);\n  &#125;\n  return onceseen;\n&#125;;\n\n138 复制带随机指针的链表分析\n题解&#x2F;**\n * Definition for a Node.\n * function Node(val, next, random) &#123;\n *    this.val &#x3D; val;\n *    this.next &#x3D; next;\n *    this.random &#x3D; random;\n * &#125;;\n *&#x2F;\n\n&#x2F;**\n * @param &#123;Node&#125; head\n * @return &#123;Node&#125;\n *&#x2F;\nvar copyRandomList &#x3D; function (head) &#123;\n  let p &#x3D; head;\n  while (p) &#123;\n    &#x2F;&#x2F; 复制小弟\n    let q &#x3D; new Node(p.val);\n    q.next &#x3D; p.next;\n    p.next &#x3D; q;\n    p &#x3D; q.next;\n  &#125;\n  &#x2F;&#x2F; 复制随机的边\n  for (let p &#x3D; head; p; p &#x3D; p.next.next) &#123;\n    if (p.random) &#123;\n      p.next.random &#x3D; p.random.next;\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 拆分链表\n  let dummy &#x3D; new Node(-1),\n    cur &#x3D; dummy;\n\n  for (let p &#x3D; head; p; p &#x3D; p.next) &#123;\n    let q &#x3D; p.next; &#x2F;&#x2F; 小弟\n    cur &#x3D; cur.next &#x3D; q;\n    p.next &#x3D; q.next;\n  &#125;\n\n  return dummy.next;\n&#125;;\n\n141. 环形链表分析\n快慢指针 有环的话快指针能追上慢指针\n\n题解&#x2F;**\n * Definition for singly-linked list.\n * function ListNode(val) &#123;\n *     this.val &#x3D; val;\n *     this.next &#x3D; null;\n * &#125;\n *&#x2F;\n\n&#x2F;**\n * @param &#123;ListNode&#125; head\n * @return &#123;boolean&#125;\n *&#x2F;\nvar hasCycle &#x3D; function (head) &#123;\n  if (!head) return false;\n\n  let fast &#x3D; head,\n    slow &#x3D; head;\n\n  while (fast &amp;&amp; fast.next) &#123;\n    fast &#x3D; fast.next.next;\n    slow &#x3D; slow.next;\n\n    if (fast &#x3D;&#x3D;&#x3D; slow) return true;\n  &#125;\n\n  return false;\n&#125;;\n\n142. 环形链表 II分析\na = c + (n-1) (b+c)\n题解var detectCycle &#x3D; function (head) &#123;\n  if (head &#x3D;&#x3D;&#x3D; null) &#123;\n    return null;\n  &#125;\n  let slow &#x3D; head,\n    fast &#x3D; head;\n  while (fast !&#x3D;&#x3D; null) &#123;\n    slow &#x3D; slow.next;\n    if (fast.next !&#x3D;&#x3D; null) &#123;\n      fast &#x3D; fast.next.next;\n    &#125; else &#123;\n      return null;\n    &#125;\n    if (fast &#x3D;&#x3D;&#x3D; slow) &#123;\n      let ptr &#x3D; head;\n      while (ptr !&#x3D;&#x3D; slow) &#123;\n        ptr &#x3D; ptr.next;\n        slow &#x3D; slow.next;\n      &#125;\n      return ptr;\n    &#125;\n  &#125;\n  return null;\n&#125;;\n\n143 重排链表分析\n快慢指针 倒置后一半的链表 然后合并\n\n题解&#x2F;**\n * Definition for singly-linked list.\n * function ListNode(val, next) &#123;\n *     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)\n *     this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next)\n * &#125;\n *&#x2F;\n&#x2F;**\n * @param &#123;ListNode&#125; head\n * @return &#123;void&#125; Do not return anything, modify head in-place instead.\n *&#x2F;\nvar reorderList &#x3D; function (head) &#123;\n  if (!head) return null;\n  let dummy &#x3D; new ListNode(-1);\n  let tail &#x3D; dummy;\n\n  dummy.next &#x3D; head;\n  let fast &#x3D; dummy,\n    slow &#x3D; dummy;\n\n  while (fast &amp;&amp; fast.next) &#123;\n    slow &#x3D; slow.next;\n    fast &#x3D; fast.next.next;\n  &#125;\n\n  let cur &#x3D; new ListNode(-1);\n  cur &#x3D; slow.next;\n  slow.next &#x3D; null;\n\n  let tem &#x3D; new ListNode(-1);\n\n  while (cur) &#123;\n    let c &#x3D; cur.next;\n    cur.next &#x3D; tem.next;\n    tem.next &#x3D; cur;\n    cur &#x3D; c;\n  &#125;\n  cur &#x3D; head;\n  tem &#x3D; tem.next;\n  dummy.next &#x3D; null;\n  tail &#x3D; dummy;\n  while (cur || tem) &#123;\n    if (cur) &#123;\n      dummy &#x3D; dummy.next &#x3D; cur;\n      cur &#x3D; cur.next;\n    &#125;\n    if (tem) &#123;\n      dummy &#x3D; dummy.next &#x3D; tem;\n      tem &#x3D; tem.next;\n    &#125;\n  &#125;\n\n  return tail.next;\n&#125;;\n\n144. 二叉树的前序遍历代码&#x2F;&#x2F; 递归\nvar preorderTraversal &#x3D; function (root) &#123;\n  let res &#x3D; [];\n  let stack &#x3D; [];\n\n  while (root || stack.length) &#123;\n    while (root) &#123;\n      res.push(root.val);\n      stack.push(root);\n      root &#x3D; root.left;\n    &#125;\n\n    let top &#x3D; stack.pop();\n    root &#x3D; top.right;\n  &#125;\n\n  return res;\n&#125;;\n\n145 二叉树的后序遍历代码&#x2F;&#x2F; 方式一\nvar postorderTraversal &#x3D; function (root) &#123;\n  let res &#x3D; [];\n  let stack &#x3D; [];\n  let prev &#x3D; null;\n  while (root || stack.length) &#123;\n    while (root) &#123;\n      stack.push(root);\n      root &#x3D; root.left;\n    &#125;\n\n    root &#x3D; stack.pop();\n\n    if (root.right &#x3D;&#x3D;&#x3D; null || root.right &#x3D;&#x3D;&#x3D; prev) &#123;\n      res.push(root.val);\n      prev &#x3D; root;\n      root &#x3D; null;\n    &#125; else &#123;\n      stack.push(root);\n      root &#x3D; root.right;\n    &#125;\n  &#125;\n\n  return res;\n&#125;;\n\n&#x2F;&#x2F; 方式二\nvar postorderTraversal &#x3D; function (root) &#123;\n  let res &#x3D; [];\n  let stack &#x3D; [];\n\n  while (root || stack.length) &#123;\n    while (root) &#123;\n      res.push(root.val);\n      stack.push(root);\n      root &#x3D; root.right;\n    &#125;\n\n    root &#x3D; stack.pop().left;\n  &#125;\n\n  return res.reverse();\n&#125;;\n\n\n\n146 LRU缓存机制分析\n用hash表存储每一个节点 然后用一个双链表来表示优先级 每次更新的节点全部放到链表头 不使用的放在链表尾部，这样就可以解决了排序的问题 同时删除节点的时候 需要删除的东西都在链表尾部 做到了O(1)的时间复杂度\n\n题解\nfunction Node(key, value) &#123;\n    this.value &#x3D; value\n    this.key &#x3D; key;\n    this.left &#x3D; null;\n    this.right &#x3D; null\n&#125;\n\nvar LRUCache &#x3D; function (capacity) &#123;\n    this.size &#x3D; 0\n    this.capacity &#x3D; capacity\n    this.head &#x3D; new Node(-1, -1);\n    this.tail &#x3D; new Node(-1, -1)\n    this.head.right &#x3D; this.tail;\n    this.tail.left &#x3D; this.head;\n    this.container &#x3D; new Map()\n&#125;;\n\nLRUCache.prototype.remove &#x3D; function remove(node) &#123;\n    node.right.left &#x3D; node.left;\n    node.left.right &#x3D; node.right\n&#125;\n\nLRUCache.prototype.addToHead &#x3D; function addToHead(node) &#123;\n    node.left &#x3D; this.head\n    node.right &#x3D; this.head.right\n    this.head.right.left &#x3D; node\n    this.head.right &#x3D; node;\n\n&#125;\n\n\nLRUCache.prototype.moveToHead &#x3D; function moveToHead(node) &#123;\n    this.remove(node)\n    this.addToHead(node)\n&#125;\n\n\nLRUCache.prototype.removeTail &#x3D; function removeTail() &#123;\n    let node &#x3D; this.tail.left;\n    this.remove(node)\n    return node\n&#125;\n\nLRUCache.prototype.get &#x3D; function (key) &#123;\n    if (!this.container.has(key)) &#123;\n        return -1\n    &#125;\n\n    let p &#x3D; this.container.get(key);\n    this.moveToHead(p);\n    return p.value;\n\n&#125;;\n\nLRUCache.prototype.put &#x3D; function (key, value) &#123;\n    if (!this.container.has(key)) &#123;\n        let node &#x3D; new Node(key, value);\n        this.container.set(key, node);\n        this.addToHead(node);\n        this.size++;\n        if (this.size &gt; this.capacity) &#123;\n            let removedNode &#x3D; this.removeTail();\n            this.container.delete(removedNode.key);\n            delete removedNode;\n            this.size--;\n        &#125;\n    &#125; else &#123;\n        let node &#x3D; this.container.get(key);\n        node.value &#x3D; value;\n        this.moveToHead(node)\n    &#125;\n&#125;;\n\n\n\n147对链表进行插入排序题解var insertionSortList &#x3D; function (head) &#123;\n    if (!head) return null;\n    let dummy &#x3D; new ListNode();\n    dummy.next &#x3D; head;\n    head &#x3D; head.next;\n    dummy.next.next &#x3D; null;\n\n\n    while (head) &#123;\n        let tail &#x3D; dummy\n        let p &#x3D; dummy.next;\n        let c &#x3D; null;\n        while (p) &#123;\n            if (head.val &gt; p.val) &#123;\n                p &#x3D; p.next;\n                tail &#x3D; tail.next;\n            &#125; else &#123;\n                c &#x3D; head.next\n                tail.next &#x3D; head;\n                head.next &#x3D; p;\n                break;\n            &#125;\n\n        &#125;\n        if (!p) &#123;\n            tail.next &#x3D; head;\n            head &#x3D; head.next\n            tail.next.next &#x3D; null;\n        &#125; else &#123;\n\n            head &#x3D; c\n        &#125;\n    &#125;\n    return dummy.next;\n&#125;;\n\n\n\n","slug":"LeetCode","date":"2021-04-06T14:27:28.256Z","categories_index":"leetcode","tags_index":"leetcode","author_index":"麦当"}]