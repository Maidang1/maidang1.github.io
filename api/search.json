[{"id":"d99453202fb96ed4663408801fbf0008","title":"Vuex 源码分析","content":"vuex 简易实现\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102let Vue;class ModuleCollection &#123;  constructor(options) &#123;    this.register([], options);  &#125;  register(path, rootModule) &#123;    let module = &#123;      _rawModule: rootModule,      _children: &#123;&#125;,      state: rootModule.state,    &#125;;    if (path.length == 0) &#123;      this.root = module;    &#125;    if(rootModule.modules) &#123;      for    &#125;  &#125;&#125;class Store &#123;  constructor(options = &#123;&#125;) &#123;    // 状态赋值    this.s = new Vue(&#123;      data() &#123;        return &#123; state: options.state &#125;;      &#125;,    &#125;);    let getters = options.getters;    this.getters = &#123;&#125;;    Object.keys(getters).forEach((getterName) =&gt; &#123;      Object.defineProperty(this.getters, getterName, &#123;        get: () =&gt; &#123;          return getters[getterName](this.state);        &#125;,      &#125;);    &#125;);    let mutations = options.mutations;    this.mutations = &#123;&#125;;    // 发布订阅模式    Object.keys(mutations).forEach((mutation) =&gt; &#123;      this.mutations[mutation] = (payload) =&gt; &#123;        mutations[mutation](this.state, payload);      &#125;;    &#125;);    // action    let actions = options.actions;    this.action = &#123;&#125;;    Object.keys(actions).forEach((action) =&gt; &#123;      this.actions[action] = (payload, fn) =&gt; &#123;        fn(this, payload);      &#125;;    &#125;);    this._modules = new ModuleCollection(); // 数据格式化  &#125;  dispatch = (actionName, payload) =&gt; &#123;    this.action[actionName](payload);  &#125;;  //提交更改  commit = (mutationName, payload) =&gt; &#123;    this.mutations[mutationName](payload);  &#125;;  get state() &#123;    return this.s.state;  &#125;&#125;const install = (_Vue) =&gt; &#123;  Vue = _Vue; // vue构造函数  Vue.mixin(&#123;    beforeCreate() &#123;      // 需要拿到store 给每个组件增加了$store属性      // 可能有很多Vue实例 有的不需要store 没有放在Vue原型上面      if (this.$options &amp;&amp; this.$options.store) &#123;        // 给根实例增加$store属性        this.$store = this.$options.store;      &#125; else &#123;        // 单独创建的实例        this.store = this.$parent &amp;&amp; this.$parent.store;      &#125;    &#125;,  &#125;);&#125;;export default &#123;  // 默认执行 vue方法  install,&#125;;\n","slug":"vuex","date":"2021-04-06T14:27:28.497Z","categories_index":"vue","tags_index":"vuex,vue","author_index":"麦当"},{"id":"b491bd34f265533799a79211838a0e41","title":"Vue3 响应式原理","content":"简单的实现 Vue3 响应式原理\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110let toProxy = new WeakMap(); // 原对象：代理过得对象let toRaw = new WeakMap(); // 被代理过得对象: 原对象function isObject(val) &#123;  return typeof val === &#x27;object&#x27; &amp;&amp; val !== null;&#125;function reactive(target) &#123;  return createReactiveObject(target);&#125;function hasOwn(target, key) &#123;  return target.hasOwnProperty(key);&#125;let proxy = reactive(&#123; name: &#x27;zf&#x27; &#125;);function createReactiveObject(target) &#123;  if (!isObject(target)) return target;  // 处理多次代理的操作  let proxy = toProxy.get(target);  if (proxy) return proxy;  if (toRaw.has(target)) return target;  let baseHandler = &#123;    get(target, key, receiver) &#123;      let res = Reflect.get(target, key, receiver);      // 实现多层代理      track(target, key);      return isObject(res) ? reactive(res) : res;    &#125;,    set(target, key, value, receiver) &#123;      let hadKey = hasOwn(target, key);      let oldValue = target[key];      let res = Reflect.set(target, key, value, receiver);      if (!hadKey) &#123;        // 增加属性        trigger(target, &#x27;add&#x27;, key);      &#125; else if (oldValue !== value) &#123;        // 修改属性 屏蔽没有意义的更新        trigger(target, &#x27;set&#x27;, key);      &#125;      return res;    &#125;,    deleteProperty(target, key) &#123;      let res = Reflect.defineProperty(target, key);      return res;    &#125;,  &#125;;  let proxy = new Proxy(target, baseHandler);  toProxy.set(target, proxy);  toRaw.set(proxy, target);  return proxy;&#125;// 依赖收集 发布订阅let activeEffectStacks = [];let targetsMap = new WeakMap();function track(target, key) &#123;  let effect = activeEffectStacks[activeEffectStacks.length - 1];  if (effect) &#123;    let depMap = targetsMap.get(target);    if (!depMap) &#123;      targetsMap.set(target, (depMap = new Map()));    &#125;    let deps = depMap.get(key);    if (!deps) &#123;      depMap, set(key, (deps = new Set()));    &#125;    if (!deps.has(effect)) &#123;      deps.add(effect);    &#125;  &#125;&#125;function trigger(target, type, key) &#123;  let depsMap = targetsMap.get(target);  if (depsMap) &#123;    let deps = depsMap.get(key);    if (deps) &#123;      deps.forEach((effect) =&gt; &#123;        effect();      &#125;);    &#125;  &#125;&#125;function effect(fn) &#123;  // fn是响应的  let effect = createReactiveEffect(fn);  effect();&#125;function createReactiveEffect(fn) &#123;  let effect = function () &#123;    return run(effect, fn);  &#125;;  return effect;&#125;function run(effect, fn) &#123;  try &#123;    activeEffectStacks.push(effect);    fn();  &#125; finally &#123;    activeEffectStacks.pop();  &#125;&#125;\n","slug":"vue3-reactive","date":"2021-04-06T14:27:28.471Z","categories_index":"vue","tags_index":"vue3","author_index":"麦当"},{"id":"eb7ed51aa22769817771964a330ff0d5","title":"dataFetchHook","content":"Encapsulating data request with hook\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; Fragment, useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;function App() &#123;  const [data, setData] = useState(&#123; hits: [] &#125;);  const [query, setQuery] = useState(&#x27;redux&#x27;);  const [url, setUrl] = useState(    &#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;  );  const [isLoading, setIsLoading] = useState(false);  const [isError, setIsError] = useState(false);  useEffect(() =&gt; &#123;    const fetchData = async () =&gt; &#123;      setIsError(false);      setIsLoading(true);      try &#123;        const result = await axios(url);        setData(result.data);      &#125; catch (error) &#123;        setIsError(true);      &#125;      setIsLoading(false);    &#125;;    fetchData();  &#125;, [url]);  return (    &lt;Fragment&gt;      &lt;input        type=&#x27;text&#x27;        value=&#123;query&#125;        onChange=&#123;(event) =&gt; setQuery(event.target.value)&#125;      /&gt;      &lt;button        type=&#x27;button&#x27;        onClick=&#123;() =&gt;          setUrl(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`)        &#125;      &gt;        Search      &lt;/button&gt;      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125;      &#123;isLoading ? (        &lt;div&gt;Loading ...&lt;/div&gt;      ) : (        &lt;ul&gt;          &#123;data.hits.map((item) =&gt; (            &lt;li key=&#123;item.objectID&#125;&gt;              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;            &lt;/li&gt;          ))&#125;        &lt;/ul&gt;      )&#125;    &lt;/Fragment&gt;  );&#125;export default App;\n\nCustom hook123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React, &#123; Fragment, useState, useEffect &#125; from &#x27;react&#x27;;import axios from &#x27;axios&#x27;;const useDataApi = (initialUrl, initialData) =&gt; &#123;  const [data, setData] = useState(initialData);  const [url, setUrl] = useState(initialUrl);  const [isLoading, setIsLoading] = useState(false);  const [isError, setIsError] = useState(false);  useEffect(() =&gt; &#123;    const fetchData = async () =&gt; &#123;      setIsError(false);      setIsLoading(true);      try &#123;        const result = await axios(url);        setData(result.data);      &#125; catch (error) &#123;        setIsError(true);      &#125;      setIsLoading(false);    &#125;;    fetchData();  &#125;, [url]);  return [&#123; data, isLoading, isError &#125;, setUrl];&#125;;function App() &#123;  const [query, setQuery] = useState(&#x27;redux&#x27;);  const [&#123; data, isLoading, isError &#125;, doFetch] = useDataApi(    &#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;,    &#123;      hits: [],    &#125;  );  return (    &lt;Fragment&gt;      &lt;form        onSubmit=&#123;(event) =&gt; &#123;          doFetch(`http://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`);          event.preventDefault();        &#125;&#125;      &gt;        &lt;input          type=&#x27;text&#x27;          value=&#123;query&#125;          onChange=&#123;(event) =&gt; setQuery(event.target.value)&#125;        /&gt;        &lt;button type=&#x27;submit&#x27;&gt;Search&lt;/button&gt;      &lt;/form&gt;      &#123;isError &amp;&amp; &lt;div&gt;Something went wrong ...&lt;/div&gt;&#125;      &#123;isLoading ? (        &lt;div&gt;Loading ...&lt;/div&gt;      ) : (        &lt;ul&gt;          &#123;data.hits.map((item) =&gt; (            &lt;li key=&#123;item.objectID&#125;&gt;              &lt;a href=&#123;item.url&#125;&gt;&#123;item.title&#125;&lt;/a&gt;            &lt;/li&gt;          ))&#125;        &lt;/ul&gt;      )&#125;    &lt;/Fragment&gt;  );&#125;export default App;\n","slug":"useFetchData","date":"2021-04-06T14:27:28.438Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"ba2efac7316616866db1719079267951","title":"Symbol 基础学习","content":"Symbol 内置符号\nECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道 for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义 Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。\n\n\n\nSymbol.asyncIterator\n1234567891011121314151617181920// for-await-of 实现调用class Emitter &#123;  constructor(max) &#123;    this.max = max;    this.asyncIdx = 0;  &#125;  async *[Symbol.asyncIterator]() &#123;    while (this.asyncIdx &lt; this.max) &#123;      yield new Promise((resolve) =&gt; resolve(this.asyncIdx++));    &#125;  &#125;&#125;async function asyncCount() &#123;  let emitter = new Emitter(5);  for await (const x of emitter) &#123;    console.log(x);  &#125;&#125;asyncCount();// 0 1 2 3 4\n\nSymbol.hasInstance\n1// instanceof 调用\n\nSymbol.isConcatSpreadable\n1234567891011// 使用concat的时候会不会被打平let initial = [&#x27;foo&#x27;];let arrayLikeObject = &#123; length: 1, 0: &#x27;baz&#x27; &#125;;console.log(arrayLikeObject[Symbol.isConcatSpreadable]); // undefinedconsole.log(initial.concat(arrayLikeObject)); // [&#x27;foo&#x27;, &#123;...&#125;]arrayLikeObject[Symbol.isConcatSpreadable] = true;console.log(initial.concat(arrayLikeObject)); // [&#x27;foo&#x27;, &#x27;baz&#x27;]/*  [ &#x27;foo&#x27;, &#123; &#x27;0&#x27;: &#x27;baz&#x27;, length: 1 &#125; ]  [ &#x27;foo&#x27;, &#x27;baz&#x27; ]*/\n\nSymbol.iterator\n123456789101112131415161718class Emitter &#123;  constructor(max) &#123;    this.max = max;    this.idx = 0;  &#125;  *[Symbol.iterator]() &#123;    while (this.idx &lt; this.max) &#123;      yield this.idx++;    &#125;  &#125;&#125;function count() &#123;  let emitter = new Emitter(5);  for (const x of emitter) &#123;    console.log(x);  &#125;&#125;count();\n\nSymbol.match\n1// String.prototype.match() 调用\n\nSymbol.replaceSymbol.searchSymbol.split\nSymbol.toPrimitiveSymbol.toStringTag\n","slug":"symbol","date":"2021-04-06T14:27:28.412Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"f45f275952c50e73ccfd35d25a4b9c92","title":"redux && redux-middleware","content":"redux\n\n1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createStore &#125; from &#x27;redux&#x27;;let INC = Symbol.for(&#x27;INC&#x27;);let DEC = Symbol.for(&#x27;DEC&#x27;);let initialState = 0;function reducer(state = initialState, action) &#123;  switch (action.type) &#123;    case INC:      return state + 1;    case DEC:      return state - 1;    default:      return state;  &#125;&#125;/** * redux action有要求 有个不是undefined的type类型 */let store = createStore(reducer);let state = store.getState();let countValue = document.getElementById(&#x27;counter-value&#x27;);let inc = document.getElementById(&#x27;inc-btn&#x27;);let dec = document.getElementById(&#x27;dec-btn&#x27;);console.log(state);function render() &#123;  countValue.innerHTML = store.getState();&#125;render();store.subscribe(render);inc.addEventListener(&#x27;click&#x27;, function () &#123;  store.dispatch(&#123; type: INC &#125;);&#125;);dec.addEventListener(&#x27;click&#x27;, function () &#123;  store.dispatch(&#123; type: DEC &#125;);&#125;);\n\ncreate-store.js(版本一)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import isPlainObject from &#x27;./utils/isPlainObject&#x27;;import ActionTypes from &#x27;./utils/actionType&#x27;;export default function createStore(reducer, preloadedState) &#123;  if (typeof reducer !== &#x27;function&#x27;) &#123;    throw new Error(&#x27;reducer must be a function&#x27;);  &#125;  /*******************************/  /** initiallize the base property  */  let currentState = preloadedState;  let currentReducer = reducer;  let currentListeners = [];  /*******************************/  function getState() &#123;    return currentState;  &#125;  function dispatch(action) &#123;    if (!isPlainObject(action)) &#123;      throw new Error(&#x27;action must be a plainObject&#x27;);    &#125;    if (typeof action.type === &#x27;undefined&#x27;) &#123;      throw new Error(&#x27;action need a type property&#x27;);    &#125;    currentState = currentReducer(currentState, action);    for (let i = 0; i &lt; currentListeners.length; i++) &#123;      let listener = currentListeners[i];      listener();    &#125;    return action;  &#125;  dispatch(&#123; type: ActionTypes.INIT &#125;);  function subScribe(listener) &#123;    currentListeners.push(listener);    return function unsubScribe() &#123;      const index = currentListeners.indexOf(listener);      currentListeners.splice(index, 1);    &#125;;  &#125;  return &#123;    getState,    subScribe,    dispatch,  &#125;;&#125;\n\nbindActionCreator123456789101112131415161718function bindActionCreator(actionCreator, dispatch) &#123;  return function () &#123;    return dispatch(actionCreator.apply(this, arguments));  &#125;;&#125;function bindActionCreators(actionCreators, dispatch) &#123;  if (typeof actionCreators === &#x27;function&#x27;) &#123;    return bindActionCreator(actionCreators, dispatch);  &#125;  const boundActionCreators = &#123;&#125;;  for (const key in actionCreators) &#123;    boundActionCreators[key] = bindActionCreator(actionCreators[key], dispatch);  &#125;  return boundActionCreators;&#125;export default bindActionCreators;\n\ncombineReducer12345678910111213141516export default function combineReducer(reducers) &#123;  const reducerkeys = Object.keys(reducers);  return function (state = &#123;&#125;, action) &#123;    let nextState = &#123;&#125;;    for (let i = 0; i &lt; reducerkeys.length; i++) &#123;      const key = reducerkeys[i];      const reducer = reducers[key];      const previousStateForKey = state[key];      const nextStateForkey = reducer(previousStateForKey, action);      nextState[key] = nextStateForkey;    &#125;    return nextState;  &#125;;&#125;\n\nutil123456789101112export default function isPlainObject(obj) &#123;  if (typeof obj !== &#x27;object&#x27; || obj === null) &#123;    return false;  &#125;  let proto = obj;  while (Object.getPrototypeOf(proto)) &#123;    proto = Object.getPrototypeOf(proto);  &#125;  return Object.getPrototypeOf(obj) === proto;&#125;\n\napplyMiddleWare1234567891011121314151617181920212223function applyMiddleWare(...middlewares) &#123;  return function (createStore) &#123;    return function (reducer) &#123;      let store = createStore();      let dispath = () =&gt; &#123;        throw new Error();      &#125;;      let middlewareAPI = &#123;        getStore: store.getState,        dispatch: (...args) =&gt; dispath(...args),      &#125;;      // middleware = middleware(store);      // dispath = middleware(store.dispatch);      const chain = middlewares.map((middleware) =&gt; middleware(middlewareAPI));      dispath = componse(...chain)(store.dispatch)      return &#123;        ...store,        dispath,      &#125;;    &#125;;  &#125;;&#125;\n\ncompose123456789101112function compose(...funcs) &#123;  if (funcs.length === 0) &#123;    return (args) =&gt; args;  &#125;  if (funcs.length === 1) &#123;    return funcs[0];  &#125;  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));&#125;export default compose;\n\nreact-reudxindex.js1234import Provider from &#x27;./Provider&#x27;;import connect from &#x27;./connect&#x27;;export &#123; Provider, connect &#125;;\n\nProvider.js1234567891011121314import React, &#123; Component &#125; from &#x27;react&#x27;;import ReduxContext from &#x27;./context&#x27;;class Provider extends Component &#123;  render() &#123;    return (      &lt;ReduxContext.Provider value=&#123;this.props.store&#125;&gt;        &#123;this.props.children&#125;      &lt;/ReduxContext.Provider&gt;    );  &#125;&#125;export default Provider;\n\nconnect.js123456789101112131415161718192021222324252627282930import React from &#x27;react&#x27;;import ReduxContext from &#x27;./context&#x27;;import bindActionCreator from &#x27;../redux/bindActionCreator&#x27;;export default function connect(mapStateToProps, mapDispatchToProps) &#123;  return function (WrappedComponent) &#123;    return class extends React.Component &#123;      static contextType = ReduxContext;      constructor(props, context) &#123;        super(props);        /** context = &#123;store: this.props.store&#125; */        this.state = mapDispatchToProps(context.store.getState());      &#125;      componentDidCatch() &#123;        this.unsubscribe = this.context.store.subscribe(() =&gt; &#123;          this.setState(mapStateToProps(this.context.store.getState()));        &#125;);      &#125;      componentWillUnmount() &#123;        this.unsubscribe();      &#125;      render() &#123;        let action = bindActionCreator(          mapDispatchToProps,          this.context.store.dispatch        );        return &lt;WrappedComponent &#123;...this.state&#125; &#123;...action&#125; /&gt;;      &#125;    &#125;;  &#125;;&#125;\n\ncontext.js1234import React from &#x27;react&#x27;;const ReduxContext = React.createContext(null);export default ReduxContext;\n\nredux-promise12345678910111213141516function isPromise(obj) &#123;  return (    !!obj &amp;&amp;    (typeof obj === &#x27;object&#x27; || typeof obj === &#x27;function&#x27;) &amp;&amp;    typeof obj.then === &#x27;function&#x27;  );&#125;export default function (&#123; dispatch, getState &#125;) &#123;  return (next) =&gt; (action) =&gt; &#123;    return isPromise(action.payload)      ? action.payload.then((result) =&gt; &#123;          dispatch(&#123; ...action, payload: result &#125;);        &#125;)      : next(action);  &#125;;&#125;\n\nreudx-thunk1234567891011function createThunkMiddleware() &#123;  return (&#123; dispatch, getState &#125; /** middlewareAPI */) =&gt; (next) =&gt; (    action  ) =&gt; &#123;    if (typeof action === &#x27;function&#x27;) &#123;      return action(dispatch, getState);    &#125;    return next(action);  &#125;;&#125;\n","slug":"redux && redux-middleware","date":"2021-04-06T14:27:28.404Z","categories_index":"React","tags_index":"React,redux,redux-middleware","author_index":"麦当"},{"id":"89dff2a6379feafc73b36875ccf71035","title":"react-setState","content":"react-state 流程\n\nindex.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** 事务 用wrapper包装起来 */class Transaction &#123;  constructor(wrappers) &#123;    this.wrappers = wrappers;  &#125;  /** AOP 编程概念  */  perform(anyMethod) &#123;    this.wrappers.forEach((wrapper) =&gt; wrapper.initialize());    anyMethod();    this.wrappers.forEach((wrapper) =&gt; wrapper.close());  &#125;&#125;let batchingStrategy = &#123;  isBatchingStrates: false /** 标记是否是批量更新模式 */,  dirtyComponent: [] /** 脏组件 组件的状态和UI不匹配  */,  batchedUpdates() &#123;    /** 执行所有的更新操作 */    this.dirtyComponent.forEach((component) =&gt; component.updateComonent());  &#125;,&#125;;class Updater &#123;  constructor(component) &#123;    this.component = component;    this.pendingState = [];  &#125;  addState(partcialState) &#123;    this.pendingState.push(partcialState);    /** 判断是不是批量更新模式 如果是批量更新 将组件放到脏组件里 做到异步更新 */    batchingStrategy.isBatchingStrates      ? batchingStrategy.dirtyComponent.push(this.component)      : this.component.updateComonent();  &#125;&#125;class Component &#123;  constructor(props) &#123;    this.props = props;    this.$updater = new Updater(this);  &#125;  createDOMFromDOMString(domString) &#123;    let div = document.createElement(&#x27;div&#x27;);    div.innerHTML = domString;    return div.children[0];  &#125;  setState(partcialState) &#123;    this.$updater.addState(partcialState);  &#125;  /** 组件的更新方法 合并所有的状态 然后进行统一的页面元素UI的替换 */  updateComonent() &#123;    this.$updater.pendingState.forEach((partcialState) =&gt;      Object.assign(this.setState, partcialState)    );    this.$updater.pendingState.length = 0; /** 清空队列 */    let oldElemet = this.domElement;    let newElement = this.renderElement();    oldElemet.parentElement.replaceChild(newElement, oldElemet);  &#125;  /** 创建页面元素 */  renderElement() &#123;    let htmlString = this.render();    this.domElement = this.createDOMFromDOMString(htmlString);    this.domElement.component = this;    return this.domElement;  &#125;  /** 组件的挂载方法  */  mount(container) &#123;    container.appendChild(this.renderElement());  &#125;&#125;let transaction = new Transaction([  &#123;    initialize() &#123;      /** 事件开启的时候进入批量更新模式  */      batchingStrategy.isBatchingStrates = true;    &#125;,    close() &#123;      /** 事件结束的时候关闭批量更新模式  */      batchingStrategy.isBatchingStrates = false;      /** 脏组件进行状态的更新 */      batchingStrategy.batchedUpdates();    &#125;,  &#125;,]);/** 统一的事件处理 挂载到全局  */window.trigger = function (event, mothodName) &#123;  /** 拿到组件的实例(事件委托) 执行绑定的方法 */  let component = event.target.component;  /** wrapper包装起来 处理一些相关的事件 */  transaction.perform(component[mothodName].bind(component));&#125;;/** 子组件 */class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; number: 0 &#125;;  &#125;  add() &#123;    this.setState(&#123; number: this.state.number + 1 &#125;);  &#125;  render() &#123;    return `&lt;button onclick=&quot;trigger(event, &#x27;add&#x27;)&quot;&gt;$&#123;this.state.number&#125;&lt;/button&gt;`;  &#125;&#125;\n\nindex.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;count-app&quot;&gt;&lt;/div&gt;  &lt;/body&gt;  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    let countApp = document.getElementById(&#x27;count-app&#x27;);    let res = new Counter().render();    res.mount(countApp);  &lt;/script&gt;&lt;/html&gt;\n","slug":"react-setState","date":"2021-04-06T14:27:28.394Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"50552075ed1d1cbaae410e21993db179","title":"react-router-dom","content":"BrowserRouter\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123; Component &#125; from &#x27;react&#x27;;import Context from &#x27;./context&#x27;;let pushState = window.history.pushState;class HashRouter extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      location: &#123; pathname: window.location.pathname, state: null &#125;,    &#125;;  &#125;  componentDidMount() &#123;    window.history.pushState = (state, title, url) =&gt; &#123;      pushState.call(window.history, state, title, url);      window.onpushstate.call(this, state, url);    &#125;;    window.onpopstate = (event) =&gt; &#123;      this.setState(&#123;        location: &#123;          ...this.state.location,          pathname: window.location.pathname,          state: event.state,        &#125;,      &#125;);    &#125;;    window.onpushstate = (state, pathname) =&gt; &#123;      this.setState(&#123;        location: &#123;          ...this.state.location,          pathname: pathname,          state: state,        &#125;,      &#125;);    &#125;;  &#125;  render() &#123;    let that = this;    let value = &#123;      location: that.state.location,      history: &#123;        push(to) &#123;          /** 阻止跳转 */          if (that.block) &#123;            let confirm = window.confirm(              that.block(typeof to === &#x27;object&#x27; ? to : &#123; pathname: to &#125;)            );            if (!confirm) return;          &#125;          if (typeof to === &#x27;object&#x27;) &#123;            let &#123; pathname, state &#125; = to;            window.history.pushState(state, &#x27;&#x27;, pathname);          &#125; else &#123;            window.history.pushState(null, &#x27;&#x27;, to);          &#125;        &#125;,        block(message) &#123;          that.block = message;        &#125;,      &#125;,    &#125;;    return (      &lt;Context.Provider value=&#123;value&#125;&gt;&#123;this.props.children&#125;&lt;/Context.Provider&gt;    );  &#125;&#125;export default HashRouter;\n\ncontext123456/** 暴露出整个库的context上下文  */import React from &#x27;react&#x27;;const Context = React.createContext();export default Context;\n\nHashRouter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123; Component &#125; from &#x27;react&#x27;;import Context from &#x27;./context&#x27;;class HashRouter extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      location: &#123; pathname: window.location.hash.slice(1), state: null &#125;,    &#125;;    this.locationState = null;  &#125;  componentDidMount() &#123;    window.location.hash = window.location.hash || &#x27;/&#x27;;    window.addEventListener(&#x27;hashchange&#x27;, () =&gt; &#123;      this.setState(&#123;        location: &#123;          ...this.state.location,          pathname: window.location.hash.slice(1),          state: this.locationState,        &#125;,      &#125;);    &#125;);  &#125;  render() &#123;    let that = this;    let value = &#123;      location: that.state.location,      history: &#123;        push(to) &#123;          /** 阻止跳转 */          if (that.block) &#123;            let confirm = window.confirm(              that.block(typeof to === &#x27;object&#x27; ? to : &#123; pathname: to &#125;)            );            if (!confirm) return;          &#125;          if (typeof to === &#x27;object&#x27;) &#123;            let &#123; pathname, state &#125; = to;            that.locationState = state;            window.location.hash = pathname;          &#125; else &#123;            that.locationState = null;            window.location.hash = to;          &#125;        &#125;,        block(message) &#123;          that.block = message;        &#125;,      &#125;,    &#125;;    return (      &lt;Context.Provider value=&#123;value&#125;&gt;&#123;this.props.children&#125;&lt;/Context.Provider&gt;    );  &#125;&#125;export default HashRouter;\n\nLink1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from &#x27;react&#x27;;import Context from &#x27;./context&#x27;;class Link extends Component &#123;  static contextType = Context;  constructor(props) &#123;    super(props);    this.state = &#123;&#125;;  &#125;  render() &#123;    /** 注意合并上部传来的props */    return (      // eslint-disable-next-line jsx-a11y/anchor-is-valid      &lt;a        &#123;...this.props&#125;        onClick=&#123;() =&gt; &#123;          this.props.context.history.push(this.props.to);        &#125;&#125;      &gt;        &#123;this.props.children&#125;      &lt;/a&gt;    );  &#125;&#125;export default Link;/** * &lt;a href=&#123;`#$&#123;this.props.to&#125;`&#125;&gt;&#123;this.props.children&#125;&lt;/a&gt;; */\n\nMenuLink1234567891011121314151617181920212223import React, &#123; Component &#125; from &#x27;react&#x27;;import Route from &#x27;./Route&#x27;;import Link from &#x27;./Link&#x27;;/**自定义导航 正增加高亮属性 *//** Route渲染内容有三种方法 component render children */// component render 路径匹配渲染// children 都会渲染function MenuLink(&#123; to, exact, children &#125;) &#123;  return (    &lt;Route      path=&#123;to&#125;      exact=&#123;exact&#125;      children=&#123;(props) =&gt; (        &lt;li className=&#123;props.match ? &#x27;active&#x27; : &#x27;&#x27;&#125;&gt;          &lt;Link to=&#123;to&#125;&gt;&#123;children&#125;&lt;/Link&gt;        &lt;/li&gt;      )&#125;    &gt;&lt;/Route&gt;  );&#125;export default MenuLink;\n\nPrompt12345678910111213141516171819202122import React, &#123; Component &#125; from &#x27;react&#x27;;import Context from &#x27;./context&#x27;;class Prompt extends Component &#123;  static contextType = Context;  componentWillUnmount() &#123;    this.history.block(null);  &#125;  render() &#123;    let history = this.context.history;    const &#123; when, messaga &#125; = this.props;    if (when) &#123;      history.block(messaga);    &#125; else &#123;      history.block(null);    &#125;    return null;  &#125;&#125;export default Prompt;\n\nRedirect1234567891011import &#123; Component &#125; from &#x27;react&#x27;;import Context from &#x27;./context&#x27;;class Redirect extends Component &#123;  static contextType = Context;  render() &#123;    this.context.history.push(this.props.to);    return null;  &#125;&#125;export default Redirect;\n\nRoute123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import PathToRegexp from &#x27;path-to-regexp&#x27;;import React, &#123; Component &#125; from &#x27;react&#x27;;import Context from &#x27;./context&#x27;;class Route extends Component &#123;  static contextType = Context;  constructor(props) &#123;    super(props);    this.state = &#123;&#125;;  &#125;  render() &#123;    let &#123; pathname &#125; = this.context.location;    let &#123;      path = &#x27;/&#x27;,      component: Component,      exact = false,      render,      children,    &#125; = this.props;    let paramNames = [];    let regxp = PathToRegexp(path, paramNames, &#123; end: exact &#125;);    let result = pathname.match(regxp);    let props = &#123;      location: this.context.location,      history: this.props.history,    &#125;;    if (result) &#123;      paramNames = paramNames.map((item) =&gt; item.name);      let [url, ...values] = result;      let params = &#123;&#125;;      for (let i = 0; i &lt; paramNames.length; i++) &#123;        params[paramNames[i]] = values[i];      &#125;      props.match = &#123; params, path, url, isExect: url === pathname &#125;;      if (Component) &#123;        return &lt;Component &#123;...props&#125; /&gt;;      &#125; else if (render) &#123;        /** 检查属性 兼容性 */        return render(props);      &#125; else if (children) &#123;        return children(props);      &#125; else &#123;        return null;      &#125;    &#125; else &#123;      if (children) return children(props);      else return null;    &#125;  &#125;&#125;export default Route;\n\nSwitch123456789101112131415161718192021222324252627import &#123; Component &#125; from &#x27;react&#x27;;import PathToRegexp from &#x27;path-to-regexp&#x27;;class Switch extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;&#125;;  &#125;  render() &#123;    let &#123; pathname &#125; = this.context.location;    let children = Array.isArray(this.props.children)      ? this.props      : [this.props.children];    for (let i = 0; i &lt; children.length; i++) &#123;      let child = children[i];      let &#123; path = &#x27;/&#x27;, exect = false &#125; = child.props;      let pathNames = [];      let reg = PathToRegexp(path, pathNames, &#123; end: exect &#125;);      let result = pathname.match(reg);      if (result) &#123;        return child; /** react的元素 React.createElement */      &#125;    &#125;    return null;  &#125;&#125;export default Switch;\n\nWithRouter1234567import React from &#x27;react&#x27;;import Route from &#x27;./Route&#x27;;// eslint-disable-next-line import/no-anonymous-default-exportexport default function (WrappedComponent) &#123;  return (props) =&gt; &lt;Route component=&#123;WrappedComponent&#125; /&gt;;&#125;\n","slug":"react-router-dom","date":"2021-04-06T14:27:28.383Z","categories_index":"React","tags_index":"React,react-router-dom","author_index":"麦当"},{"id":"fa08fd35cb36d755ed7492a61cf66138","title":"react Hooks","content":"useState\n\n每次渲染都是一个独立的闭包\n每次渲染都会有自己的 props 和 state\n每次渲染后会有自己的时间处理函数\n\n123456789101112131415function Counter() &#123;  let [num, setNum] = useState(0);  function alertNum() &#123;    setTimeout(() =&gt; &#123;      alert(num);    &#125;, 3000);  &#125;  return (    &lt;div&gt;      &lt;p&gt;&#123;num&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setNum&#125;&gt;&lt;/button&gt;      &lt;button onClick=&#123;alertNum&#125;&gt;alert&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n1234567891011121314151617function Counter() &#123;  let [num, setNum] = useState(0);  function lazy()&#123;    setTimeout((      // 有差别 -     setNum(num + 1); -     setNum(num =&gt; num + 1);    )=&gt;&#123;&#125;, 3000)  &#125;  return (    &lt;div&gt;      &lt;p&gt;&#123;num&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setNum&#125;&gt;&lt;/button&gt;      &lt;button onClick=&#123;lazy&#125;&gt;lazy&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n惰性初始化\n1234567891011function Counter(props) &#123;  let [counter, setCounter] = useState(function () &#123;    return &#123; num: props.num &#125;;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;&#123;counter.num&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCounter&#125;&gt;&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\nefect每次我们重新渲染 都会生成新的 effect 替换之前的 effect 属于渲染结果的一部分 effect 属于特定的渲染\n","slug":"react-hook","date":"2021-04-06T14:27:28.370Z","categories_index":"React","tags_index":"React,react hook","author_index":"麦当"},{"id":"b9a37f021de474295d3010955ace362e","title":"react base","content":"生命周期(老版)\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123; Component &#125; from &#x27;react&#x27;;class LifeCycle extends Component &#123;  /**组件的静态属性 */  static defaultProps = &#123; name: &#x27;计数器&#x27; &#125;;  constructor(props) &#123;    /** setup props and state */    super(props);    this.state = &#123; number: 0 &#125;;    console.log(&#x27;setup&#x27;);  &#125;  componentWillMount() &#123;    console.log(&#x27;2 组件将要挂载&#x27;);  &#125;  componentDidMount() &#123;    console.log(&#x27;4.组件挂载完成&#x27;);  &#125;  shouldComponentUpdate() &#123;    console.log(&#x27;5. 询问组件是否要更新&#x27;);    return true;  &#125;  componentWillUpdate() &#123;    console.log(&#x27;6 组件将要更新&#x27;);  &#125;  componentDidUpdate() &#123;    console.log(&#x27;7 组件已经更新完毕&#x27;);  &#125;  add = () =&gt; &#123;    this.setState(&#123;      number: this.state.number + 1,    &#125;);  &#125;;  render() &#123;    console.log(&#x27;parent render&#x27;);    return (      &lt;div&gt;        &lt;p&gt;&#123;this.state.name&#125;&lt;/p&gt;        &lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt;        &lt;Sub /&gt;      &lt;/div&gt;    );  &#125;&#125;export default LifeCycle;class Sub extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; age: 10 &#125;;  &#125;  componentWillReceiveProps() &#123;    console.log(&#x27;componentWillReceiveProps&#x27;);  &#125;  render() &#123;    console.log(&#x27;children render&#x27;);    return (      &lt;div&gt;        &lt;p&gt;age:&#123;this.state.age&#125;&lt;/p&gt;        &lt;button          onClick=&#123;() =&gt; &#123;            this.setState(&#123; age: this.state.age + 1 &#125;);          &#125;&#125;        &gt;&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n生命周期新版\ngetDerivedStateFromProps1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from &#x27;react&#x27;;class Counter extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; number: 0 &#125;;  &#125;  add = () =&gt; &#123;    this.setState(&#123;      number: this.state.number + 1,    &#125;);  &#125;;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt;        &lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt;        &lt;SubCounter number=&#123;this.state.number&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;class SubCounter extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; number: 0 &#125;;  &#125;  /** 将State和Props传来的值全部整合到state上 */  static getDerivedStateFromProps(nextProps, prevState) &#123;    if (nextProps.number % 2 === 0) &#123;      return &#123; number: nextProps.number * 2 &#125;;    &#125; else &#123;      return &#123; number: nextProps.number * 3 &#125;;    &#125;  &#125;  render() &#123;    return &lt;div&gt;&#123;this.state.number&#125;&lt;/div&gt;;  &#125;&#125;export default Counter;\n\ngetSnapshotBeforeUpdate12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from &#x27;react&#x27;;class getSnapshotBeforeUpdateComponent extends Component &#123;  constructor(props) &#123;    super(props);    this.wrapper = React.createRef();    this.state = &#123; message: [&#x27;5&#x27;, &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;] &#125;;  &#125;  componentDidMount() &#123;    setInterval(() =&gt; &#123;      this.setState(&#123;        message: [this.state.message.length, ...this.state.message],      &#125;);    &#125;, 1000);  &#125;  getSnapshotBeforeUpdate() &#123;    return this.wrapper.current.scrollHeight;  &#125;  componentDidUpdate(prevProps, prevState, scrollHeight) &#123;    let Dom = this.wrapper.current;    Dom.scrollTop = Dom.scrollTop + (Dom.scrollHeight - scrollHeight);  &#125;  render() &#123;    let style = &#123;      height: &#x27;100p&#x27;,      width: &#x27;200px&#x27;,      border: &#x27;1px solid red&#x27;,      overflow: &#x27;auto&#x27;,    &#125;;    return (      &lt;div style=&#123;style&#125; ref=&#123;this.wrapper&#125;&gt;        &lt;ul&gt;          &#123;this.state.message.map((item, index) =&gt; &#123;            return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;;          &#125;)&#125;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;export default getSnapshotBeforeUpdateComponent;\n\ncontext(上下文)旧版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123; Component &#125; from &#x27;react&#x27;;import propTypes from &#x27;prop-types&#x27;;class Page extends Component &#123;  static childContextTypes = &#123;    color: propTypes.string,    setColor: propTypes.func,  &#125;;  getChildContext() &#123;    return &#123; color: &#x27;gray&#x27;, setColor: this.setColor &#125;;  &#125;  setColor = (color) =&gt; &#123;    this.setColor(&#123; color &#125;);  &#125;;  constructor() &#123;    super();    this.state = &#123; color: &#x27;gray&#x27; &#125;;  &#125;  render() &#123;    return (      &lt;&gt;        &lt;Header&gt;          &lt;Title&gt;&lt;/Title&gt;        &lt;/Header&gt;        &lt;Main&gt;          &lt;Content&gt;&lt;/Content&gt;        &lt;/Main&gt;      &lt;/&gt;    );  &#125;&#125;class Header extends Component &#123;  render() &#123;    return (      &lt;div&gt;        Header        &lt;Title&gt;&lt;/Title&gt;      &lt;/div&gt;    );  &#125;&#125;class Title extends Component &#123;  /** 子集关系 */  static contextTypes = &#123;    color: propTypes.string,    setColor: propTypes.func,  &#125;;  /**   * this.context.color   * this.context.setColor   */  render() &#123;    return &lt;div&gt;Title&lt;/div&gt;;  &#125;&#125;class Main extends Component &#123;  render() &#123;    return (      &lt;div&gt;        Main        &lt;Content&gt;&lt;/Content&gt;      &lt;/div&gt;    );  &#125;&#125;class Content extends Component &#123;  render() &#123;    return &lt;div&gt;Content&lt;/div&gt;;  &#125;&#125;export default Page;\n\n新版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// import &#123; func &#125; from &#x27;prop-types&#x27;;import React, &#123; Component &#125; from &#x27;react&#x27;;// import propTypes from &#x27;prop-types&#x27;;const ThemeContext = React.createContext();/** * ThemeContext = &#123;Provider Consumer&#125; * *//**-------- createContext -----------------------------------*/function createContext() &#123;  class Provider extends Component &#123;    static value;    constructor(props) &#123;      super(props);      Provider.value = props.value;    &#125;    render() &#123;      return this.props.children;    &#125;  &#125;  class Consumer extends Component &#123;    render() &#123;      return this.props.children(Provider.value);    &#125;  &#125;  return &#123; Provider, Consumer &#125;;&#125;/**----------------------------------------------------------- */class Page extends Component &#123;  constructor() &#123;    super();    this.state = &#123; color: &#x27;gray&#x27; &#125;;  &#125;  setColor(color) &#123;    this.setState(&#123; color &#125;);  &#125;  render() &#123;    let ctx = &#123; color: &#x27;gray&#x27;, setColor: this.setColor &#125;;    return (      &lt;ThemeContext.Provider value=&#123;ctx&#125;&gt;        &lt;Header&gt;          &lt;Title&gt;&lt;/Title&gt;        &lt;/Header&gt;        &lt;Main&gt;          &lt;Content&gt;&lt;/Content&gt;        &lt;/Main&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;class Header extends Component &#123;  /**----------------------------------------------- */  static contextType = ThemeContext;  /**----------------------------------------------- */  /**   * this.context 拿到了所有的值   */  render() &#123;    return (      &lt;div&gt;        Header        &lt;Title&gt;&lt;/Title&gt;      &lt;/div&gt;    );  &#125;&#125;function Title(props) &#123;  return &lt;div&gt;title&lt;/div&gt;;&#125;class Main extends Component &#123;  render() &#123;    return (      &lt;div&gt;        Main        &lt;Content&gt;&lt;/Content&gt;      &lt;/div&gt;    );  &#125;&#125;class Content extends Component &#123;  render() &#123;    return &lt;div&gt;Content&lt;/div&gt;;  &#125;&#125;export default Page;\n\npureComponent12345678910111213141516171819202122232425262728293031323334353637import React, &#123; PureComponent &#125; from &#x27;react&#x27;;class Title extends PureComponent &#123;  render() &#123;    return &lt;div&gt;&#123;this.props.title&#125;&lt;/div&gt;;  &#125;&#125;class Counter extends PureComponent &#123;  render() &#123;    return &lt;div&gt;&#123;this.props.number&#125;&lt;/div&gt;;  &#125;&#125;export default class App extends PureComponent &#123;  constructor(props) &#123;    super(props);    this.props = props;    this.state = &#123; title: &#x27;计数器&#x27;, number: 0 &#125;;    this.inputRef = React.createRef();  &#125;  add = () =&gt; &#123;    this.setState(&#123;      number: this.state.number + parseInt(this.inputRef.current.value),    &#125;);  &#125;;  render() &#123;    return (      &lt;div&gt;        &lt;Title title=&#123;this.state.title&#125; /&gt;        &lt;Counter number=&#123;this.state.number&#125; /&gt;        &lt;input ref=&#123;inputRef&#125; /&gt;        &lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from &#x27;react&#x27;;export default class PureComponent extends Component &#123;  isPureComponent = true;  shouldComponentUpdate(nextProps, nextState) &#123;    return (      !shallowEqual(this.props, nextProps) ||      !shallowEqual(this.state, nextState)    );  &#125;  render() &#123;    return &lt;div&gt;1&lt;/div&gt;;  &#125;&#125;function shallowEqual(obj1, obj2) &#123;  if (obj1 === obj2) return true;  if (    typeof obj1 !== &#x27;object&#x27; ||    obj1 === null ||    typeof obj2 !== &#x27;object&#x27; ||    obj2 === null  ) &#123;    return false;  &#125;  let keys1 = Object.keys(obj1);  let keys2 = Object.keys(obj2);  if (keys1.length !== keys2.length) return false;  for (let key of keys1) &#123;    if (!obj2.hasOwnProperty(key)) &#123;      if (obj1[key] !== obj2[key]) &#123;        if (typeof obj1[key] === &#x27;object&#x27; &amp;&amp; typeof obj2[key] === &#x27;object&#x27;) &#123;          return shallowEqual(obj1[key], obj2[key]);        &#125;      &#125; else &#123;        return false;      &#125;    &#125;  &#125;  return true;&#125;\n\nmemo1234567891011import React, &#123; PureComponent &#125; from &#39;react&#39;;function memo(FunComponent) &#123;  return class Proxy extends PureComponent &#123;    render() &#123;      return FunComponent(this.props)    &#125;  &#125;;&#125;export default memo;\n\n高阶组件123456789101112131415161718192021&#x2F;** * 高阶函数 传入一个函数 返回一个新的函数 * 高阶组件 传入一个组件 返回一个新的组件 *&#x2F;import React from &#39;react&#39;;export default function withLogger(Comp) &#123;  return class extends React.Component &#123;    componentWillMount() &#123;      this.start &#x3D; Date.now();    &#125;    componentDidMount() &#123;      console.log(Date.now() - this.start + &#39;ms&#39;);    &#125;    render() &#123;      return &lt;Comp &#123;...this.props&#125; &#x2F;&gt;;    &#125;  &#125;;&#125;\n\nrender props12345678910111213141516171819202122232425262728293031&lt;MouseTracker&gt;\t&#123;        (props)&#x3D;&gt;&lt;Pirture &#123;...props&#125;&#x2F;&gt;    &#125;&lt;&#x2F;MouseTracker&gt;import React, &#123; Component &#125; from &#39;react&#39;;class MouseTracker extends Component &#123;  constructor(props) &#123;    super(props);    this.state &#x3D; &#123; x: 0, y: 0 &#125;;  &#125;  handleMouseMove &#x3D; (event) &#x3D;&gt; &#123;    this.setState(&#123;      x: event.clientX,      y: event.clientY,    &#125;);  &#125;;  render() &#123;    return (      &lt;div onMouseOver&#x3D;&#123;this.handleMouseMove&#125;&gt;            &#x2F;* 执行子组件 函数组件*&#x2F;        &#123;this.props.children(&#123; x: this.state.x, y: this.state.y &#125;)&#125;      &lt;&#x2F;div&gt;    );  &#125;&#125;export default MouseTracker;\n\nFrament1&lt;React.Fragment&gt;\n\nprotal1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class Modal extends Component &#123;  constructor(props) &#123;    super(props);    this.modal = document.getElementById(&#x27;modal-root&#x27;);  &#125;  render() &#123;    return ReactDOM.createPortal(this.props.children, this.modal);  &#125;&#125;class Page extends Component &#123;  constructor(prop) &#123;    super(prop);    this.state = &#123; show: false &#125;;  &#125;  toggleModal = () =&gt; &#123;    this.setState(&#123;      show: !this.state.show,    &#125;);  &#125;;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.toggleModal&#125;&gt;关闭/显示&lt;/button&gt;        &#123;this.state.show &amp;&amp; (          &lt;Modal&gt;            &lt;div id=&#x27;modal&#x27; className=&#x27;modal&#x27;&gt;              &lt;div id=&#x27;content&#x27; className=&#x27;content&#x27;&gt;                Modal              &lt;/div&gt;            &lt;/div&gt;          &lt;/Modal&gt;        )&#125;      &lt;/div&gt;    );  &#125;&#125;export default Page;\n\n错误边界12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from &#x27;react&#x27;;class ErrorBoundary extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasErrors: false &#125;;  &#125;  /* 捕获异常 检查错误*/  componentDidCatch(err, info) &#123;    if (err) &#123;      this.setState(&#123;        hasErrors: true,      &#125;);    &#125;  &#125;  render() &#123;    if (this.state.hasErrors) &#123;      return &lt;div&gt; error&lt;/div&gt;;    &#125; else &#123;      return this.props.children;    &#125;  &#125;&#125;class Clock extends Component &#123;  render() &#123;    return &lt;div&gt;&#123;Date.now()&#125;&lt;/div&gt;;  &#125;&#125;class page extends Component &#123;  render() &#123;    return (      &lt;ErrorBoundary&gt;        &lt;Clock /&gt;      &lt;/ErrorBoundary&gt;    );  &#125;&#125;export default page;\n","slug":"react-base","date":"2021-04-06T14:27:28.342Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"764ea20144bdcb36de34ee7af78c0567","title":"proxy 基础学习","content":"代理基础什么是代理\n代理是目标对象的抽象，类似于 c++的指针，可以用作目标的替身，又独立目标之外。\n\n\n1234567891011const target = &#123;  id: &#x27;target&#x27;,&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);console.log(proxy.id);// proxy的prototype是undefined\n\n定义捕获器\n1234567891011121314const target = &#123;  id: &#x27;target&#x27;,&#125;;const handler = &#123;  get() &#123;    return &#x27;handler override&#x27;;  &#125;,&#125;;const proxy = new Proxy(target, handler);console.log(proxy.id);// 只有代理才会产生捕获 原来的目标没有这样的行为\n\n反射 API\n1234567891011121314const target = &#123;  id: &#x27;target&#x27;,&#125;;const handler = &#123;  get() &#123;    console.log(&#x27;get handler&#x27;);    return Reflect.get(...arguments);  &#125;,&#125;;const proxy = new Proxy(target, handler);console.log(&#x27;----------&#x27;, proxy.id);\n\n捕获器不变式\n12345678910111213const target = &#123;&#125;;Object.defineProperty(target, &#x27;foo&#x27;, &#123;  configurable: false,  writable: false,  value: &#x27;bar&#x27;,&#125;);const handler = &#123;  get() &#123;    return &#x27;qux&#x27;;  &#125;,&#125;;const proxy = new Proxy(target, handler);console.log(proxy.foo);\n\n撤销代理\n12345678910111213const target = &#123;  foo: &#x27;bar&#x27;,&#125;;const handler = &#123;  get() &#123;    return &#x27;intercepted&#x27;;  &#125;,&#125;;const &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);console.log(proxy.foo); // interceptedconsole.log(target.foo); // barrevoke();console.log(proxy.foo); // TypeError\n\n**实用反射 API **\n123456789101112131415161718// 很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功const o = &#123;&#125;;try &#123;  Object.defineProperty(o, &#x27;foo&#x27;, &#x27;bar&#x27;);  console.log(&#x27;success&#x27;);&#125; catch (e) &#123;  console.log(&#x27;failure&#x27;);&#125;// 使用代理之后// 在定义新属性时如果发生问题，Reflect.defineProperty()会返回 false，而不是抛出错误。// 因此使用这个反射方法可以这样重构上面的代码：// 重构后的代码const o = &#123;&#125;;if (Reflect.defineProperty(o, &#x27;foo&#x27;, &#123; value: &#x27;bar&#x27; &#125;)) &#123;  console.log(&#x27;success&#x27;);&#125; else &#123;  console.log(&#x27;failure&#x27;);&#125;\n\n其他的状态标记反射 API\n12345Reflect.defineProperty();Reflect.preventExtensions();Reflect.setPrototypeOf();Reflect.set();Reflect.deleteProperty();\n\n用一等函数替代操作符\n以下反射方法提供只有通过操作符才能完成的操作。\nReflect.get()：可以替代对象属性访问操作符。\nReflect.set()：可以替代=赋值操作符。\nReflect.has()：可以替代 in 操作符或 with()。\nReflect.deleteProperty()：可以替代 delete 操作符。\nReflect.construct()：可以替代 new 操作符。\n代理的问题\n123456789101112131415161718192021222324252627282930313233343536373839404142434445const wm = new WeakMap();class User &#123; constructor(userId) &#123; \twm.set(this, userId); &#125; set id(userId) &#123; \twm.set(this, userId); &#125; get id() &#123; \treturn wm.get(this); &#125;&#125;由于这个实现依赖 User 实例的对象标识，在这个实例被代理的情况下就会出问题：const user = new User(123);console.log(user.id); // 123const userInstanceProxy = new Proxy(user, &#123;&#125;);console.log(userInstanceProxy.id); // undefined// 这是因为 User 实例一开始使用目标对象作为 WeakMap 的键，代理对象却尝试从自身取得这个实// 例。要解决这个问题，就需要重新配置代理，把代理 User 实例改为代理 User 类本身。之后再创建代// 理的实例就会以代理实例作为 WeakMap 的键了：const UserClassProxy = new Proxy(User, &#123;&#125;);const proxyUser = new UserClassProxy(456);console.log(proxyUser.id);  //\n\n代理与内部槽位\n1234567891011/*代理与内置引用类型（比如 Array）的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError：*/const target = new Date();const proxy = new Proxy(target, &#123;&#125;);console.log(proxy instanceof Date); // trueproxy.getDate(); // TypeError: &#x27;this&#x27; is not a Date object\n\n代理捕获器get()\n12345678const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  get(target, property, receiver) &#123;    console.log(&#x27;get()&#x27;);    return Reflect.get(...arguments);  &#125;,&#125;);proxy.foo;\n\n拦截的操作\n\nproxy.property\nproxy[property]\nObject.create(proxy)[property]\nReflect.get(proxy, property, receiver)\n\nset\n123456789const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  set(target, property, value, receiver) &#123;    console.log(&#x27;set()&#x27;);    return Reflect.set(...arguments);  &#125;,&#125;);proxy.foo = &#x27;bar&#x27;;// 返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。\n\n拦截的操作\n\nproxy.property = value\nproxy[property] = value\nObject.create(proxy)[property] = value\nReflect.set(proxy, property, value, receiver)\n\nhas\n123456789const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  has(target, property) &#123;    console.log(&#x27;has()&#x27;);    return Reflect.has(...arguments);  &#125;,&#125;);&#x27;foo&#x27; in proxy;// has()\n\n\nproperty in proxy\nproperty in Object.create(proxy)\nwith(proxy) {(property);}\nReflect.has(proxy, property)\n\ndefineProperty()\n12345678910const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  defineProperty(target, property, descriptor) &#123;    console.log(&#x27;defineProperty()&#x27;);    return Reflect.defineProperty(...arguments);  &#125;,&#125;);Object.defineProperty(proxy, &#x27;foo&#x27;, &#123; value: &#x27;bar&#x27; &#125;);// Object.defineProperty(proxy, property, descriptor)// Reflect.defineProperty(proxy, property, descriptor)\n\ngetOwnPropertyDescriptor\n123456789101112const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  getOwnPropertyDescriptor(target, property) &#123;    console.log(&#x27;getOwnPropertyDescriptor()&#x27;);    return Reflect.getOwnPropertyDescriptor(...arguments);  &#125;,&#125;);Object.getOwnPropertyDescriptor(proxy, &#x27;foo&#x27;);// getOwnPropertyDescriptor()// Object.getOwnPropertyDescriptor(proxy, property)// Reflect.getOwnPropertyDescriptor(proxy, property)\n\ndeleteProperty\n1234567891011121314const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  deleteProperty(target, property) &#123;    console.log(&#x27;deleteProperty()&#x27;);    return Reflect.deleteProperty(...arguments);  &#125;,&#125;);delete proxy.foo;// deleteProperty()/*    delete proxy.property    delete proxy[property]    Reflect.deleteProperty(proxy, property)*/\n\nownKeys\n123456789101112131415const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  ownKeys(target) &#123;    console.log(&#x27;ownKeys()&#x27;);    return Reflect.ownKeys(...arguments);  &#125;,&#125;);Object.keys(proxy);// ownKeys()/*    Object.getOwnPropertyNames(proxy)    Object.getOwnPropertySymbols(proxy)    Object.keys(proxy)    Reflect.ownKeys(proxy)*/\n\ngetPrototypeOf\n12345678910111213141516const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  getPrototypeOf(target) &#123;    console.log(&#x27;getPrototypeOf()&#x27;);    return Reflect.getPrototypeOf(...arguments);  &#125;,&#125;);Object.getPrototypeOf(proxy);// getPrototypeOf()/*    Object.getPrototypeOf(proxy)    Reflect.getPrototypeOf(proxy)    proxy.__proto__    Object.prototype.isProt*/\n\nsetPrototypeOf\n1234567891011121314const myTarget = &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  setPrototypeOf(target, prototype) &#123;    console.log(&#x27;setPrototypeOf()&#x27;);    return Reflect.setPrototypeOf(...arguments);  &#125;,&#125;);Object.setPrototypeOf(proxy, Object);// setPrototypeOf()/*    Object.setPrototypeOf(proxy)    Reflect.setPrototypeOf(proxy)*/\n\nisExtensible\npreventExtensions\napply\n1234567891011121314const myTarget = () =&gt; &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  apply(target, thisArg, ...argumentsList) &#123;    console.log(&#x27;apply()&#x27;);    return Reflect.apply(...arguments);  &#125;,&#125;);proxy();/*    proxy(...argumentsList)    Function.prototype.apply(thisArg, argumentsList)    Function.prototype.call(thisArg, ...argumentsList)    Reflect.apply(target, thisArgument, argumentsList)*/\n\nconstruct\n12345678910111213const myTarget = function () &#123;&#125;;const proxy = new Proxy(myTarget, &#123;  construct(target, argumentsList, newTarget) &#123;    console.log(&#x27;construct()&#x27;);    return Reflect.construct(...arguments);  &#125;,&#125;);new proxy();// construct()/*    new proxy(...argumentsList)    Reflect.construct(target, argumentsList, newTarget)*/\n","slug":"proxy","date":"2021-04-06T14:27:28.313Z","categories_index":"JavaScript","tags_index":"JavaScript","author_index":"麦当"},{"id":"3a1de7864b72f88f991d2ad903723f46","title":"connected-react-router","content":"index.js\n\n12345import routerMiddlware from &#x27;./routerMiddlware&#x27;;import connectRouter from &#x27;./connectRouter&#x27;;import push from &#x27;./push&#x27;;import ConnectedRouter from &#x27;./ConnectedRouter&#x27;;export &#123; routerMiddlware, connectRouter, push, ConnectedRouter &#125;;\n\n\n\nconstants12export const CALL_HISTORY_METHOD = &#x27;@@router/CALL_HISTORY_METHOD&#x27;;export const LOCATION_CHANGE = &#x27;@@router/LOCATION_CHANGE&#x27;;\n\nConnectedRouter.js123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; ReactReduxContext &#125; from &#x27;react-redux&#x27;;import &#123; Route &#125; from &#x27;react-router&#x27;;import &#123; LOCATION_CHANGE &#125; from &#x27;./constants&#x27;;class ConnectedRouter extends Component &#123;  static contextType = ReactReduxContext;  constructor(props) &#123;    super(props);    this.state = &#123;&#125;;  &#125;  componentDidMount() &#123;    // location 新的路径    // action 新的动作 POP PUSH    this.unlistener = this.props.history.listen((location, action) =&gt; &#123;      this.context.store.dispatch(&#123;        type: LOCATION_CHANGE,        payload: &#123; location, action &#125;,      &#125;);    &#125;);  &#125;  componentWillUnmount() &#123;    this.unlistener();  &#125;  render() &#123;    let &#123; history, children &#125; = this.props;    return &lt;Route history=&#123;history&#125;&gt;&#123;children&#125;&lt;/Route&gt;;  &#125;&#125;export default ConnectedRouter;\n\nconnectRouter.js12345678910111213import &#123; LOCATION_CHANGE &#125; from &#x27;./constants&#x27;;// eslint-disable-next-line import/no-anonymous-default-exportexport default function (history) &#123;  let initialState = &#123; action: history.action, location: history.location &#125;;  return function (state = initialState, action) &#123;    switch (action.type) &#123;      case LOCATION_CHANGE:        return action.payload;      default:        return state;    &#125;  &#125;;&#125;\n\npush123456789101112import &#123; CALL_HISTORY_METHOD &#125; from &#x27;./constants&#x27;;function push(path) &#123;  return &#123;    type: CALL_HISTORY_METHOD,    payload: &#123;      method: &#x27;push&#x27;,      path,    &#125;,  &#125;;&#125;export default push;\n\nrouterMiddleware.js123456789101112import &#123; CALL_HISTORY_METHOD &#125; from &#x27;./constants&#x27;;// eslint-disable-next-line import/no-anonymous-default-exportexport default function (history) &#123;  return (&#123; dispatch, getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123;    if (action.type === CALL_HISTORY_METHOD) &#123;      let &#123; method, path &#125; = action.payload;      history[method](path);    &#125; else &#123;      next();    &#125;  &#125;;&#125;\n","slug":"connected-react-router","date":"2021-04-06T14:27:28.294Z","categories_index":"React","tags_index":"React","author_index":"麦当"},{"id":"20aabeefe97ee970307cf5d861ceb05e","title":"leetcode 加油站","content":"分析\n\n\n枚举每个站点 然后尝试从这个站点走n次, 如果可以顺利走了n 次的话 就是可以绕一周，就是题解，如果如果中途不可以继续走下去了，那个 i-j 中的子集部分也不可能走下去了。时间复杂度:O(n)空间复杂度:O(1)\n\n题解1234567891011121314151617181920212223/** * @param &#123;number[]&#125; gas * @param &#123;number[]&#125; cost * @return &#123;number&#125; */var canCompleteCircuit = function (gas, cost) &#123;  let n = gas.length;  let i, j;  for (i = 0; i &lt; n; ) &#123;    let left = 0;    for (j = 0; j &lt; n; j++) &#123;      let k = (i + j) % n;      left = left + gas[k] - cost[k];      if (left &lt; 0) break;    &#125;    if (j == n) return i;    else i += j + 1;  &#125;  return -1;&#125;;\n","slug":"134加油站","date":"2021-04-06T14:27:28.256Z","categories_index":"leetcode","tags_index":"leetcode","author_index":"麦当"}]